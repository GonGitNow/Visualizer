{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\fkuce\\\\OneDrive\\\\Desktop\\\\Money Projects\\\\Visualizer\\\\frontend\\\\src\\\\components\\\\VideoExporter.js\",\n  _s = $RefreshSig$();\nimport React, { useRef, useState, useEffect } from 'react';\nimport './VideoExporter.css';\n\n// Quality presets for different export options\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst QUALITY_PRESETS = {\n  high: {\n    videoBitrate: 8000000,\n    audioBitrate: 320000,\n    frameRate: 60,\n    label: 'High Quality'\n  },\n  medium: {\n    videoBitrate: 4000000,\n    audioBitrate: 192000,\n    frameRate: 30,\n    label: 'Medium Quality'\n  },\n  low: {\n    videoBitrate: 2000000,\n    audioBitrate: 128000,\n    frameRate: 30,\n    label: 'Low Quality'\n  }\n};\n\n// Export format options with MIME type checks\nconst EXPORT_FORMATS = {\n  webm: {\n    mimeType: 'video/webm;codecs=vp9,opus',\n    extension: 'webm',\n    label: 'WebM (VP9)',\n    fallback: null\n  },\n  mp4: {\n    mimeType: 'video/mp4;codecs=h264,aac',\n    extension: 'mp4',\n    label: 'MP4 (H.264)',\n    fallback: 'webm'\n  }\n};\n\n// Maximum number of retries for failed exports\nconst MAX_RETRIES = 3;\nconst VideoExporter = ({\n  visualizerRef,\n  audioFile,\n  isPlaying\n}) => {\n  _s();\n  const [isExporting, setIsExporting] = useState(false);\n  const [progress, setProgress] = useState(0);\n  const [debug, setDebug] = useState('');\n  const [selectedQuality, setSelectedQuality] = useState('high');\n  const [selectedFormat, setSelectedFormat] = useState('webm');\n  const [retryCount, setRetryCount] = useState(0);\n  const [supportedFormats, setSupportedFormats] = useState([]);\n  const mediaRecorderRef = useRef(null);\n  const chunksRef = useRef([]);\n  const startTimeRef = useRef(null);\n  const audioDurationRef = useRef(null);\n  const progressIntervalRef = useRef(null);\n  const dataRequestIntervalRef = useRef(null);\n  const audioContextRef = useRef(null);\n  const audioSourceRef = useRef(null);\n  const audioElementRef = useRef(null);\n  const originalAudioRef = useRef(null);\n  const originalIsPlayingRef = useRef(false);\n\n  // Check supported formats on component mount\n  useEffect(() => {\n    const checkSupportedFormats = () => {\n      const supported = Object.entries(EXPORT_FORMATS).filter(([_, format]) => MediaRecorder.isTypeSupported(format.mimeType)).map(([key]) => key);\n      setSupportedFormats(supported);\n      setDebug(`Supported formats: ${supported.join(', ')}`);\n\n      // If current format is not supported, switch to a supported one\n      if (!supported.includes(selectedFormat)) {\n        const fallbackFormat = EXPORT_FORMATS[selectedFormat].fallback;\n        if (fallbackFormat && supported.includes(fallbackFormat)) {\n          setSelectedFormat(fallbackFormat);\n          setDebug(`Switched to fallback format: ${fallbackFormat}`);\n        } else if (supported.length > 0) {\n          setSelectedFormat(supported[0]);\n          setDebug(`Switched to first supported format: ${supported[0]}`);\n        }\n      }\n    };\n    checkSupportedFormats();\n  }, []);\n\n  // Clean up on unmount\n  useEffect(() => {\n    return () => {\n      cleanupResources();\n    };\n  }, []);\n\n  // Store the original audio element and isPlaying state\n  useEffect(() => {\n    const audioElements = document.querySelectorAll('audio');\n    if (audioElements.length > 0) {\n      originalAudioRef.current = audioElements[0];\n      console.log('Found original audio element:', originalAudioRef.current);\n    }\n    originalIsPlayingRef.current = isPlaying;\n  }, [isPlaying]);\n\n  // Clean up resources function\n  const cleanupResources = () => {\n    if (originalIsPlayingRef.current && originalAudioRef.current) {\n      try {\n        originalAudioRef.current.play().catch(e => {\n          console.error('Error resuming original audio:', e);\n        });\n      } catch (e) {\n        console.error('Error resuming original audio:', e);\n      }\n    }\n    if (progressIntervalRef.current) {\n      clearInterval(progressIntervalRef.current);\n      progressIntervalRef.current = null;\n    }\n    if (dataRequestIntervalRef.current) {\n      clearInterval(dataRequestIntervalRef.current);\n      dataRequestIntervalRef.current = null;\n    }\n    if (audioSourceRef.current) {\n      try {\n        audioSourceRef.current.disconnect();\n      } catch (e) {\n        console.error('Error disconnecting audio source:', e);\n      }\n      audioSourceRef.current = null;\n    }\n    if (audioElementRef.current) {\n      try {\n        audioElementRef.current.pause();\n        audioElementRef.current.oncanplaythrough = null;\n        audioElementRef.current.onerror = null;\n        audioElementRef.current.onended = null;\n        audioElementRef.current.removeAttribute('src');\n        audioElementRef.current.load();\n      } catch (e) {\n        console.error('Error cleaning up audio element:', e);\n      }\n      audioElementRef.current = null;\n    }\n    if (audioContextRef.current && audioContextRef.current.state !== 'closed') {\n      try {\n        audioContextRef.current.close().catch(e => console.error('Error closing audio context:', e));\n      } catch (e) {\n        console.error('Error closing audio context:', e);\n      }\n      audioContextRef.current = null;\n    }\n    if (mediaRecorderRef.current && mediaRecorderRef.current.state === 'recording') {\n      try {\n        mediaRecorderRef.current.stop();\n      } catch (e) {\n        console.error('Error stopping media recorder:', e);\n      }\n      mediaRecorderRef.current = null;\n    }\n    chunksRef.current = [];\n  };\n\n  // Validate audio file\n  const validateAudioFile = () => {\n    if (!audioFile) {\n      setDebug('Error: No audio file selected');\n      return false;\n    }\n    if (!audioFile.path) {\n      setDebug('Error: Audio file has no path');\n      return false;\n    }\n    return true;\n  };\n\n  // Ensure visualizer is active\n  const ensureVisualizerActive = () => {\n    if (!(visualizerRef !== null && visualizerRef !== void 0 && visualizerRef.current)) {\n      setDebug('Error: Visualizer reference not available');\n      return false;\n    }\n    const canvas = visualizerRef.current.getCanvas();\n    if (!canvas) {\n      setDebug('Error: Canvas not found in visualizer');\n      return false;\n    }\n    try {\n      const ctx = canvas.getContext('2d');\n      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n      ctx.putImageData(imageData, 0, 0);\n      return true;\n    } catch (e) {\n      setDebug(`Error activating visualizer: ${e.message}`);\n      return false;\n    }\n  };\n\n  // Get canvas resolution\n  const getCanvasResolution = canvas => {\n    if (!canvas) return {\n      width: 0,\n      height: 0\n    };\n    const width = canvas.width;\n    const height = canvas.height;\n    console.log(`Canvas resolution: ${width}x${height}`);\n    setDebug(`Canvas resolution: ${width}x${height}`);\n    return {\n      width,\n      height\n    };\n  };\n\n  // Activate visualizer with original audio\n  const activateVisualizerWithOriginalAudio = async () => {\n    try {\n      const playButtons = document.querySelectorAll('button');\n      let playButton = null;\n      for (const button of playButtons) {\n        if (button.textContent.includes('Play') || button.className.includes('play') || button.title.includes('Play')) {\n          playButton = button;\n          break;\n        }\n      }\n      originalIsPlayingRef.current = isPlaying;\n      if (playButton && !isPlaying) {\n        setDebug('Clicking play button to activate visualizer');\n        playButton.click();\n        await new Promise(resolve => setTimeout(resolve, 500));\n        if (originalAudioRef.current) {\n          originalAudioRef.current.pause();\n          setDebug('Paused original audio to avoid duplication');\n        } else if (playButton) {\n          playButton.click();\n          setDebug('Clicked play button again to pause audio');\n        }\n        return true;\n      } else {\n        setDebug('Audio is already playing or play button not found');\n        return isPlaying;\n      }\n    } catch (e) {\n      setDebug(`Error activating visualizer: ${e.message}`);\n      return false;\n    }\n  };\n\n  // Retry mechanism for failed exports\n  const retryExport = async (exportFunction, maxRetries = MAX_RETRIES) => {\n    for (let i = 0; i < maxRetries; i++) {\n      try {\n        setRetryCount(i + 1);\n        setDebug(`Attempt ${i + 1} of ${maxRetries}`);\n        await exportFunction();\n        return;\n      } catch (error) {\n        if (i === maxRetries - 1) throw error;\n        setDebug(`Export failed, retrying in ${i + 1} seconds...`);\n        await new Promise(resolve => setTimeout(resolve, 1000 * (i + 1)));\n      }\n    }\n  };\n  const exportVideo = async () => {\n    if (!(visualizerRef !== null && visualizerRef !== void 0 && visualizerRef.current) || !audioFile) {\n      alert(\"Please upload an audio file first\");\n      return;\n    }\n    if (!validateAudioFile()) {\n      alert(\"Invalid audio file. Please upload a valid audio file.\");\n      return;\n    }\n    if (isExporting) {\n      console.log('Already exporting, ignoring request');\n      return;\n    }\n    try {\n      cleanupResources();\n      setIsExporting(true);\n      setProgress(0);\n      setDebug('Starting export process...');\n      startTimeRef.current = Date.now();\n\n      // First, ensure the visualizer is active and rendering\n      if (!ensureVisualizerActive()) {\n        throw new Error(\"Could not activate visualizer\");\n      }\n      const canvas = visualizerRef.current.getCanvas();\n      if (!canvas) {\n        throw new Error(\"Canvas element not found\");\n      }\n      const resolution = getCanvasResolution(canvas);\n      setDebug(`Canvas found, dimensions: ${resolution.width}x${resolution.height}`);\n\n      // Set up audio context first\n      const AudioContext = window.AudioContext || window.webkitAudioContext;\n      const audioContext = new AudioContext({\n        sampleRate: 48000\n      });\n      audioContextRef.current = audioContext;\n\n      // Create and set up audio element\n      const audioElement = new Audio();\n      audioElement.crossOrigin = \"anonymous\";\n      audioElement.preload = \"auto\";\n      audioElement.volume = 0;\n      audioElementRef.current = audioElement;\n\n      // Set up audio URL with timestamp to prevent caching\n      const timestamp = new Date().getTime();\n      const encodedPath = encodeURI(audioFile.path);\n      const audioUrl = `http://localhost:5001${encodedPath}?t=${timestamp}`;\n      setDebug(`Loading audio from: ${audioUrl}`);\n\n      // Load audio with promise\n      await new Promise((resolve, reject) => {\n        audioElement.oncanplaythrough = () => {\n          setDebug('Audio loaded successfully');\n          resolve();\n        };\n        audioElement.onerror = e => {\n          const errorDetail = e.target.error ? `${e.target.error.message || ''} (code: ${e.target.error.code})` : 'Unknown error';\n          setDebug(`Audio load error: ${errorDetail}`);\n          reject(new Error(`Audio load error: ${errorDetail}`));\n        };\n        audioElement.src = audioUrl;\n        audioElement.load();\n      });\n\n      // Store duration for progress tracking\n      audioDurationRef.current = audioElement.duration;\n      setDebug(`Audio duration: ${audioDurationRef.current.toFixed(2)} seconds`);\n\n      // Set up audio processing chain\n      const audioSource = audioContext.createMediaElementSource(audioElement);\n      audioSourceRef.current = audioSource;\n      const audioDestination = audioContext.createMediaStreamDestination();\n      const gainNode = audioContext.createGain();\n      gainNode.gain.value = 1.0;\n      audioSource.connect(gainNode);\n      gainNode.connect(audioDestination);\n\n      // Get audio tracks\n      const audioTracks = audioDestination.stream.getAudioTracks();\n      if (audioTracks.length === 0) {\n        throw new Error(\"No audio tracks available\");\n      }\n\n      // Set up canvas stream\n      let stream = null;\n      try {\n        stream = canvas.captureStream(QUALITY_PRESETS[selectedQuality].frameRate);\n      } catch (e) {\n        try {\n          stream = canvas.mozCaptureStream && canvas.mozCaptureStream(QUALITY_PRESETS[selectedQuality].frameRate);\n        } catch (e) {\n          try {\n            stream = canvas.webkitCaptureStream && canvas.webkitCaptureStream(QUALITY_PRESETS[selectedQuality].frameRate);\n          } catch (e) {\n            throw new Error(\"Browser doesn't support canvas streaming\");\n          }\n        }\n      }\n\n      // Get video tracks\n      const videoTracks = stream.getVideoTracks();\n      if (videoTracks.length === 0) {\n        throw new Error(\"No video tracks available\");\n      }\n\n      // Combine streams\n      const combinedStream = new MediaStream([...videoTracks, ...audioTracks]);\n\n      // Set up MediaRecorder\n      const selectedMimeType = EXPORT_FORMATS[selectedFormat].mimeType;\n      if (!MediaRecorder.isTypeSupported(selectedMimeType)) {\n        throw new Error(`Format ${EXPORT_FORMATS[selectedFormat].label} not supported`);\n      }\n      const options = {\n        mimeType: selectedMimeType,\n        videoBitsPerSecond: QUALITY_PRESETS[selectedQuality].videoBitrate,\n        audioBitsPerSecond: QUALITY_PRESETS[selectedQuality].audioBitrate\n      };\n      const mediaRecorder = new MediaRecorder(combinedStream, options);\n      mediaRecorderRef.current = mediaRecorder;\n\n      // Set up data handling\n      mediaRecorder.ondataavailable = event => {\n        if (event.data && event.data.size > 0) {\n          chunksRef.current.push(event.data);\n          const totalSize = chunksRef.current.reduce((size, chunk) => size + chunk.size, 0);\n          setDebug(`Chunk received: ${(event.data.size / 1024).toFixed(2)} KB, Total: ${(totalSize / 1024 / 1024).toFixed(2)} MB`);\n        }\n      };\n\n      // Set up recording stop handler\n      mediaRecorder.onstop = () => {\n        const totalSize = chunksRef.current.reduce((size, chunk) => size + chunk.size, 0);\n        setDebug(`Recording stopped. Total chunks: ${chunksRef.current.length}, Total size: ${(totalSize / 1024 / 1024).toFixed(2)} MB`);\n        if (totalSize === 0) {\n          throw new Error(\"No data was recorded\");\n        }\n\n        // Create and download blob\n        const blob = new Blob(chunksRef.current, {\n          type: selectedMimeType\n        });\n        const url = URL.createObjectURL(blob);\n        let fileName = \"visualization.\" + EXPORT_FORMATS[selectedFormat].extension;\n        if (audioFile && audioFile.name) {\n          fileName = audioFile.name.replace(/\\.[^/.]+$/, \"\") + \"_visualization.\" + EXPORT_FORMATS[selectedFormat].extension;\n        }\n        const a = document.createElement('a');\n        a.href = url;\n        a.download = fileName;\n        a.click();\n        URL.revokeObjectURL(url);\n        setIsExporting(false);\n        setProgress(100);\n        setDebug('Export completed successfully');\n        cleanupResources();\n      };\n\n      // Start recording with smaller timeslice for more frequent chunks\n      mediaRecorder.start(100);\n      setDebug('MediaRecorder started');\n\n      // Start audio playback\n      await audioElement.play();\n      setDebug('Audio playback started');\n\n      // Update progress\n      progressIntervalRef.current = setInterval(() => {\n        if (audioDurationRef.current) {\n          const elapsed = (Date.now() - startTimeRef.current) / 1000;\n          const percentage = Math.min(Math.floor(elapsed / audioDurationRef.current * 100), 99);\n          setProgress(percentage);\n          setDebug(`Progress: ${percentage}%, Duration: ${elapsed.toFixed(1)}s/${audioDurationRef.current.toFixed(1)}s`);\n        }\n      }, 500);\n\n      // Request data chunks periodically\n      dataRequestIntervalRef.current = setInterval(() => {\n        if (mediaRecorder.state === 'recording') {\n          mediaRecorder.requestData();\n        }\n      }, 1000);\n\n      // Stop recording when audio ends\n      audioElement.onended = () => {\n        setDebug('Audio playback ended, stopping recording');\n        if (dataRequestIntervalRef.current) {\n          clearInterval(dataRequestIntervalRef.current);\n        }\n        if (mediaRecorder.state === 'recording') {\n          mediaRecorder.requestData();\n          setTimeout(() => mediaRecorder.stop(), 500);\n        }\n      };\n    } catch (error) {\n      console.error(\"Error exporting video:\", error);\n      setDebug(`Export error: ${error.message}`);\n      if (retryCount < MAX_RETRIES) {\n        setDebug(`Retrying export (attempt ${retryCount + 1} of ${MAX_RETRIES})...`);\n        await retryExport(exportVideo);\n      } else {\n        alert(`Error exporting video: ${error.message}`);\n        setIsExporting(false);\n        cleanupResources();\n      }\n    }\n  };\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"video-exporter\",\n    children: isExporting ? /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"export-progress\",\n      children: [/*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"progress-bar\",\n        children: /*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"progress-fill\",\n          style: {\n            width: `${progress}%`\n          }\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 521,\n          columnNumber: 13\n        }, this)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 520,\n        columnNumber: 11\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"progress-text\",\n        children: [progress, \"% Exporting...\"]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 523,\n        columnNumber: 11\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"debug-info\",\n        children: debug\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 524,\n        columnNumber: 11\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 519,\n      columnNumber: 9\n    }, this) : /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"export-controls\",\n      children: [/*#__PURE__*/_jsxDEV(\"select\", {\n        value: selectedQuality,\n        onChange: e => setSelectedQuality(e.target.value),\n        className: \"quality-select\",\n        children: Object.entries(QUALITY_PRESETS).map(([key, preset]) => /*#__PURE__*/_jsxDEV(\"option\", {\n          value: key,\n          children: preset.label\n        }, key, false, {\n          fileName: _jsxFileName,\n          lineNumber: 534,\n          columnNumber: 15\n        }, this))\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 528,\n        columnNumber: 11\n      }, this), /*#__PURE__*/_jsxDEV(\"select\", {\n        value: selectedFormat,\n        onChange: e => setSelectedFormat(e.target.value),\n        className: \"format-select\",\n        disabled: supportedFormats.length <= 1,\n        children: Object.entries(EXPORT_FORMATS).filter(([key]) => supportedFormats.includes(key)).map(([key, format]) => /*#__PURE__*/_jsxDEV(\"option\", {\n          value: key,\n          children: format.label\n        }, key, false, {\n          fileName: _jsxFileName,\n          lineNumber: 546,\n          columnNumber: 17\n        }, this))\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 537,\n        columnNumber: 11\n      }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n        className: \"export-button\",\n        onClick: exportVideo,\n        disabled: !visualizerRef || !audioFile || isPlaying || supportedFormats.length === 0,\n        children: \"Export Video\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 549,\n        columnNumber: 11\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 527,\n      columnNumber: 9\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 517,\n    columnNumber: 5\n  }, this);\n};\n_s(VideoExporter, \"k6O9tR91WAUoOvX0I9xeL0Kj0Lw=\");\n_c = VideoExporter;\nexport default VideoExporter;\nvar _c;\n$RefreshReg$(_c, \"VideoExporter\");","map":{"version":3,"names":["React","useRef","useState","useEffect","jsxDEV","_jsxDEV","QUALITY_PRESETS","high","videoBitrate","audioBitrate","frameRate","label","medium","low","EXPORT_FORMATS","webm","mimeType","extension","fallback","mp4","MAX_RETRIES","VideoExporter","visualizerRef","audioFile","isPlaying","_s","isExporting","setIsExporting","progress","setProgress","debug","setDebug","selectedQuality","setSelectedQuality","selectedFormat","setSelectedFormat","retryCount","setRetryCount","supportedFormats","setSupportedFormats","mediaRecorderRef","chunksRef","startTimeRef","audioDurationRef","progressIntervalRef","dataRequestIntervalRef","audioContextRef","audioSourceRef","audioElementRef","originalAudioRef","originalIsPlayingRef","checkSupportedFormats","supported","Object","entries","filter","_","format","MediaRecorder","isTypeSupported","map","key","join","includes","fallbackFormat","length","cleanupResources","audioElements","document","querySelectorAll","current","console","log","play","catch","e","error","clearInterval","disconnect","pause","oncanplaythrough","onerror","onended","removeAttribute","load","state","close","stop","validateAudioFile","path","ensureVisualizerActive","canvas","getCanvas","ctx","getContext","imageData","getImageData","width","height","putImageData","message","getCanvasResolution","activateVisualizerWithOriginalAudio","playButtons","playButton","button","textContent","className","title","click","Promise","resolve","setTimeout","retryExport","exportFunction","maxRetries","i","exportVideo","alert","Date","now","Error","resolution","AudioContext","window","webkitAudioContext","audioContext","sampleRate","audioElement","Audio","crossOrigin","preload","volume","timestamp","getTime","encodedPath","encodeURI","audioUrl","reject","errorDetail","target","code","src","duration","toFixed","audioSource","createMediaElementSource","audioDestination","createMediaStreamDestination","gainNode","createGain","gain","value","connect","audioTracks","stream","getAudioTracks","captureStream","mozCaptureStream","webkitCaptureStream","videoTracks","getVideoTracks","combinedStream","MediaStream","selectedMimeType","options","videoBitsPerSecond","audioBitsPerSecond","mediaRecorder","ondataavailable","event","data","size","push","totalSize","reduce","chunk","onstop","blob","Blob","type","url","URL","createObjectURL","fileName","name","replace","a","createElement","href","download","revokeObjectURL","start","setInterval","elapsed","percentage","Math","min","floor","requestData","children","style","_jsxFileName","lineNumber","columnNumber","onChange","preset","disabled","onClick","_c","$RefreshReg$"],"sources":["C:/Users/fkuce/OneDrive/Desktop/Money Projects/Visualizer/frontend/src/components/VideoExporter.js"],"sourcesContent":["import React, { useRef, useState, useEffect } from 'react';\nimport './VideoExporter.css';\n\n// Quality presets for different export options\nconst QUALITY_PRESETS = {\n  high: {\n    videoBitrate: 8000000,\n    audioBitrate: 320000,\n    frameRate: 60,\n    label: 'High Quality'\n  },\n  medium: {\n    videoBitrate: 4000000,\n    audioBitrate: 192000,\n    frameRate: 30,\n    label: 'Medium Quality'\n  },\n  low: {\n    videoBitrate: 2000000,\n    audioBitrate: 128000,\n    frameRate: 30,\n    label: 'Low Quality'\n  }\n};\n\n// Export format options with MIME type checks\nconst EXPORT_FORMATS = {\n  webm: {\n    mimeType: 'video/webm;codecs=vp9,opus',\n    extension: 'webm',\n    label: 'WebM (VP9)',\n    fallback: null\n  },\n  mp4: {\n    mimeType: 'video/mp4;codecs=h264,aac',\n    extension: 'mp4',\n    label: 'MP4 (H.264)',\n    fallback: 'webm'\n  }\n};\n\n// Maximum number of retries for failed exports\nconst MAX_RETRIES = 3;\n\nconst VideoExporter = ({ visualizerRef, audioFile, isPlaying }) => {\n  const [isExporting, setIsExporting] = useState(false);\n  const [progress, setProgress] = useState(0);\n  const [debug, setDebug] = useState('');\n  const [selectedQuality, setSelectedQuality] = useState('high');\n  const [selectedFormat, setSelectedFormat] = useState('webm');\n  const [retryCount, setRetryCount] = useState(0);\n  const [supportedFormats, setSupportedFormats] = useState([]);\n  \n  const mediaRecorderRef = useRef(null);\n  const chunksRef = useRef([]);\n  const startTimeRef = useRef(null);\n  const audioDurationRef = useRef(null);\n  const progressIntervalRef = useRef(null);\n  const dataRequestIntervalRef = useRef(null);\n  const audioContextRef = useRef(null);\n  const audioSourceRef = useRef(null);\n  const audioElementRef = useRef(null);\n  const originalAudioRef = useRef(null);\n  const originalIsPlayingRef = useRef(false);\n  \n  // Check supported formats on component mount\n  useEffect(() => {\n    const checkSupportedFormats = () => {\n      const supported = Object.entries(EXPORT_FORMATS)\n        .filter(([_, format]) => MediaRecorder.isTypeSupported(format.mimeType))\n        .map(([key]) => key);\n      \n      setSupportedFormats(supported);\n      setDebug(`Supported formats: ${supported.join(', ')}`);\n      \n      // If current format is not supported, switch to a supported one\n      if (!supported.includes(selectedFormat)) {\n        const fallbackFormat = EXPORT_FORMATS[selectedFormat].fallback;\n        if (fallbackFormat && supported.includes(fallbackFormat)) {\n          setSelectedFormat(fallbackFormat);\n          setDebug(`Switched to fallback format: ${fallbackFormat}`);\n        } else if (supported.length > 0) {\n          setSelectedFormat(supported[0]);\n          setDebug(`Switched to first supported format: ${supported[0]}`);\n        }\n      }\n    };\n\n    checkSupportedFormats();\n  }, []);\n\n  // Clean up on unmount\n  useEffect(() => {\n    return () => {\n      cleanupResources();\n    };\n  }, []);\n\n  // Store the original audio element and isPlaying state\n  useEffect(() => {\n    const audioElements = document.querySelectorAll('audio');\n    if (audioElements.length > 0) {\n      originalAudioRef.current = audioElements[0];\n      console.log('Found original audio element:', originalAudioRef.current);\n    }\n    originalIsPlayingRef.current = isPlaying;\n  }, [isPlaying]);\n\n  // Clean up resources function\n  const cleanupResources = () => {\n    if (originalIsPlayingRef.current && originalAudioRef.current) {\n      try {\n        originalAudioRef.current.play().catch(e => {\n          console.error('Error resuming original audio:', e);\n        });\n      } catch (e) {\n        console.error('Error resuming original audio:', e);\n      }\n    }\n    \n    if (progressIntervalRef.current) {\n      clearInterval(progressIntervalRef.current);\n      progressIntervalRef.current = null;\n    }\n    \n    if (dataRequestIntervalRef.current) {\n      clearInterval(dataRequestIntervalRef.current);\n      dataRequestIntervalRef.current = null;\n    }\n    \n    if (audioSourceRef.current) {\n      try {\n        audioSourceRef.current.disconnect();\n      } catch (e) {\n        console.error('Error disconnecting audio source:', e);\n      }\n      audioSourceRef.current = null;\n    }\n    \n    if (audioElementRef.current) {\n      try {\n        audioElementRef.current.pause();\n        audioElementRef.current.oncanplaythrough = null;\n        audioElementRef.current.onerror = null;\n        audioElementRef.current.onended = null;\n        audioElementRef.current.removeAttribute('src');\n        audioElementRef.current.load();\n      } catch (e) {\n        console.error('Error cleaning up audio element:', e);\n      }\n      audioElementRef.current = null;\n    }\n    \n    if (audioContextRef.current && audioContextRef.current.state !== 'closed') {\n      try {\n        audioContextRef.current.close().catch(e => console.error('Error closing audio context:', e));\n      } catch (e) {\n        console.error('Error closing audio context:', e);\n      }\n      audioContextRef.current = null;\n    }\n    \n    if (mediaRecorderRef.current && mediaRecorderRef.current.state === 'recording') {\n      try {\n        mediaRecorderRef.current.stop();\n      } catch (e) {\n        console.error('Error stopping media recorder:', e);\n      }\n      mediaRecorderRef.current = null;\n    }\n    \n    chunksRef.current = [];\n  };\n\n  // Validate audio file\n  const validateAudioFile = () => {\n    if (!audioFile) {\n      setDebug('Error: No audio file selected');\n      return false;\n    }\n    \n    if (!audioFile.path) {\n      setDebug('Error: Audio file has no path');\n      return false;\n    }\n    \n    return true;\n  };\n\n  // Ensure visualizer is active\n  const ensureVisualizerActive = () => {\n    if (!visualizerRef?.current) {\n      setDebug('Error: Visualizer reference not available');\n      return false;\n    }\n    \n    const canvas = visualizerRef.current.getCanvas();\n    if (!canvas) {\n      setDebug('Error: Canvas not found in visualizer');\n      return false;\n    }\n    \n    try {\n      const ctx = canvas.getContext('2d');\n      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n      ctx.putImageData(imageData, 0, 0);\n      return true;\n    } catch (e) {\n      setDebug(`Error activating visualizer: ${e.message}`);\n      return false;\n    }\n  };\n\n  // Get canvas resolution\n  const getCanvasResolution = (canvas) => {\n    if (!canvas) return { width: 0, height: 0 };\n    \n    const width = canvas.width;\n    const height = canvas.height;\n    \n    console.log(`Canvas resolution: ${width}x${height}`);\n    setDebug(`Canvas resolution: ${width}x${height}`);\n    \n    return { width, height };\n  };\n\n  // Activate visualizer with original audio\n  const activateVisualizerWithOriginalAudio = async () => {\n    try {\n      const playButtons = document.querySelectorAll('button');\n      let playButton = null;\n      \n      for (const button of playButtons) {\n        if (button.textContent.includes('Play') || \n            button.className.includes('play') || \n            button.title.includes('Play')) {\n          playButton = button;\n          break;\n        }\n      }\n      \n      originalIsPlayingRef.current = isPlaying;\n      \n      if (playButton && !isPlaying) {\n        setDebug('Clicking play button to activate visualizer');\n        playButton.click();\n        \n        await new Promise(resolve => setTimeout(resolve, 500));\n        \n        if (originalAudioRef.current) {\n          originalAudioRef.current.pause();\n          setDebug('Paused original audio to avoid duplication');\n        } else if (playButton) {\n          playButton.click();\n          setDebug('Clicked play button again to pause audio');\n        }\n        \n        return true;\n      } else {\n        setDebug('Audio is already playing or play button not found');\n        return isPlaying;\n      }\n    } catch (e) {\n      setDebug(`Error activating visualizer: ${e.message}`);\n      return false;\n    }\n  };\n\n  // Retry mechanism for failed exports\n  const retryExport = async (exportFunction, maxRetries = MAX_RETRIES) => {\n    for (let i = 0; i < maxRetries; i++) {\n      try {\n        setRetryCount(i + 1);\n        setDebug(`Attempt ${i + 1} of ${maxRetries}`);\n        await exportFunction();\n        return;\n      } catch (error) {\n        if (i === maxRetries - 1) throw error;\n        setDebug(`Export failed, retrying in ${i + 1} seconds...`);\n        await new Promise(resolve => setTimeout(resolve, 1000 * (i + 1)));\n      }\n    }\n  };\n\n  const exportVideo = async () => {\n    if (!visualizerRef?.current || !audioFile) {\n      alert(\"Please upload an audio file first\");\n      return;\n    }\n    \n    if (!validateAudioFile()) {\n      alert(\"Invalid audio file. Please upload a valid audio file.\");\n      return;\n    }\n    \n    if (isExporting) {\n      console.log('Already exporting, ignoring request');\n      return;\n    }\n\n    try {\n      cleanupResources();\n      \n      setIsExporting(true);\n      setProgress(0);\n      setDebug('Starting export process...');\n      startTimeRef.current = Date.now();\n      \n      // First, ensure the visualizer is active and rendering\n      if (!ensureVisualizerActive()) {\n        throw new Error(\"Could not activate visualizer\");\n      }\n      \n      const canvas = visualizerRef.current.getCanvas();\n      if (!canvas) {\n        throw new Error(\"Canvas element not found\");\n      }\n      \n      const resolution = getCanvasResolution(canvas);\n      setDebug(`Canvas found, dimensions: ${resolution.width}x${resolution.height}`);\n      \n      // Set up audio context first\n      const AudioContext = window.AudioContext || window.webkitAudioContext;\n      const audioContext = new AudioContext({ sampleRate: 48000 });\n      audioContextRef.current = audioContext;\n      \n      // Create and set up audio element\n      const audioElement = new Audio();\n      audioElement.crossOrigin = \"anonymous\";\n      audioElement.preload = \"auto\";\n      audioElement.volume = 0;\n      audioElementRef.current = audioElement;\n      \n      // Set up audio URL with timestamp to prevent caching\n      const timestamp = new Date().getTime();\n      const encodedPath = encodeURI(audioFile.path);\n      const audioUrl = `http://localhost:5001${encodedPath}?t=${timestamp}`;\n      \n      setDebug(`Loading audio from: ${audioUrl}`);\n      \n      // Load audio with promise\n      await new Promise((resolve, reject) => {\n        audioElement.oncanplaythrough = () => {\n          setDebug('Audio loaded successfully');\n          resolve();\n        };\n        \n        audioElement.onerror = (e) => {\n          const errorDetail = e.target.error \n            ? `${e.target.error.message || ''} (code: ${e.target.error.code})` \n            : 'Unknown error';\n          setDebug(`Audio load error: ${errorDetail}`);\n          reject(new Error(`Audio load error: ${errorDetail}`));\n        };\n        \n        audioElement.src = audioUrl;\n        audioElement.load();\n      });\n      \n      // Store duration for progress tracking\n      audioDurationRef.current = audioElement.duration;\n      setDebug(`Audio duration: ${audioDurationRef.current.toFixed(2)} seconds`);\n      \n      // Set up audio processing chain\n      const audioSource = audioContext.createMediaElementSource(audioElement);\n      audioSourceRef.current = audioSource;\n      \n      const audioDestination = audioContext.createMediaStreamDestination();\n      const gainNode = audioContext.createGain();\n      gainNode.gain.value = 1.0;\n      \n      audioSource.connect(gainNode);\n      gainNode.connect(audioDestination);\n      \n      // Get audio tracks\n      const audioTracks = audioDestination.stream.getAudioTracks();\n      if (audioTracks.length === 0) {\n        throw new Error(\"No audio tracks available\");\n      }\n      \n      // Set up canvas stream\n      let stream = null;\n      try {\n        stream = canvas.captureStream(QUALITY_PRESETS[selectedQuality].frameRate);\n      } catch (e) {\n        try {\n          stream = canvas.mozCaptureStream && canvas.mozCaptureStream(QUALITY_PRESETS[selectedQuality].frameRate);\n        } catch (e) {\n          try {\n            stream = canvas.webkitCaptureStream && canvas.webkitCaptureStream(QUALITY_PRESETS[selectedQuality].frameRate);\n          } catch (e) {\n            throw new Error(\"Browser doesn't support canvas streaming\");\n          }\n        }\n      }\n      \n      // Get video tracks\n      const videoTracks = stream.getVideoTracks();\n      if (videoTracks.length === 0) {\n        throw new Error(\"No video tracks available\");\n      }\n      \n      // Combine streams\n      const combinedStream = new MediaStream([\n        ...videoTracks,\n        ...audioTracks\n      ]);\n      \n      // Set up MediaRecorder\n      const selectedMimeType = EXPORT_FORMATS[selectedFormat].mimeType;\n      if (!MediaRecorder.isTypeSupported(selectedMimeType)) {\n        throw new Error(`Format ${EXPORT_FORMATS[selectedFormat].label} not supported`);\n      }\n      \n      const options = {\n        mimeType: selectedMimeType,\n        videoBitsPerSecond: QUALITY_PRESETS[selectedQuality].videoBitrate,\n        audioBitsPerSecond: QUALITY_PRESETS[selectedQuality].audioBitrate\n      };\n      \n      const mediaRecorder = new MediaRecorder(combinedStream, options);\n      mediaRecorderRef.current = mediaRecorder;\n      \n      // Set up data handling\n      mediaRecorder.ondataavailable = (event) => {\n        if (event.data && event.data.size > 0) {\n          chunksRef.current.push(event.data);\n          const totalSize = chunksRef.current.reduce((size, chunk) => size + chunk.size, 0);\n          setDebug(`Chunk received: ${(event.data.size / 1024).toFixed(2)} KB, Total: ${(totalSize / 1024 / 1024).toFixed(2)} MB`);\n        }\n      };\n      \n      // Set up recording stop handler\n      mediaRecorder.onstop = () => {\n        const totalSize = chunksRef.current.reduce((size, chunk) => size + chunk.size, 0);\n        setDebug(`Recording stopped. Total chunks: ${chunksRef.current.length}, Total size: ${(totalSize / 1024 / 1024).toFixed(2)} MB`);\n        \n        if (totalSize === 0) {\n          throw new Error(\"No data was recorded\");\n        }\n        \n        // Create and download blob\n        const blob = new Blob(chunksRef.current, { type: selectedMimeType });\n        const url = URL.createObjectURL(blob);\n        \n        let fileName = \"visualization.\" + EXPORT_FORMATS[selectedFormat].extension;\n        if (audioFile && audioFile.name) {\n          fileName = audioFile.name.replace(/\\.[^/.]+$/, \"\") + \"_visualization.\" + EXPORT_FORMATS[selectedFormat].extension;\n        }\n        \n        const a = document.createElement('a');\n        a.href = url;\n        a.download = fileName;\n        a.click();\n        \n        URL.revokeObjectURL(url);\n        setIsExporting(false);\n        setProgress(100);\n        setDebug('Export completed successfully');\n        \n        cleanupResources();\n      };\n      \n      // Start recording with smaller timeslice for more frequent chunks\n      mediaRecorder.start(100);\n      setDebug('MediaRecorder started');\n      \n      // Start audio playback\n      await audioElement.play();\n      setDebug('Audio playback started');\n      \n      // Update progress\n      progressIntervalRef.current = setInterval(() => {\n        if (audioDurationRef.current) {\n          const elapsed = (Date.now() - startTimeRef.current) / 1000;\n          const percentage = Math.min(Math.floor((elapsed / audioDurationRef.current) * 100), 99);\n          setProgress(percentage);\n          setDebug(`Progress: ${percentage}%, Duration: ${elapsed.toFixed(1)}s/${audioDurationRef.current.toFixed(1)}s`);\n        }\n      }, 500);\n      \n      // Request data chunks periodically\n      dataRequestIntervalRef.current = setInterval(() => {\n        if (mediaRecorder.state === 'recording') {\n          mediaRecorder.requestData();\n        }\n      }, 1000);\n      \n      // Stop recording when audio ends\n      audioElement.onended = () => {\n        setDebug('Audio playback ended, stopping recording');\n        if (dataRequestIntervalRef.current) {\n          clearInterval(dataRequestIntervalRef.current);\n        }\n        if (mediaRecorder.state === 'recording') {\n          mediaRecorder.requestData();\n          setTimeout(() => mediaRecorder.stop(), 500);\n        }\n      };\n      \n    } catch (error) {\n      console.error(\"Error exporting video:\", error);\n      setDebug(`Export error: ${error.message}`);\n      \n      if (retryCount < MAX_RETRIES) {\n        setDebug(`Retrying export (attempt ${retryCount + 1} of ${MAX_RETRIES})...`);\n        await retryExport(exportVideo);\n      } else {\n        alert(`Error exporting video: ${error.message}`);\n        setIsExporting(false);\n        cleanupResources();\n      }\n    }\n  };\n\n  return (\n    <div className=\"video-exporter\">\n      {isExporting ? (\n        <div className=\"export-progress\">\n          <div className=\"progress-bar\">\n            <div className=\"progress-fill\" style={{ width: `${progress}%` }}></div>\n          </div>\n          <div className=\"progress-text\">{progress}% Exporting...</div>\n          <div className=\"debug-info\">{debug}</div>\n        </div>\n      ) : (\n        <div className=\"export-controls\">\n          <select \n            value={selectedQuality} \n            onChange={(e) => setSelectedQuality(e.target.value)}\n            className=\"quality-select\"\n          >\n            {Object.entries(QUALITY_PRESETS).map(([key, preset]) => (\n              <option key={key} value={key}>{preset.label}</option>\n            ))}\n          </select>\n          <select \n            value={selectedFormat} \n            onChange={(e) => setSelectedFormat(e.target.value)}\n            className=\"format-select\"\n            disabled={supportedFormats.length <= 1}\n          >\n            {Object.entries(EXPORT_FORMATS)\n              .filter(([key]) => supportedFormats.includes(key))\n              .map(([key, format]) => (\n                <option key={key} value={key}>{format.label}</option>\n              ))}\n          </select>\n          <button\n            className=\"export-button\"\n            onClick={exportVideo}\n            disabled={!visualizerRef || !audioFile || isPlaying || supportedFormats.length === 0}\n          >\n            Export Video\n          </button>\n        </div>\n      )}\n    </div>\n  );\n};\n\nexport default VideoExporter; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}