{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\fkuce\\\\OneDrive\\\\Desktop\\\\Money Projects\\\\Visualizer\\\\frontend\\\\src\\\\components\\\\VideoExporter.js\",\n  _s = $RefreshSig$();\nimport React, { useRef, useState, useEffect } from 'react';\nimport './VideoExporter.css';\n\n// Quality presets for different export options\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst QUALITY_PRESETS = {\n  high: {\n    videoBitrate: 8000000,\n    audioBitrate: 320000,\n    frameRate: 60,\n    label: 'High Quality'\n  },\n  medium: {\n    videoBitrate: 4000000,\n    audioBitrate: 192000,\n    frameRate: 30,\n    label: 'Medium Quality'\n  },\n  low: {\n    videoBitrate: 2000000,\n    audioBitrate: 128000,\n    frameRate: 30,\n    label: 'Low Quality'\n  }\n};\n\n// Export format options\nconst EXPORT_FORMATS = {\n  webm: {\n    mimeType: 'video/webm;codecs=vp9,opus',\n    extension: 'webm',\n    label: 'WebM (VP9)'\n  },\n  mp4: {\n    mimeType: 'video/mp4;codecs=h264,aac',\n    extension: 'mp4',\n    label: 'MP4 (H.264)'\n  }\n};\n\n// Maximum number of retries for failed exports\nconst MAX_RETRIES = 3;\nconst VideoExporter = ({\n  visualizerRef,\n  audioFile,\n  isPlaying\n}) => {\n  _s();\n  const [isExporting, setIsExporting] = useState(false);\n  const [progress, setProgress] = useState(0);\n  const [debug, setDebug] = useState('');\n  const [selectedQuality, setSelectedQuality] = useState('high');\n  const [selectedFormat, setSelectedFormat] = useState('webm');\n  const [retryCount, setRetryCount] = useState(0);\n  const mediaRecorderRef = useRef(null);\n  const chunksRef = useRef([]);\n  const startTimeRef = useRef(null);\n  const audioDurationRef = useRef(null);\n  const progressIntervalRef = useRef(null);\n  const dataRequestIntervalRef = useRef(null);\n  const audioContextRef = useRef(null);\n  const audioSourceRef = useRef(null);\n  const audioElementRef = useRef(null);\n  const originalAudioRef = useRef(null);\n  const originalIsPlayingRef = useRef(false);\n\n  // Clean up on unmount\n  useEffect(() => {\n    return () => {\n      cleanupResources();\n    };\n  }, []);\n\n  // Store the original audio element and isPlaying state\n  useEffect(() => {\n    const audioElements = document.querySelectorAll('audio');\n    if (audioElements.length > 0) {\n      originalAudioRef.current = audioElements[0];\n      console.log('Found original audio element:', originalAudioRef.current);\n    }\n    originalIsPlayingRef.current = isPlaying;\n  }, [isPlaying]);\n\n  // Clean up resources function\n  const cleanupResources = () => {\n    if (originalIsPlayingRef.current && originalAudioRef.current) {\n      try {\n        originalAudioRef.current.play().catch(e => {\n          console.error('Error resuming original audio:', e);\n        });\n      } catch (e) {\n        console.error('Error resuming original audio:', e);\n      }\n    }\n    if (progressIntervalRef.current) {\n      clearInterval(progressIntervalRef.current);\n      progressIntervalRef.current = null;\n    }\n    if (dataRequestIntervalRef.current) {\n      clearInterval(dataRequestIntervalRef.current);\n      dataRequestIntervalRef.current = null;\n    }\n    if (audioSourceRef.current) {\n      try {\n        audioSourceRef.current.disconnect();\n      } catch (e) {\n        console.error('Error disconnecting audio source:', e);\n      }\n      audioSourceRef.current = null;\n    }\n    if (audioElementRef.current) {\n      try {\n        audioElementRef.current.pause();\n        audioElementRef.current.oncanplaythrough = null;\n        audioElementRef.current.onerror = null;\n        audioElementRef.current.onended = null;\n        audioElementRef.current.removeAttribute('src');\n        audioElementRef.current.load();\n      } catch (e) {\n        console.error('Error cleaning up audio element:', e);\n      }\n      audioElementRef.current = null;\n    }\n    if (audioContextRef.current && audioContextRef.current.state !== 'closed') {\n      try {\n        audioContextRef.current.close().catch(e => console.error('Error closing audio context:', e));\n      } catch (e) {\n        console.error('Error closing audio context:', e);\n      }\n      audioContextRef.current = null;\n    }\n    if (mediaRecorderRef.current && mediaRecorderRef.current.state === 'recording') {\n      try {\n        mediaRecorderRef.current.stop();\n      } catch (e) {\n        console.error('Error stopping media recorder:', e);\n      }\n      mediaRecorderRef.current = null;\n    }\n    chunksRef.current = [];\n  };\n\n  // Validate audio file\n  const validateAudioFile = () => {\n    if (!audioFile) {\n      setDebug('Error: No audio file selected');\n      return false;\n    }\n    if (!audioFile.path) {\n      setDebug('Error: Audio file has no path');\n      return false;\n    }\n    return true;\n  };\n\n  // Ensure visualizer is active\n  const ensureVisualizerActive = () => {\n    if (!(visualizerRef !== null && visualizerRef !== void 0 && visualizerRef.current)) {\n      setDebug('Error: Visualizer reference not available');\n      return false;\n    }\n    const canvas = visualizerRef.current.getCanvas();\n    if (!canvas) {\n      setDebug('Error: Canvas not found in visualizer');\n      return false;\n    }\n    try {\n      const ctx = canvas.getContext('2d');\n      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n      ctx.putImageData(imageData, 0, 0);\n      return true;\n    } catch (e) {\n      setDebug(`Error activating visualizer: ${e.message}`);\n      return false;\n    }\n  };\n\n  // Get canvas resolution\n  const getCanvasResolution = canvas => {\n    if (!canvas) return {\n      width: 0,\n      height: 0\n    };\n    const width = canvas.width;\n    const height = canvas.height;\n    console.log(`Canvas resolution: ${width}x${height}`);\n    setDebug(`Canvas resolution: ${width}x${height}`);\n    return {\n      width,\n      height\n    };\n  };\n\n  // Activate visualizer with original audio\n  const activateVisualizerWithOriginalAudio = async () => {\n    try {\n      const playButtons = document.querySelectorAll('button');\n      let playButton = null;\n      for (const button of playButtons) {\n        if (button.textContent.includes('Play') || button.className.includes('play') || button.title.includes('Play')) {\n          playButton = button;\n          break;\n        }\n      }\n      originalIsPlayingRef.current = isPlaying;\n      if (playButton && !isPlaying) {\n        setDebug('Clicking play button to activate visualizer');\n        playButton.click();\n        await new Promise(resolve => setTimeout(resolve, 500));\n        if (originalAudioRef.current) {\n          originalAudioRef.current.pause();\n          setDebug('Paused original audio to avoid duplication');\n        } else if (playButton) {\n          playButton.click();\n          setDebug('Clicked play button again to pause audio');\n        }\n        return true;\n      } else {\n        setDebug('Audio is already playing or play button not found');\n        return isPlaying;\n      }\n    } catch (e) {\n      setDebug(`Error activating visualizer: ${e.message}`);\n      return false;\n    }\n  };\n\n  // Retry mechanism for failed exports\n  const retryExport = async (exportFunction, maxRetries = MAX_RETRIES) => {\n    for (let i = 0; i < maxRetries; i++) {\n      try {\n        setRetryCount(i + 1);\n        setDebug(`Attempt ${i + 1} of ${maxRetries}`);\n        await exportFunction();\n        return;\n      } catch (error) {\n        if (i === maxRetries - 1) throw error;\n        setDebug(`Export failed, retrying in ${i + 1} seconds...`);\n        await new Promise(resolve => setTimeout(resolve, 1000 * (i + 1)));\n      }\n    }\n  };\n  const exportVideo = async () => {\n    if (!(visualizerRef !== null && visualizerRef !== void 0 && visualizerRef.current) || !audioFile) {\n      alert(\"Please upload an audio file first\");\n      return;\n    }\n    if (!validateAudioFile()) {\n      alert(\"Invalid audio file. Please upload a valid audio file.\");\n      return;\n    }\n    if (isExporting) {\n      console.log('Already exporting, ignoring request');\n      return;\n    }\n    try {\n      cleanupResources();\n      setIsExporting(true);\n      setProgress(0);\n      setDebug('Starting export process...');\n      startTimeRef.current = Date.now();\n      setDebug('Activating visualizer with original audio...');\n      const visualizerActivated = await activateVisualizerWithOriginalAudio();\n      if (!visualizerActivated) {\n        setDebug('Warning: Could not activate visualizer with original audio');\n      }\n      await new Promise(resolve => setTimeout(resolve, 500));\n      if (!ensureVisualizerActive()) {\n        throw new Error(\"Could not activate visualizer\");\n      }\n      const canvas = visualizerRef.current.getCanvas();\n      if (!canvas) {\n        throw new Error(\"Canvas element not found\");\n      }\n      const resolution = getCanvasResolution(canvas);\n      setDebug(`Canvas found, dimensions: ${resolution.width}x${resolution.height}`);\n      if (resolution.width < 720 || resolution.height < 720) {\n        setDebug(`Warning: Canvas resolution (${resolution.width}x${resolution.height}) is low. Consider using a higher resolution for better quality.`);\n      }\n      let stream = null;\n\n      // Try different stream capture methods\n      try {\n        stream = canvas.captureStream(QUALITY_PRESETS[selectedQuality].frameRate);\n        setDebug(`Canvas stream created with ${QUALITY_PRESETS[selectedQuality].frameRate}fps`);\n      } catch (e) {\n        console.error('Standard captureStream failed:', e);\n        setDebug('Standard captureStream failed, trying alternatives...');\n      }\n      if (!stream) {\n        try {\n          stream = canvas.mozCaptureStream && canvas.mozCaptureStream(QUALITY_PRESETS[selectedQuality].frameRate);\n          if (stream) {\n            setDebug(`Canvas stream created with mozCaptureStream at ${QUALITY_PRESETS[selectedQuality].frameRate}fps`);\n          }\n        } catch (e) {\n          console.error('mozCaptureStream failed:', e);\n          setDebug('mozCaptureStream failed, trying alternatives...');\n        }\n      }\n      if (!stream) {\n        try {\n          stream = canvas.webkitCaptureStream && canvas.webkitCaptureStream(QUALITY_PRESETS[selectedQuality].frameRate);\n          if (stream) {\n            setDebug(`Canvas stream created with webkitCaptureStream at ${QUALITY_PRESETS[selectedQuality].frameRate}fps`);\n          }\n        } catch (e) {\n          console.error('webkitCaptureStream failed:', e);\n          setDebug('webkitCaptureStream failed');\n        }\n      }\n      if (!stream) {\n        throw new Error(\"Your browser doesn't support canvas streaming. Try using a different browser like Chrome.\");\n      }\n      const videoTracks = stream.getVideoTracks();\n      if (videoTracks.length === 0) {\n        throw new Error(\"No video tracks found in canvas stream\");\n      }\n      setDebug(`Stream created with ${videoTracks.length} video tracks`);\n      videoTracks.forEach((track, index) => {\n        console.log(`Video track ${index}:`, track.label, track.enabled, track.readyState);\n        try {\n          if (track.applyConstraints) {\n            track.applyConstraints({\n              width: {\n                ideal: resolution.width\n              },\n              height: {\n                ideal: resolution.height\n              },\n              frameRate: {\n                ideal: QUALITY_PRESETS[selectedQuality].frameRate\n              }\n            });\n            console.log(`Applied constraints to video track ${index}`);\n          }\n        } catch (e) {\n          console.error('Could not apply constraints to video track:', e);\n        }\n      });\n      try {\n        const AudioContext = window.AudioContext || window.webkitAudioContext;\n        const audioContext = new AudioContext({\n          sampleRate: 48000\n        });\n        audioContextRef.current = audioContext;\n        const timestamp = new Date().getTime();\n        const encodedPath = encodeURI(audioFile.path);\n        const audioUrl = `http://localhost:5001${encodedPath}?t=${timestamp}`;\n        console.log('Audio URL:', audioUrl);\n        setDebug(`Using audio URL: ${audioUrl}`);\n        const audioElement = new Audio();\n        audioElement.crossOrigin = \"anonymous\";\n        audioElement.preload = \"auto\";\n        audioElement.volume = 0;\n        audioElementRef.current = audioElement;\n        audioElement.onerror = e => {\n          const errorDetail = e.target.error ? `${e.target.error.message || ''} (code: ${e.target.error.code})` : 'Unknown error';\n          console.error('Audio error:', e.target.error);\n          setDebug(`Audio error: ${errorDetail}`);\n          throw new Error(`Audio error: ${errorDetail}`);\n        };\n        setDebug('Loading audio...');\n        const audioLoadPromise = new Promise((resolve, reject) => {\n          audioElement.oncanplaythrough = () => {\n            console.log('Audio loaded successfully, duration:', audioElement.duration);\n            setDebug('Audio loaded successfully');\n            resolve();\n          };\n          audioElement.onerror = e => {\n            const errorDetail = e.target.error ? `${e.target.error.message || ''} (code: ${e.target.error.code})` : 'Unknown error';\n            console.error('Audio load error:', e.target.error);\n            setDebug(`Audio load error: ${errorDetail}`);\n            reject(new Error(`Audio load error: ${errorDetail}`));\n          };\n          const timeoutId = setTimeout(() => {\n            audioElement.oncanplaythrough = null;\n            audioElement.onerror = null;\n            setDebug('Audio load timeout - took too long to load');\n            reject(new Error('Audio load timeout - took too long to load'));\n          }, 10000);\n          const clearTimeoutHandler = () => {\n            clearTimeout(timeoutId);\n          };\n          audioElement.addEventListener('canplaythrough', clearTimeoutHandler, {\n            once: true\n          });\n          audioElement.addEventListener('error', clearTimeoutHandler, {\n            once: true\n          });\n        });\n        audioElement.src = audioUrl;\n        audioElement.load();\n        await audioLoadPromise;\n        audioDurationRef.current = audioElement.duration;\n        setDebug(`Audio duration: ${audioDurationRef.current.toFixed(2)} seconds`);\n        const audioSource = audioContext.createMediaElementSource(audioElement);\n        audioSourceRef.current = audioSource;\n        const audioDestination = audioContext.createMediaStreamDestination();\n        const gainNode = audioContext.createGain();\n        gainNode.gain.value = 1.0;\n        audioSource.connect(gainNode);\n        gainNode.connect(audioDestination);\n        const audioTracks = audioDestination.stream.getAudioTracks();\n        if (audioTracks.length === 0) {\n          setDebug('Warning: No audio tracks found in audio stream');\n        } else {\n          setDebug(`Audio stream created with ${audioTracks.length} audio tracks`);\n          audioTracks.forEach((track, index) => {\n            console.log(`Audio track ${index}:`, track.label, track.enabled, track.readyState);\n          });\n        }\n        const combinedStream = new MediaStream([...videoTracks, ...audioTracks]);\n        if (combinedStream.getTracks().length === 0) {\n          throw new Error(\"Combined stream has no tracks\");\n        }\n        setDebug(`Combined stream created with ${combinedStream.getTracks().length} total tracks`);\n        const selectedMimeType = EXPORT_FORMATS[selectedFormat].mimeType;\n        if (!MediaRecorder.isTypeSupported(selectedMimeType)) {\n          throw new Error(`Selected format ${EXPORT_FORMATS[selectedFormat].label} is not supported by your browser`);\n        }\n        const options = {\n          mimeType: selectedMimeType,\n          videoBitsPerSecond: QUALITY_PRESETS[selectedQuality].videoBitrate,\n          audioBitsPerSecond: QUALITY_PRESETS[selectedQuality].audioBitrate\n        };\n        try {\n          const mediaRecorder = new MediaRecorder(combinedStream, options);\n          mediaRecorderRef.current = mediaRecorder;\n          console.log('MediaRecorder created:', mediaRecorder.mimeType, mediaRecorder.state);\n          setDebug(`MediaRecorder created with mime type: ${mediaRecorder.mimeType}, video bitrate: ${QUALITY_PRESETS[selectedQuality].videoBitrate / 1000000}Mbps`);\n          mediaRecorder.addEventListener('start', () => {\n            console.log('MediaRecorder started');\n            setDebug('Recording started at high quality');\n          });\n          mediaRecorder.addEventListener('error', event => {\n            console.error('MediaRecorder error:', event);\n            setDebug(`MediaRecorder error: ${event.error || 'Unknown error'}`);\n          });\n          mediaRecorder.ondataavailable = event => {\n            console.log('Data available event, size:', event.data.size);\n            if (event.data && event.data.size > 0) {\n              chunksRef.current.push(event.data);\n              setDebug(`Received data chunk: ${(event.data.size / 1024).toFixed(2)} KB, total chunks: ${chunksRef.current.length}`);\n            } else {\n              console.warn('Received empty data chunk');\n              setDebug('Warning: Received empty data chunk');\n            }\n          };\n          mediaRecorder.onstop = () => {\n            console.log('MediaRecorder stopped, chunks:', chunksRef.current.length);\n            setDebug(`Recording stopped with ${chunksRef.current.length} chunks`);\n            if (chunksRef.current.length === 0) {\n              setDebug('Error: No data chunks were recorded');\n              alert('Error: No video data was captured during recording. This may be due to browser compatibility issues. Try using Chrome or Edge.');\n              setIsExporting(false);\n              cleanupResources();\n              return;\n            }\n            const totalSize = chunksRef.current.reduce((size, chunk) => size + chunk.size, 0);\n            setDebug(`Total data size: ${(totalSize / 1024 / 1024).toFixed(2)} MB`);\n            if (totalSize === 0) {\n              setDebug('Error: Recorded data has zero size');\n              alert('Error: The recorded video has no data (0 bytes). Try using a different browser or visualization.');\n              setIsExporting(false);\n              cleanupResources();\n              return;\n            }\n            try {\n              const blob = new Blob(chunksRef.current, {\n                type: selectedMimeType\n              });\n              console.log('Created blob, size:', blob.size);\n              setDebug(`Created video blob: ${(blob.size / 1024 / 1024).toFixed(2)} MB`);\n              if (blob.size === 0) {\n                setDebug('Error: Final blob has zero size');\n                alert('Error: The final video file has no data (0 bytes). Try using a different browser.');\n                setIsExporting(false);\n                cleanupResources();\n                return;\n              }\n              const url = URL.createObjectURL(blob);\n              let fileName = \"visualization.\" + EXPORT_FORMATS[selectedFormat].extension;\n              if (audioFile && audioFile.name) {\n                fileName = audioFile.name.replace(/\\.[^/.]+$/, \"\") + \"_visualization.\" + EXPORT_FORMATS[selectedFormat].extension;\n              } else if (audioFile && audioFile.path) {\n                const pathParts = audioFile.path.split('/');\n                const pathFileName = pathParts[pathParts.length - 1];\n                fileName = pathFileName.replace(/\\.[^/.]+$/, \"\") + \"_visualization.\" + EXPORT_FORMATS[selectedFormat].extension;\n              }\n              const a = document.createElement('a');\n              a.href = url;\n              a.download = fileName;\n              a.click();\n              URL.revokeObjectURL(url);\n              setIsExporting(false);\n              setProgress(100);\n              setDebug('Export completed successfully');\n              cleanupResources();\n            } catch (blobError) {\n              console.error('Error creating blob:', blobError);\n              setDebug(`Error creating video file: ${blobError.message}`);\n              alert(`Error creating video file: ${blobError.message}`);\n              setIsExporting(false);\n              cleanupResources();\n            }\n          };\n          mediaRecorder.start(100);\n          setDebug('MediaRecorder started with 100ms timeslice for high quality');\n          try {\n            await audioElement.play();\n            setDebug('Silent audio playback started for timing');\n            if (canvas) {\n              const ctx = canvas.getContext('2d');\n              ctx.fillStyle = 'rgba(0,0,0,0.01)';\n              ctx.fillRect(0, 0, 1, 1);\n            }\n          } catch (playError) {\n            console.error('Error playing audio:', playError);\n            setDebug(`Failed to play audio: ${playError.message || 'Unknown error'}`);\n            throw new Error(`Failed to play audio: ${playError.message}`);\n          }\n          dataRequestIntervalRef.current = setInterval(() => {\n            if (mediaRecorderRef.current && mediaRecorderRef.current.state === 'recording') {\n              mediaRecorderRef.current.requestData();\n              if (canvas) {\n                try {\n                  const ctx = canvas.getContext('2d');\n                  ctx.fillStyle = 'rgba(0,0,0,0.01)';\n                  ctx.fillRect(0, 0, 1, 1);\n                } catch (e) {\n                  console.error('Error keeping canvas active:', e);\n                }\n              }\n            }\n          }, 1000);\n          progressIntervalRef.current = setInterval(() => {\n            if (audioDurationRef.current) {\n              const elapsed = (Date.now() - startTimeRef.current) / 1000;\n              const percentage = Math.min(Math.floor(elapsed / audioDurationRef.current * 100), 99);\n              setProgress(percentage);\n              setDebug(`Progress: ${percentage}%, Chunks: ${chunksRef.current.length}, Duration: ${elapsed.toFixed(1)}s/${audioDurationRef.current.toFixed(1)}s`);\n              if (elapsed > 3 && chunksRef.current.length === 0) {\n                setDebug('Warning: No data chunks received after 3 seconds');\n              }\n            }\n          }, 500);\n          audioElement.onended = () => {\n            setDebug('Audio playback ended, stopping recording');\n            if (dataRequestIntervalRef.current) {\n              clearInterval(dataRequestIntervalRef.current);\n              dataRequestIntervalRef.current = null;\n            }\n            if (mediaRecorderRef.current && mediaRecorderRef.current.state === 'recording') {\n              mediaRecorderRef.current.requestData();\n              setTimeout(() => {\n                try {\n                  mediaRecorderRef.current.stop();\n                } catch (stopError) {\n                  console.error('Error stopping MediaRecorder:', stopError);\n                  setDebug(`Error stopping recording: ${stopError.message}`);\n                  setIsExporting(false);\n                  cleanupResources();\n                }\n              }, 500);\n            }\n          };\n        } catch (recorderError) {\n          console.error('Error creating MediaRecorder:', recorderError);\n          setDebug(`Failed to create MediaRecorder: ${recorderError.message}`);\n          throw new Error(`Failed to create MediaRecorder: ${recorderError.message}. Try using a different browser.`);\n        }\n      } catch (audioError) {\n        console.error('Error setting up audio:', audioError);\n        setDebug(`Audio setup error: ${audioError.message}`);\n        throw new Error(`Failed to set up audio: ${audioError.message}`);\n      }\n    } catch (error) {\n      console.error(\"Error exporting video:\", error);\n      setDebug(`Export error: ${error.message || 'Unknown error'}`);\n      if (retryCount < MAX_RETRIES) {\n        setDebug(`Retrying export (attempt ${retryCount + 1} of ${MAX_RETRIES})...`);\n        await retryExport(exportVideo);\n      } else {\n        alert(`Error exporting video: ${error.message}`);\n        setIsExporting(false);\n        cleanupResources();\n      }\n    }\n  };\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"video-exporter\",\n    children: isExporting ? /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"export-progress\",\n      children: [/*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"progress-bar\",\n        children: /*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"progress-fill\",\n          style: {\n            width: `${progress}%`\n          }\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 677,\n          columnNumber: 13\n        }, this)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 676,\n        columnNumber: 11\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"progress-text\",\n        children: [progress, \"% Exporting...\"]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 679,\n        columnNumber: 11\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"debug-info\",\n        children: debug\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 680,\n        columnNumber: 11\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 675,\n      columnNumber: 9\n    }, this) : /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"export-controls\",\n      children: [/*#__PURE__*/_jsxDEV(\"select\", {\n        value: selectedQuality,\n        onChange: e => setSelectedQuality(e.target.value),\n        className: \"quality-select\",\n        children: Object.entries(QUALITY_PRESETS).map(([key, preset]) => /*#__PURE__*/_jsxDEV(\"option\", {\n          value: key,\n          children: preset.label\n        }, key, false, {\n          fileName: _jsxFileName,\n          lineNumber: 690,\n          columnNumber: 15\n        }, this))\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 684,\n        columnNumber: 11\n      }, this), /*#__PURE__*/_jsxDEV(\"select\", {\n        value: selectedFormat,\n        onChange: e => setSelectedFormat(e.target.value),\n        className: \"format-select\",\n        children: Object.entries(EXPORT_FORMATS).map(([key, format]) => /*#__PURE__*/_jsxDEV(\"option\", {\n          value: key,\n          children: format.label\n        }, key, false, {\n          fileName: _jsxFileName,\n          lineNumber: 699,\n          columnNumber: 15\n        }, this))\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 693,\n        columnNumber: 11\n      }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n        className: \"export-button\",\n        onClick: exportVideo,\n        disabled: !visualizerRef || !audioFile || isPlaying,\n        children: \"Export Video\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 702,\n        columnNumber: 11\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 683,\n      columnNumber: 9\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 673,\n    columnNumber: 5\n  }, this);\n};\n_s(VideoExporter, \"u6VA+H2WORmlmW2Bm5I/l8kyWFo=\");\n_c = VideoExporter;\nexport default VideoExporter;\nvar _c;\n$RefreshReg$(_c, \"VideoExporter\");","map":{"version":3,"names":["React","useRef","useState","useEffect","jsxDEV","_jsxDEV","QUALITY_PRESETS","high","videoBitrate","audioBitrate","frameRate","label","medium","low","EXPORT_FORMATS","webm","mimeType","extension","mp4","MAX_RETRIES","VideoExporter","visualizerRef","audioFile","isPlaying","_s","isExporting","setIsExporting","progress","setProgress","debug","setDebug","selectedQuality","setSelectedQuality","selectedFormat","setSelectedFormat","retryCount","setRetryCount","mediaRecorderRef","chunksRef","startTimeRef","audioDurationRef","progressIntervalRef","dataRequestIntervalRef","audioContextRef","audioSourceRef","audioElementRef","originalAudioRef","originalIsPlayingRef","cleanupResources","audioElements","document","querySelectorAll","length","current","console","log","play","catch","e","error","clearInterval","disconnect","pause","oncanplaythrough","onerror","onended","removeAttribute","load","state","close","stop","validateAudioFile","path","ensureVisualizerActive","canvas","getCanvas","ctx","getContext","imageData","getImageData","width","height","putImageData","message","getCanvasResolution","activateVisualizerWithOriginalAudio","playButtons","playButton","button","textContent","includes","className","title","click","Promise","resolve","setTimeout","retryExport","exportFunction","maxRetries","i","exportVideo","alert","Date","now","visualizerActivated","Error","resolution","stream","captureStream","mozCaptureStream","webkitCaptureStream","videoTracks","getVideoTracks","forEach","track","index","enabled","readyState","applyConstraints","ideal","AudioContext","window","webkitAudioContext","audioContext","sampleRate","timestamp","getTime","encodedPath","encodeURI","audioUrl","audioElement","Audio","crossOrigin","preload","volume","errorDetail","target","code","audioLoadPromise","reject","duration","timeoutId","clearTimeoutHandler","clearTimeout","addEventListener","once","src","toFixed","audioSource","createMediaElementSource","audioDestination","createMediaStreamDestination","gainNode","createGain","gain","value","connect","audioTracks","getAudioTracks","combinedStream","MediaStream","getTracks","selectedMimeType","MediaRecorder","isTypeSupported","options","videoBitsPerSecond","audioBitsPerSecond","mediaRecorder","event","ondataavailable","data","size","push","warn","onstop","totalSize","reduce","chunk","blob","Blob","type","url","URL","createObjectURL","fileName","name","replace","pathParts","split","pathFileName","a","createElement","href","download","revokeObjectURL","blobError","start","fillStyle","fillRect","playError","setInterval","requestData","elapsed","percentage","Math","min","floor","stopError","recorderError","audioError","children","style","_jsxFileName","lineNumber","columnNumber","onChange","Object","entries","map","key","preset","format","onClick","disabled","_c","$RefreshReg$"],"sources":["C:/Users/fkuce/OneDrive/Desktop/Money Projects/Visualizer/frontend/src/components/VideoExporter.js"],"sourcesContent":["import React, { useRef, useState, useEffect } from 'react';\nimport './VideoExporter.css';\n\n// Quality presets for different export options\nconst QUALITY_PRESETS = {\n  high: {\n    videoBitrate: 8000000,\n    audioBitrate: 320000,\n    frameRate: 60,\n    label: 'High Quality'\n  },\n  medium: {\n    videoBitrate: 4000000,\n    audioBitrate: 192000,\n    frameRate: 30,\n    label: 'Medium Quality'\n  },\n  low: {\n    videoBitrate: 2000000,\n    audioBitrate: 128000,\n    frameRate: 30,\n    label: 'Low Quality'\n  }\n};\n\n// Export format options\nconst EXPORT_FORMATS = {\n  webm: {\n    mimeType: 'video/webm;codecs=vp9,opus',\n    extension: 'webm',\n    label: 'WebM (VP9)'\n  },\n  mp4: {\n    mimeType: 'video/mp4;codecs=h264,aac',\n    extension: 'mp4',\n    label: 'MP4 (H.264)'\n  }\n};\n\n// Maximum number of retries for failed exports\nconst MAX_RETRIES = 3;\n\nconst VideoExporter = ({ visualizerRef, audioFile, isPlaying }) => {\n  const [isExporting, setIsExporting] = useState(false);\n  const [progress, setProgress] = useState(0);\n  const [debug, setDebug] = useState('');\n  const [selectedQuality, setSelectedQuality] = useState('high');\n  const [selectedFormat, setSelectedFormat] = useState('webm');\n  const [retryCount, setRetryCount] = useState(0);\n  \n  const mediaRecorderRef = useRef(null);\n  const chunksRef = useRef([]);\n  const startTimeRef = useRef(null);\n  const audioDurationRef = useRef(null);\n  const progressIntervalRef = useRef(null);\n  const dataRequestIntervalRef = useRef(null);\n  const audioContextRef = useRef(null);\n  const audioSourceRef = useRef(null);\n  const audioElementRef = useRef(null);\n  const originalAudioRef = useRef(null);\n  const originalIsPlayingRef = useRef(false);\n  \n  // Clean up on unmount\n  useEffect(() => {\n    return () => {\n      cleanupResources();\n    };\n  }, []);\n\n  // Store the original audio element and isPlaying state\n  useEffect(() => {\n    const audioElements = document.querySelectorAll('audio');\n    if (audioElements.length > 0) {\n      originalAudioRef.current = audioElements[0];\n      console.log('Found original audio element:', originalAudioRef.current);\n    }\n    originalIsPlayingRef.current = isPlaying;\n  }, [isPlaying]);\n\n  // Clean up resources function\n  const cleanupResources = () => {\n    if (originalIsPlayingRef.current && originalAudioRef.current) {\n      try {\n        originalAudioRef.current.play().catch(e => {\n          console.error('Error resuming original audio:', e);\n        });\n      } catch (e) {\n        console.error('Error resuming original audio:', e);\n      }\n    }\n    \n    if (progressIntervalRef.current) {\n      clearInterval(progressIntervalRef.current);\n      progressIntervalRef.current = null;\n    }\n    \n    if (dataRequestIntervalRef.current) {\n      clearInterval(dataRequestIntervalRef.current);\n      dataRequestIntervalRef.current = null;\n    }\n    \n    if (audioSourceRef.current) {\n      try {\n        audioSourceRef.current.disconnect();\n      } catch (e) {\n        console.error('Error disconnecting audio source:', e);\n      }\n      audioSourceRef.current = null;\n    }\n    \n    if (audioElementRef.current) {\n      try {\n        audioElementRef.current.pause();\n        audioElementRef.current.oncanplaythrough = null;\n        audioElementRef.current.onerror = null;\n        audioElementRef.current.onended = null;\n        audioElementRef.current.removeAttribute('src');\n        audioElementRef.current.load();\n      } catch (e) {\n        console.error('Error cleaning up audio element:', e);\n      }\n      audioElementRef.current = null;\n    }\n    \n    if (audioContextRef.current && audioContextRef.current.state !== 'closed') {\n      try {\n        audioContextRef.current.close().catch(e => console.error('Error closing audio context:', e));\n      } catch (e) {\n        console.error('Error closing audio context:', e);\n      }\n      audioContextRef.current = null;\n    }\n    \n    if (mediaRecorderRef.current && mediaRecorderRef.current.state === 'recording') {\n      try {\n        mediaRecorderRef.current.stop();\n      } catch (e) {\n        console.error('Error stopping media recorder:', e);\n      }\n      mediaRecorderRef.current = null;\n    }\n    \n    chunksRef.current = [];\n  };\n\n  // Validate audio file\n  const validateAudioFile = () => {\n    if (!audioFile) {\n      setDebug('Error: No audio file selected');\n      return false;\n    }\n    \n    if (!audioFile.path) {\n      setDebug('Error: Audio file has no path');\n      return false;\n    }\n    \n    return true;\n  };\n\n  // Ensure visualizer is active\n  const ensureVisualizerActive = () => {\n    if (!visualizerRef?.current) {\n      setDebug('Error: Visualizer reference not available');\n      return false;\n    }\n    \n    const canvas = visualizerRef.current.getCanvas();\n    if (!canvas) {\n      setDebug('Error: Canvas not found in visualizer');\n      return false;\n    }\n    \n    try {\n      const ctx = canvas.getContext('2d');\n      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n      ctx.putImageData(imageData, 0, 0);\n      return true;\n    } catch (e) {\n      setDebug(`Error activating visualizer: ${e.message}`);\n      return false;\n    }\n  };\n\n  // Get canvas resolution\n  const getCanvasResolution = (canvas) => {\n    if (!canvas) return { width: 0, height: 0 };\n    \n    const width = canvas.width;\n    const height = canvas.height;\n    \n    console.log(`Canvas resolution: ${width}x${height}`);\n    setDebug(`Canvas resolution: ${width}x${height}`);\n    \n    return { width, height };\n  };\n\n  // Activate visualizer with original audio\n  const activateVisualizerWithOriginalAudio = async () => {\n    try {\n      const playButtons = document.querySelectorAll('button');\n      let playButton = null;\n      \n      for (const button of playButtons) {\n        if (button.textContent.includes('Play') || \n            button.className.includes('play') || \n            button.title.includes('Play')) {\n          playButton = button;\n          break;\n        }\n      }\n      \n      originalIsPlayingRef.current = isPlaying;\n      \n      if (playButton && !isPlaying) {\n        setDebug('Clicking play button to activate visualizer');\n        playButton.click();\n        \n        await new Promise(resolve => setTimeout(resolve, 500));\n        \n        if (originalAudioRef.current) {\n          originalAudioRef.current.pause();\n          setDebug('Paused original audio to avoid duplication');\n        } else if (playButton) {\n          playButton.click();\n          setDebug('Clicked play button again to pause audio');\n        }\n        \n        return true;\n      } else {\n        setDebug('Audio is already playing or play button not found');\n        return isPlaying;\n      }\n    } catch (e) {\n      setDebug(`Error activating visualizer: ${e.message}`);\n      return false;\n    }\n  };\n\n  // Retry mechanism for failed exports\n  const retryExport = async (exportFunction, maxRetries = MAX_RETRIES) => {\n    for (let i = 0; i < maxRetries; i++) {\n      try {\n        setRetryCount(i + 1);\n        setDebug(`Attempt ${i + 1} of ${maxRetries}`);\n        await exportFunction();\n        return;\n      } catch (error) {\n        if (i === maxRetries - 1) throw error;\n        setDebug(`Export failed, retrying in ${i + 1} seconds...`);\n        await new Promise(resolve => setTimeout(resolve, 1000 * (i + 1)));\n      }\n    }\n  };\n\n  const exportVideo = async () => {\n    if (!visualizerRef?.current || !audioFile) {\n      alert(\"Please upload an audio file first\");\n      return;\n    }\n    \n    if (!validateAudioFile()) {\n      alert(\"Invalid audio file. Please upload a valid audio file.\");\n      return;\n    }\n    \n    if (isExporting) {\n      console.log('Already exporting, ignoring request');\n      return;\n    }\n\n    try {\n      cleanupResources();\n      \n      setIsExporting(true);\n      setProgress(0);\n      setDebug('Starting export process...');\n      startTimeRef.current = Date.now();\n      \n      setDebug('Activating visualizer with original audio...');\n      const visualizerActivated = await activateVisualizerWithOriginalAudio();\n      \n      if (!visualizerActivated) {\n        setDebug('Warning: Could not activate visualizer with original audio');\n      }\n      \n      await new Promise(resolve => setTimeout(resolve, 500));\n\n      if (!ensureVisualizerActive()) {\n        throw new Error(\"Could not activate visualizer\");\n      }\n      \n      const canvas = visualizerRef.current.getCanvas();\n      if (!canvas) {\n        throw new Error(\"Canvas element not found\");\n      }\n      \n      const resolution = getCanvasResolution(canvas);\n      setDebug(`Canvas found, dimensions: ${resolution.width}x${resolution.height}`);\n      \n      if (resolution.width < 720 || resolution.height < 720) {\n        setDebug(`Warning: Canvas resolution (${resolution.width}x${resolution.height}) is low. Consider using a higher resolution for better quality.`);\n      }\n\n      let stream = null;\n      \n      // Try different stream capture methods\n      try {\n        stream = canvas.captureStream(QUALITY_PRESETS[selectedQuality].frameRate);\n        setDebug(`Canvas stream created with ${QUALITY_PRESETS[selectedQuality].frameRate}fps`);\n      } catch (e) {\n        console.error('Standard captureStream failed:', e);\n        setDebug('Standard captureStream failed, trying alternatives...');\n      }\n      \n      if (!stream) {\n        try {\n          stream = canvas.mozCaptureStream && canvas.mozCaptureStream(QUALITY_PRESETS[selectedQuality].frameRate);\n          if (stream) {\n            setDebug(`Canvas stream created with mozCaptureStream at ${QUALITY_PRESETS[selectedQuality].frameRate}fps`);\n          }\n        } catch (e) {\n          console.error('mozCaptureStream failed:', e);\n          setDebug('mozCaptureStream failed, trying alternatives...');\n        }\n      }\n      \n      if (!stream) {\n        try {\n          stream = canvas.webkitCaptureStream && canvas.webkitCaptureStream(QUALITY_PRESETS[selectedQuality].frameRate);\n          if (stream) {\n            setDebug(`Canvas stream created with webkitCaptureStream at ${QUALITY_PRESETS[selectedQuality].frameRate}fps`);\n          }\n        } catch (e) {\n          console.error('webkitCaptureStream failed:', e);\n          setDebug('webkitCaptureStream failed');\n        }\n      }\n\n      if (!stream) {\n        throw new Error(\"Your browser doesn't support canvas streaming. Try using a different browser like Chrome.\");\n      }\n\n      const videoTracks = stream.getVideoTracks();\n      if (videoTracks.length === 0) {\n        throw new Error(\"No video tracks found in canvas stream\");\n      }\n      setDebug(`Stream created with ${videoTracks.length} video tracks`);\n      \n      videoTracks.forEach((track, index) => {\n        console.log(`Video track ${index}:`, track.label, track.enabled, track.readyState);\n        \n        try {\n          if (track.applyConstraints) {\n            track.applyConstraints({\n              width: { ideal: resolution.width },\n              height: { ideal: resolution.height },\n              frameRate: { ideal: QUALITY_PRESETS[selectedQuality].frameRate }\n            });\n            console.log(`Applied constraints to video track ${index}`);\n          }\n        } catch (e) {\n          console.error('Could not apply constraints to video track:', e);\n        }\n      });\n\n      try {\n        const AudioContext = window.AudioContext || window.webkitAudioContext;\n        const audioContext = new AudioContext({ sampleRate: 48000 });\n        audioContextRef.current = audioContext;\n        \n        const timestamp = new Date().getTime();\n        const encodedPath = encodeURI(audioFile.path);\n        const audioUrl = `http://localhost:5001${encodedPath}?t=${timestamp}`;\n        \n        console.log('Audio URL:', audioUrl);\n        setDebug(`Using audio URL: ${audioUrl}`);\n        \n        const audioElement = new Audio();\n        audioElement.crossOrigin = \"anonymous\";\n        audioElement.preload = \"auto\";\n        audioElement.volume = 0;\n        audioElementRef.current = audioElement;\n        \n        audioElement.onerror = (e) => {\n          const errorDetail = e.target.error \n            ? `${e.target.error.message || ''} (code: ${e.target.error.code})` \n            : 'Unknown error';\n          console.error('Audio error:', e.target.error);\n          setDebug(`Audio error: ${errorDetail}`);\n          throw new Error(`Audio error: ${errorDetail}`);\n        };\n        \n        setDebug('Loading audio...');\n        \n        const audioLoadPromise = new Promise((resolve, reject) => {\n          audioElement.oncanplaythrough = () => {\n            console.log('Audio loaded successfully, duration:', audioElement.duration);\n            setDebug('Audio loaded successfully');\n            resolve();\n          };\n          \n          audioElement.onerror = (e) => {\n            const errorDetail = e.target.error \n              ? `${e.target.error.message || ''} (code: ${e.target.error.code})` \n              : 'Unknown error';\n            console.error('Audio load error:', e.target.error);\n            setDebug(`Audio load error: ${errorDetail}`);\n            reject(new Error(`Audio load error: ${errorDetail}`));\n          };\n          \n          const timeoutId = setTimeout(() => {\n            audioElement.oncanplaythrough = null;\n            audioElement.onerror = null;\n            setDebug('Audio load timeout - took too long to load');\n            reject(new Error('Audio load timeout - took too long to load'));\n          }, 10000);\n          \n          const clearTimeoutHandler = () => {\n            clearTimeout(timeoutId);\n          };\n          \n          audioElement.addEventListener('canplaythrough', clearTimeoutHandler, { once: true });\n          audioElement.addEventListener('error', clearTimeoutHandler, { once: true });\n        });\n        \n        audioElement.src = audioUrl;\n        audioElement.load();\n        \n        await audioLoadPromise;\n        \n        audioDurationRef.current = audioElement.duration;\n        setDebug(`Audio duration: ${audioDurationRef.current.toFixed(2)} seconds`);\n        \n        const audioSource = audioContext.createMediaElementSource(audioElement);\n        audioSourceRef.current = audioSource;\n        \n        const audioDestination = audioContext.createMediaStreamDestination();\n        \n        const gainNode = audioContext.createGain();\n        gainNode.gain.value = 1.0;\n        \n        audioSource.connect(gainNode);\n        gainNode.connect(audioDestination);\n        \n        const audioTracks = audioDestination.stream.getAudioTracks();\n        if (audioTracks.length === 0) {\n          setDebug('Warning: No audio tracks found in audio stream');\n        } else {\n          setDebug(`Audio stream created with ${audioTracks.length} audio tracks`);\n          \n          audioTracks.forEach((track, index) => {\n            console.log(`Audio track ${index}:`, track.label, track.enabled, track.readyState);\n          });\n        }\n\n        const combinedStream = new MediaStream([\n          ...videoTracks,\n          ...audioTracks\n        ]);\n\n        if (combinedStream.getTracks().length === 0) {\n          throw new Error(\"Combined stream has no tracks\");\n        }\n        setDebug(`Combined stream created with ${combinedStream.getTracks().length} total tracks`);\n\n        const selectedMimeType = EXPORT_FORMATS[selectedFormat].mimeType;\n        if (!MediaRecorder.isTypeSupported(selectedMimeType)) {\n          throw new Error(`Selected format ${EXPORT_FORMATS[selectedFormat].label} is not supported by your browser`);\n        }\n        \n        const options = {\n          mimeType: selectedMimeType,\n          videoBitsPerSecond: QUALITY_PRESETS[selectedQuality].videoBitrate,\n          audioBitsPerSecond: QUALITY_PRESETS[selectedQuality].audioBitrate\n        };\n          \n        try {\n          const mediaRecorder = new MediaRecorder(combinedStream, options);\n          mediaRecorderRef.current = mediaRecorder;\n          \n          console.log('MediaRecorder created:', mediaRecorder.mimeType, mediaRecorder.state);\n          setDebug(`MediaRecorder created with mime type: ${mediaRecorder.mimeType}, video bitrate: ${QUALITY_PRESETS[selectedQuality].videoBitrate/1000000}Mbps`);\n          \n          mediaRecorder.addEventListener('start', () => {\n            console.log('MediaRecorder started');\n            setDebug('Recording started at high quality');\n          });\n\n          mediaRecorder.addEventListener('error', (event) => {\n            console.error('MediaRecorder error:', event);\n            setDebug(`MediaRecorder error: ${event.error || 'Unknown error'}`);\n          });\n\n          mediaRecorder.ondataavailable = (event) => {\n            console.log('Data available event, size:', event.data.size);\n            if (event.data && event.data.size > 0) {\n              chunksRef.current.push(event.data);\n              setDebug(`Received data chunk: ${(event.data.size / 1024).toFixed(2)} KB, total chunks: ${chunksRef.current.length}`);\n            } else {\n              console.warn('Received empty data chunk');\n              setDebug('Warning: Received empty data chunk');\n            }\n          };\n\n          mediaRecorder.onstop = () => {\n            console.log('MediaRecorder stopped, chunks:', chunksRef.current.length);\n            setDebug(`Recording stopped with ${chunksRef.current.length} chunks`);\n            \n            if (chunksRef.current.length === 0) {\n              setDebug('Error: No data chunks were recorded');\n              alert('Error: No video data was captured during recording. This may be due to browser compatibility issues. Try using Chrome or Edge.');\n              setIsExporting(false);\n              cleanupResources();\n              return;\n            }\n            \n            const totalSize = chunksRef.current.reduce((size, chunk) => size + chunk.size, 0);\n            setDebug(`Total data size: ${(totalSize / 1024 / 1024).toFixed(2)} MB`);\n            \n            if (totalSize === 0) {\n              setDebug('Error: Recorded data has zero size');\n              alert('Error: The recorded video has no data (0 bytes). Try using a different browser or visualization.');\n              setIsExporting(false);\n              cleanupResources();\n              return;\n            }\n\n            try {\n              const blob = new Blob(chunksRef.current, { type: selectedMimeType });\n              console.log('Created blob, size:', blob.size);\n              setDebug(`Created video blob: ${(blob.size / 1024 / 1024).toFixed(2)} MB`);\n              \n              if (blob.size === 0) {\n                setDebug('Error: Final blob has zero size');\n                alert('Error: The final video file has no data (0 bytes). Try using a different browser.');\n                setIsExporting(false);\n                cleanupResources();\n                return;\n              }\n              \n              const url = URL.createObjectURL(blob);\n              \n              let fileName = \"visualization.\" + EXPORT_FORMATS[selectedFormat].extension;\n              if (audioFile && audioFile.name) {\n                fileName = audioFile.name.replace(/\\.[^/.]+$/, \"\") + \"_visualization.\" + EXPORT_FORMATS[selectedFormat].extension;\n              } else if (audioFile && audioFile.path) {\n                const pathParts = audioFile.path.split('/');\n                const pathFileName = pathParts[pathParts.length - 1];\n                fileName = pathFileName.replace(/\\.[^/.]+$/, \"\") + \"_visualization.\" + EXPORT_FORMATS[selectedFormat].extension;\n              }\n              \n              const a = document.createElement('a');\n              a.href = url;\n              a.download = fileName;\n              a.click();\n              \n              URL.revokeObjectURL(url);\n              setIsExporting(false);\n              setProgress(100);\n              setDebug('Export completed successfully');\n              \n              cleanupResources();\n            } catch (blobError) {\n              console.error('Error creating blob:', blobError);\n              setDebug(`Error creating video file: ${blobError.message}`);\n              alert(`Error creating video file: ${blobError.message}`);\n              setIsExporting(false);\n              cleanupResources();\n            }\n          };\n\n          mediaRecorder.start(100);\n          setDebug('MediaRecorder started with 100ms timeslice for high quality');\n\n          try {\n            await audioElement.play();\n            setDebug('Silent audio playback started for timing');\n            \n            if (canvas) {\n              const ctx = canvas.getContext('2d');\n              ctx.fillStyle = 'rgba(0,0,0,0.01)';\n              ctx.fillRect(0, 0, 1, 1);\n            }\n            \n          } catch (playError) {\n            console.error('Error playing audio:', playError);\n            setDebug(`Failed to play audio: ${playError.message || 'Unknown error'}`);\n            throw new Error(`Failed to play audio: ${playError.message}`);\n          }\n\n          dataRequestIntervalRef.current = setInterval(() => {\n            if (mediaRecorderRef.current && mediaRecorderRef.current.state === 'recording') {\n              mediaRecorderRef.current.requestData();\n              \n              if (canvas) {\n                try {\n                  const ctx = canvas.getContext('2d');\n                  ctx.fillStyle = 'rgba(0,0,0,0.01)';\n                  ctx.fillRect(0, 0, 1, 1);\n                } catch (e) {\n                  console.error('Error keeping canvas active:', e);\n                }\n              }\n            }\n          }, 1000);\n\n          progressIntervalRef.current = setInterval(() => {\n            if (audioDurationRef.current) {\n              const elapsed = (Date.now() - startTimeRef.current) / 1000;\n              const percentage = Math.min(Math.floor((elapsed / audioDurationRef.current) * 100), 99);\n              setProgress(percentage);\n              \n              setDebug(`Progress: ${percentage}%, Chunks: ${chunksRef.current.length}, Duration: ${elapsed.toFixed(1)}s/${audioDurationRef.current.toFixed(1)}s`);\n              \n              if (elapsed > 3 && chunksRef.current.length === 0) {\n                setDebug('Warning: No data chunks received after 3 seconds');\n              }\n            }\n          }, 500);\n\n          audioElement.onended = () => {\n            setDebug('Audio playback ended, stopping recording');\n            \n            if (dataRequestIntervalRef.current) {\n              clearInterval(dataRequestIntervalRef.current);\n              dataRequestIntervalRef.current = null;\n            }\n            \n            if (mediaRecorderRef.current && mediaRecorderRef.current.state === 'recording') {\n              mediaRecorderRef.current.requestData();\n              \n              setTimeout(() => {\n                try {\n                  mediaRecorderRef.current.stop();\n                } catch (stopError) {\n                  console.error('Error stopping MediaRecorder:', stopError);\n                  setDebug(`Error stopping recording: ${stopError.message}`);\n                  setIsExporting(false);\n                  cleanupResources();\n                }\n              }, 500);\n            }\n          };\n          \n        } catch (recorderError) {\n          console.error('Error creating MediaRecorder:', recorderError);\n          setDebug(`Failed to create MediaRecorder: ${recorderError.message}`);\n          throw new Error(`Failed to create MediaRecorder: ${recorderError.message}. Try using a different browser.`);\n        }\n      } catch (audioError) {\n        console.error('Error setting up audio:', audioError);\n        setDebug(`Audio setup error: ${audioError.message}`);\n        throw new Error(`Failed to set up audio: ${audioError.message}`);\n      }\n\n    } catch (error) {\n      console.error(\"Error exporting video:\", error);\n      setDebug(`Export error: ${error.message || 'Unknown error'}`);\n      \n      if (retryCount < MAX_RETRIES) {\n        setDebug(`Retrying export (attempt ${retryCount + 1} of ${MAX_RETRIES})...`);\n        await retryExport(exportVideo);\n      } else {\n        alert(`Error exporting video: ${error.message}`);\n        setIsExporting(false);\n        cleanupResources();\n      }\n    }\n  };\n\n  return (\n    <div className=\"video-exporter\">\n      {isExporting ? (\n        <div className=\"export-progress\">\n          <div className=\"progress-bar\">\n            <div className=\"progress-fill\" style={{ width: `${progress}%` }}></div>\n          </div>\n          <div className=\"progress-text\">{progress}% Exporting...</div>\n          <div className=\"debug-info\">{debug}</div>\n        </div>\n      ) : (\n        <div className=\"export-controls\">\n          <select \n            value={selectedQuality} \n            onChange={(e) => setSelectedQuality(e.target.value)}\n            className=\"quality-select\"\n          >\n            {Object.entries(QUALITY_PRESETS).map(([key, preset]) => (\n              <option key={key} value={key}>{preset.label}</option>\n            ))}\n          </select>\n          <select \n            value={selectedFormat} \n            onChange={(e) => setSelectedFormat(e.target.value)}\n            className=\"format-select\"\n          >\n            {Object.entries(EXPORT_FORMATS).map(([key, format]) => (\n              <option key={key} value={key}>{format.label}</option>\n            ))}\n          </select>\n          <button\n            className=\"export-button\"\n            onClick={exportVideo}\n            disabled={!visualizerRef || !audioFile || isPlaying}\n          >\n            Export Video\n          </button>\n        </div>\n      )}\n    </div>\n  );\n};\n\nexport default VideoExporter; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}