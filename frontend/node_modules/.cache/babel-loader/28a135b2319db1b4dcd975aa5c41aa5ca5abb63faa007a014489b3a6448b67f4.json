{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\fkuce\\\\OneDrive\\\\Desktop\\\\Money Projects\\\\Visualizer\\\\frontend\\\\src\\\\components\\\\Visualizer.js\",\n  _s = $RefreshSig$();\nimport React, { useEffect, useRef, forwardRef, useState } from 'react';\nimport ThreeVisualizer from './ThreeVisualizer';\nimport './Visualizer.css';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst RESOLUTIONS = {\n  '4K': {\n    width: 3840,\n    height: 2160,\n    className: 'aspect-ratio-4k'\n  },\n  '1080p': {\n    width: 1920,\n    height: 1080,\n    className: 'aspect-ratio-1080p'\n  },\n  '720p': {\n    width: 1280,\n    height: 720,\n    className: 'aspect-ratio-720p'\n  },\n  'Square': {\n    width: 720,\n    height: 720,\n    className: 'aspect-ratio-square'\n  },\n  'Vertical': {\n    width: 1080,\n    height: 1920,\n    className: 'aspect-ratio-vertical'\n  }\n};\nconst Visualizer = /*#__PURE__*/_s(/*#__PURE__*/forwardRef(_c = _s(({\n  audioFile,\n  template,\n  isPlaying,\n  onAudioElementCreated,\n  parameters = {}\n}, ref) => {\n  _s();\n  const canvasRef = useRef(null);\n  const containerRef = useRef(null);\n  const audioContextRef = useRef(null);\n  const analyserRef = useRef(null);\n  const animationFrameRef = useRef(null);\n  const sourceRef = useRef(null);\n  const audioElementRef = useRef(null);\n  const particlesRef = useRef([]);\n  const [resolution, setResolution] = useState('1080p'); // Default to 1080p\n  const [audioData, setAudioData] = useState(null);\n  const [use3D, setUse3D] = useState(false);\n\n  // Check if template is a 3D visualization\n  useEffect(() => {\n    // Define which templates should use 3D rendering\n    const threeDTemplates = ['particles3d', 'waveform3d', 'spiral3d', 'kaleidoscope3d'];\n    setUse3D(threeDTemplates.includes(template));\n  }, [template]);\n\n  // Audio initialization effect\n  useEffect(() => {\n    if (!audioFile) return;\n    let isInitialized = false;\n    const initAudio = async () => {\n      try {\n        // Initialize audio context only on first load or if it doesn't exist\n        if (!audioContextRef.current) {\n          // Create context on user interaction\n          const context = new (window.AudioContext || window.webkitAudioContext)();\n          audioContextRef.current = context;\n\n          // Create analyzer\n          const analyser = context.createAnalyser();\n          analyser.fftSize = 2048;\n          analyserRef.current = analyser;\n        }\n\n        // Create and set up audio element\n        const audioElement = new Audio();\n        audioElement.crossOrigin = \"anonymous\";\n        audioElement.preload = \"auto\";\n\n        // Set the audio source\n        const timestamp = new Date().getTime();\n        audioElement.src = `http://localhost:5001${audioFile.path}?t=${timestamp}`;\n\n        // Wait for audio to be loaded enough to play\n        await new Promise((resolve, reject) => {\n          const loadHandler = () => {\n            console.log('Audio loaded, duration:', audioElement.duration);\n            resolve();\n          };\n          const errorHandler = error => {\n            console.error('Audio load error:', error);\n            reject(error);\n          };\n          audioElement.addEventListener('canplaythrough', loadHandler, {\n            once: true\n          });\n          audioElement.addEventListener('error', errorHandler, {\n            once: true\n          });\n          audioElement.load();\n        });\n\n        // Only create new media source if not already connected\n        if (!isInitialized) {\n          // Ensure old source is disconnected\n          if (sourceRef.current) {\n            sourceRef.current.disconnect();\n          }\n\n          // Create and connect new media source\n          const mediaSource = audioContextRef.current.createMediaElementSource(audioElement);\n          sourceRef.current = mediaSource;\n          mediaSource.connect(analyserRef.current);\n          analyserRef.current.connect(audioContextRef.current.destination);\n          isInitialized = true;\n        }\n\n        // Set up event listeners\n        const onSeeking = () => {\n          console.log('Seeking:', audioElement.currentTime);\n          if (isPlaying) startVisualization();\n        };\n        const onTimeUpdate = () => {\n          console.log('Time update:', audioElement.currentTime);\n          if (isPlaying) startVisualization();\n        };\n        audioElement.addEventListener('seeking', onSeeking);\n        audioElement.addEventListener('seeked', onSeeking);\n        audioElement.addEventListener('timeupdate', onTimeUpdate);\n\n        // Store reference and notify parent\n        audioElementRef.current = audioElement;\n        onAudioElementCreated(audioElement);\n\n        // Resume audio context if suspended\n        if (audioContextRef.current.state === 'suspended') {\n          await audioContextRef.current.resume();\n        }\n        return () => {\n          console.log('Cleaning up audio element');\n          audioElement.removeEventListener('seeking', onSeeking);\n          audioElement.removeEventListener('seeked', onSeeking);\n          audioElement.removeEventListener('timeupdate', onTimeUpdate);\n          audioElement.pause();\n          audioElement.src = '';\n          onAudioElementCreated(null);\n        };\n      } catch (error) {\n        console.error('Audio initialization error:', error);\n        alert('Error loading audio. Please try again.');\n      }\n    };\n    initAudio();\n  }, [audioFile]); // Remove isPlaying from dependencies\n\n  // Separate playback control effect\n  useEffect(() => {\n    const audioElement = audioElementRef.current;\n    if (!audioElement) return;\n    const playAudio = async () => {\n      try {\n        var _audioContextRef$curr;\n        // Ensure audio context is running\n        if (((_audioContextRef$curr = audioContextRef.current) === null || _audioContextRef$curr === void 0 ? void 0 : _audioContextRef$curr.state) === 'suspended') {\n          await audioContextRef.current.resume();\n        }\n        console.log('Playing audio...');\n        await audioElement.play();\n        startVisualization();\n      } catch (error) {\n        console.error('Playback error:', error);\n        alert('Error playing audio. Please try again.');\n      }\n    };\n    if (isPlaying) {\n      playAudio();\n    } else {\n      console.log('Pausing audio...');\n      audioElement.pause();\n      cancelAnimationFrame(animationFrameRef.current);\n    }\n  }, [isPlaying]);\n\n  // Add effect to handle template changes\n  useEffect(() => {\n    if (!canvasRef.current) return;\n    const canvas = canvasRef.current;\n    const ctx = canvas.getContext('2d');\n\n    // Clear the entire canvas\n    ctx.fillStyle = 'rgb(0, 0, 0)';\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n    // Restart visualization if playing\n    if (isPlaying) {\n      startVisualization();\n    }\n  }, [template]);\n\n  // Update canvas size based on selected resolution\n  useEffect(() => {\n    if (!canvasRef.current) return;\n    const canvas = canvasRef.current;\n    const {\n      width,\n      height\n    } = RESOLUTIONS[resolution];\n\n    // Set canvas dimensions to match the selected resolution\n    canvas.width = width;\n    canvas.height = height;\n\n    // Clear canvas with new dimensions\n    const ctx = canvas.getContext('2d');\n    ctx.fillStyle = 'rgb(0, 0, 0)';\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n    // Adjust container styles based on aspect ratio\n    if (containerRef.current) {\n      if (resolution === 'Vertical') {\n        containerRef.current.style.width = 'auto';\n        containerRef.current.style.height = '80vh';\n      } else if (resolution === 'Square') {\n        containerRef.current.style.width = '720px';\n        containerRef.current.style.height = '720px';\n        containerRef.current.style.maxWidth = '720px';\n        containerRef.current.style.maxHeight = '720px';\n      } else {\n        containerRef.current.style.width = '100%';\n        containerRef.current.style.height = 'auto';\n        containerRef.current.style.maxWidth = `${width}px`;\n        containerRef.current.style.maxHeight = `${height}px`;\n      }\n    }\n\n    // Restart visualization if playing\n    if (isPlaying) {\n      startVisualization();\n    }\n\n    // Initialize particles for the new canvas size\n    if (template === 'particles') {\n      initParticles(ctx);\n    }\n  }, [resolution, isPlaying, template]);\n\n  // Function to change resolution\n  const changeResolution = newResolution => {\n    if (RESOLUTIONS[newResolution]) {\n      setResolution(newResolution);\n    }\n  };\n\n  // Expose changeResolution to parent via ref\n  React.useImperativeHandle(ref, () => ({\n    changeResolution,\n    getCurrentResolution: () => resolution,\n    updateParameters\n  }));\n  const initParticles = ctx => {\n    particlesRef.current = [];\n    const numParticles = 100;\n    for (let i = 0; i < numParticles; i++) {\n      particlesRef.current.push({\n        x: Math.random() * ctx.canvas.width,\n        y: Math.random() * ctx.canvas.height,\n        size: Math.random() * 4 + 2,\n        speedX: Math.random() * 4 - 2,\n        speedY: Math.random() * 4 - 2,\n        hue: Math.random() * 360\n      });\n    }\n  };\n  const updateAndDrawParticles = (ctx, dataArray, bufferLength) => {\n    // Apply parameters\n    const color = parameters.color || '#ffffff';\n    const particleCount = Math.floor((parameters.count || 50) / 100 * particlesRef.current.length);\n    const particleSize = (parameters.size || 50) / 10; // Convert to 0-10 scale\n    const speed = (parameters.speed || 50) / 50; // Convert to 0-2 scale\n    const reactivity = (parameters.reactivity || 50) / 50; // Convert to 0-2 scale\n\n    // Clear canvas with fade effect\n    ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';\n    ctx.fillRect(0, 0, canvasRef.current.width, canvasRef.current.height);\n\n    // Update and draw particles\n    for (let i = 0; i < particleCount; i++) {\n      const particle = particlesRef.current[i];\n\n      // Get audio data for this particle\n      const dataIndex = Math.floor(i / particleCount * bufferLength);\n      const audioValue = dataArray[dataIndex] / 256.0 * reactivity;\n\n      // Update position\n      particle.x += particle.speedX * speed;\n      particle.y += particle.speedY * speed;\n\n      // Apply audio reactivity\n      particle.size = particleSize * (1 + audioValue);\n\n      // Wrap around edges\n      if (particle.x < 0) particle.x = canvasRef.current.width;\n      if (particle.x > canvasRef.current.width) particle.x = 0;\n      if (particle.y < 0) particle.y = canvasRef.current.height;\n      if (particle.y > canvasRef.current.height) particle.y = 0;\n\n      // Draw particle\n      ctx.beginPath();\n      ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);\n\n      // Use color parameter with slight variation\n      const particleColor = adjustColor(color, i % 20 - 10);\n      ctx.fillStyle = particleColor;\n      ctx.fill();\n    }\n  };\n\n  // Helper function to adjust colors\n  const adjustColor = (hexColor, amount) => {\n    // Convert hex to RGB\n    let r = parseInt(hexColor.substring(1, 3), 16);\n    let g = parseInt(hexColor.substring(3, 5), 16);\n    let b = parseInt(hexColor.substring(5, 7), 16);\n\n    // Adjust RGB values\n    r = Math.max(0, Math.min(255, r + amount));\n    g = Math.max(0, Math.min(255, g + amount));\n    b = Math.max(0, Math.min(255, b + amount));\n\n    // Convert back to hex\n    return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;\n  };\n\n  // Start visualization\n  const startVisualization = () => {\n    if (!analyserRef.current || !canvasRef.current) return;\n    const analyser = analyserRef.current;\n    const canvas = canvasRef.current;\n    const ctx = canvas.getContext('2d');\n\n    // Create data arrays for audio analysis\n    const bufferLength = analyser.frequencyBinCount;\n    const dataArray = new Uint8Array(bufferLength);\n    const timeArray = new Uint8Array(bufferLength);\n\n    // Get initial data\n    analyser.getByteFrequencyData(dataArray);\n    analyser.getByteTimeDomainData(timeArray);\n\n    // Update audio data for 3D visualizer\n    setAudioData({\n      dataArray: Array.from(dataArray),\n      timeArray: Array.from(timeArray),\n      bufferLength\n    });\n\n    // Cancel any existing animation frame\n    if (animationFrameRef.current) {\n      cancelAnimationFrame(animationFrameRef.current);\n    }\n\n    // Skip 2D visualization if using 3D\n    if (use3D) {\n      // For 3D, we need to continuously update the audio data\n      const update3DAudio = () => {\n        animationFrameRef.current = requestAnimationFrame(update3DAudio);\n\n        // Get frequency and time domain data\n        analyser.getByteFrequencyData(dataArray);\n        analyser.getByteTimeDomainData(timeArray);\n\n        // Update audio data for 3D visualizer\n        setAudioData({\n          dataArray: Array.from(dataArray),\n          timeArray: Array.from(timeArray),\n          bufferLength\n        });\n      };\n      update3DAudio();\n      return;\n    }\n\n    // Animation function for 2D visualizations\n    const draw = () => {\n      animationFrameRef.current = requestAnimationFrame(draw);\n\n      // Get frequency and time domain data\n      analyser.getByteFrequencyData(dataArray);\n      analyser.getByteTimeDomainData(timeArray);\n\n      // Clear canvas\n      ctx.fillStyle = 'rgb(0, 0, 0)';\n      ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n      // Draw visualization based on template\n      switch (template) {\n        case 'waveform':\n          drawWaveform(ctx, dataArray, bufferLength);\n          break;\n        case 'bars':\n          drawBars(ctx, dataArray, bufferLength);\n          break;\n        case 'circles':\n          drawCircles(ctx, dataArray, bufferLength);\n          break;\n        case 'kaleidoscope':\n          drawKaleidoscope(ctx, dataArray, timeArray, bufferLength);\n          break;\n        case 'spiral':\n          drawSpiral(ctx, dataArray, timeArray, bufferLength);\n          break;\n        case 'particles':\n          updateAndDrawParticles(ctx, dataArray, bufferLength);\n          break;\n        default:\n          drawWaveform(ctx, dataArray, bufferLength);\n      }\n    };\n    draw();\n  };\n  const drawWaveform = (ctx, dataArray, bufferLength) => {\n    // Apply parameters\n    const lineWidth = parameters.lineWidth || 3;\n    const color = parameters.color || '#00aaff';\n    const reactivity = (parameters.reactivity || 50) / 50; // Convert to 0-2 scale\n    const smoothing = (parameters.smoothing || 50) / 100; // Convert to 0-1 scale\n\n    ctx.lineWidth = lineWidth;\n    ctx.strokeStyle = color;\n    ctx.beginPath();\n    const sliceWidth = canvasRef.current.width * 1.0 / bufferLength;\n    let x = 0;\n    for (let i = 0; i < bufferLength; i++) {\n      const v = dataArray[i] / 128.0 * reactivity;\n      const y = v * canvasRef.current.height / 2;\n      if (i === 0) {\n        ctx.moveTo(x, y);\n      } else {\n        // Apply smoothing if enabled\n        if (smoothing > 0) {\n          const prevX = x - sliceWidth;\n          const prevY = dataArray[i - 1] / 128.0 * reactivity * canvasRef.current.height / 2;\n          const cpX1 = prevX + sliceWidth / 3;\n          const cpX2 = x - sliceWidth / 3;\n          const cpY1 = prevY;\n          const cpY2 = y;\n\n          // Use bezier curve for smoothing\n          ctx.bezierCurveTo(cpX1, cpY1, cpX2, cpY2, x, y);\n        } else {\n          ctx.lineTo(x, y);\n        }\n      }\n      x += sliceWidth;\n    }\n    ctx.lineTo(canvasRef.current.width, canvasRef.current.height / 2);\n    ctx.stroke();\n  };\n  const drawBars = (ctx, dataArray, bufferLength) => {\n    // Apply parameters\n    const color = parameters.color || '#ff5500';\n    const barWidth = (parameters.barWidth || 50) / 100; // Convert to 0-1 scale\n    const spacing = (parameters.spacing || 30) / 100; // Convert to 0-1 scale\n    const reactivity = (parameters.reactivity || 50) / 25; // Convert to 0-4 scale\n\n    const bars = Math.min(bufferLength, 256);\n    const width = canvasRef.current.width / bars;\n    const actualBarWidth = width * barWidth;\n    const barSpacing = width * spacing;\n    for (let i = 0; i < bars; i++) {\n      const barHeight = dataArray[i] * reactivity;\n\n      // Create gradient for each bar\n      const gradient = ctx.createLinearGradient(0, canvasRef.current.height, 0, canvasRef.current.height - barHeight);\n      gradient.addColorStop(0, color);\n      gradient.addColorStop(1, adjustColor(color, 30)); // Lighter at the top\n\n      ctx.fillStyle = gradient;\n      ctx.fillRect(i * width + barSpacing / 2, canvasRef.current.height - barHeight, actualBarWidth, barHeight);\n    }\n  };\n  const drawCircles = (ctx, dataArray, bufferLength) => {\n    // Apply parameters\n    const color = parameters.color || '#ff00ff';\n    const baseRadius = (parameters.radius || 50) / 100 * Math.min(canvasRef.current.width, canvasRef.current.height) / 2;\n    const circleCount = Math.max(1, Math.min(20, Math.floor((parameters.count || 50) / 5))); // 1-20 circles\n    const reactivity = (parameters.reactivity || 50) / 50; // Convert to 0-2 scale\n\n    const centerX = canvasRef.current.width / 2;\n    const centerY = canvasRef.current.height / 2;\n    for (let i = 0; i < circleCount; i++) {\n      const radius = baseRadius * (i + 1) / circleCount;\n      ctx.beginPath();\n      ctx.strokeStyle = adjustColor(color, i * 5); // Slightly different color for each circle\n\n      // Draw circle with audio-reactive distortion\n      for (let j = 0; j < 360; j += 5) {\n        const angleRad = j * Math.PI / 180;\n        const dataIndex = Math.floor(j / 360 * bufferLength);\n        const distortion = dataArray[dataIndex] / 128.0 * reactivity;\n        const x = centerX + Math.cos(angleRad) * radius * distortion;\n        const y = centerY + Math.sin(angleRad) * radius * distortion;\n        if (j === 0) {\n          ctx.moveTo(x, y);\n        } else {\n          ctx.lineTo(x, y);\n        }\n      }\n      ctx.closePath();\n      ctx.stroke();\n    }\n  };\n  const drawKaleidoscope = (ctx, dataArray, timeArray, bufferLength) => {\n    // Apply parameters\n    const color = parameters.color || '#ffaa00';\n    const segments = parameters.segments || 8;\n    const speed = (parameters.speed || 50) / 1000; // Convert to 0-0.05 scale\n    const reactivity = (parameters.reactivity || 50) / 50; // Convert to 0-2 scale\n\n    const centerX = canvasRef.current.width / 2;\n    const centerY = canvasRef.current.height / 2;\n    const radius = Math.min(centerX, centerY) * 0.8;\n\n    // Rotate based on time and speed\n    ctx.translate(centerX, centerY);\n    ctx.rotate(timeRef.current * speed);\n\n    // Draw kaleidoscope segments\n    for (let s = 0; s < segments; s++) {\n      ctx.rotate(Math.PI * 2 / segments);\n      ctx.beginPath();\n      ctx.strokeStyle = adjustColor(color, s * 5);\n\n      // Draw audio-reactive pattern\n      for (let i = 0; i < bufferLength; i += 8) {\n        const x = dataArray[i] / 256.0 * radius * reactivity;\n        const y = timeArray[i] / 256.0 * radius * reactivity;\n        if (i === 0) {\n          ctx.moveTo(x, y);\n        } else {\n          ctx.lineTo(x, y);\n        }\n      }\n      ctx.stroke();\n    }\n\n    // Reset transformation\n    ctx.setTransform(1, 0, 0, 1, 0, 0);\n  };\n  const drawSpiral = (ctx, dataArray, timeArray, bufferLength) => {\n    // Apply parameters\n    const color = parameters.color || '#00ff99';\n    const arms = parameters.arms || 5;\n    const speed = (parameters.speed || 50) / 1000; // Convert to 0-0.05 scale\n    const reactivity = (parameters.reactivity || 50) / 50; // Convert to 0-2 scale\n\n    const centerX = canvasRef.current.width / 2;\n    const centerY = canvasRef.current.height / 2;\n    const maxRadius = Math.min(centerX, centerY) * 0.9;\n\n    // Rotate based on time and speed\n    ctx.translate(centerX, centerY);\n    ctx.rotate(timeRef.current * speed);\n\n    // Draw spiral arms\n    for (let a = 0; a < arms; a++) {\n      const armAngle = a / arms * Math.PI * 2;\n      const hue = a / arms * 360;\n      ctx.beginPath();\n      ctx.strokeStyle = adjustColor(color, a * 10);\n      for (let i = 0; i < 100; i++) {\n        const t = i / 100;\n        const angle = armAngle + t * Math.PI * 6;\n        const radius = t * maxRadius;\n\n        // Apply audio reactivity\n        const dataIndex = Math.floor(t * bufferLength);\n        const audioValue = dataArray[dataIndex] / 128.0 * reactivity;\n        const x = Math.cos(angle) * radius * audioValue;\n        const y = Math.sin(angle) * radius * audioValue;\n        if (i === 0) {\n          ctx.moveTo(x, y);\n        } else {\n          ctx.lineTo(x, y);\n        }\n      }\n      ctx.stroke();\n    }\n\n    // Reset transformation\n    ctx.setTransform(1, 0, 0, 1, 0, 0);\n  };\n\n  // Add a function to update parameters\n  const updateParameters = newParameters => {\n    console.log(\"Updating visualization parameters:\", newParameters);\n    // Parameters will be applied in the visualization functions\n  };\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"visualizer-container\",\n    children: /*#__PURE__*/_jsxDEV(\"div\", {\n      ref: containerRef,\n      className: `visualizer-aspect-container ${RESOLUTIONS[resolution].className}`,\n      children: [use3D ? /*#__PURE__*/_jsxDEV(ThreeVisualizer, {\n        audioData: audioData,\n        template: template.replace('3d', '') // Remove '3d' suffix for the ThreeVisualizer\n        ,\n        isPlaying: isPlaying\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 619,\n        columnNumber: 11\n      }, this) : /*#__PURE__*/_jsxDEV(\"canvas\", {\n        ref: canvasRef,\n        className: \"visualizer-canvas\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 625,\n        columnNumber: 11\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"visualizer-overlay\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 627,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"resolution-indicator\",\n        children: [resolution, \" (\", RESOLUTIONS[resolution].width, \"\\xD7\", RESOLUTIONS[resolution].height, \")\"]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 628,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 614,\n      columnNumber: 7\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 613,\n    columnNumber: 5\n  }, this);\n}, \"yphw8ce6beSd9NdRpFAlHUBWJXQ=\")), \"yphw8ce6beSd9NdRpFAlHUBWJXQ=\");\n_c2 = Visualizer;\nexport default Visualizer;\nvar _c, _c2;\n$RefreshReg$(_c, \"Visualizer$forwardRef\");\n$RefreshReg$(_c2, \"Visualizer\");","map":{"version":3,"names":["React","useEffect","useRef","forwardRef","useState","ThreeVisualizer","jsxDEV","_jsxDEV","RESOLUTIONS","width","height","className","Visualizer","_s","_c","audioFile","template","isPlaying","onAudioElementCreated","parameters","ref","canvasRef","containerRef","audioContextRef","analyserRef","animationFrameRef","sourceRef","audioElementRef","particlesRef","resolution","setResolution","audioData","setAudioData","use3D","setUse3D","threeDTemplates","includes","isInitialized","initAudio","current","context","window","AudioContext","webkitAudioContext","analyser","createAnalyser","fftSize","audioElement","Audio","crossOrigin","preload","timestamp","Date","getTime","src","path","Promise","resolve","reject","loadHandler","console","log","duration","errorHandler","error","addEventListener","once","load","disconnect","mediaSource","createMediaElementSource","connect","destination","onSeeking","currentTime","startVisualization","onTimeUpdate","state","resume","removeEventListener","pause","alert","playAudio","_audioContextRef$curr","play","cancelAnimationFrame","canvas","ctx","getContext","fillStyle","fillRect","style","maxWidth","maxHeight","initParticles","changeResolution","newResolution","useImperativeHandle","getCurrentResolution","updateParameters","numParticles","i","push","x","Math","random","y","size","speedX","speedY","hue","updateAndDrawParticles","dataArray","bufferLength","color","particleCount","floor","count","length","particleSize","speed","reactivity","particle","dataIndex","audioValue","beginPath","arc","PI","particleColor","adjustColor","fill","hexColor","amount","r","parseInt","substring","g","b","max","min","toString","padStart","frequencyBinCount","Uint8Array","timeArray","getByteFrequencyData","getByteTimeDomainData","Array","from","update3DAudio","requestAnimationFrame","draw","drawWaveform","drawBars","drawCircles","drawKaleidoscope","drawSpiral","lineWidth","smoothing","strokeStyle","sliceWidth","v","moveTo","prevX","prevY","cpX1","cpX2","cpY1","cpY2","bezierCurveTo","lineTo","stroke","barWidth","spacing","bars","actualBarWidth","barSpacing","barHeight","gradient","createLinearGradient","addColorStop","baseRadius","radius","circleCount","centerX","centerY","j","angleRad","distortion","cos","sin","closePath","segments","translate","rotate","timeRef","s","setTransform","arms","maxRadius","a","armAngle","t","angle","newParameters","children","replace","fileName","_jsxFileName","lineNumber","columnNumber","_c2","$RefreshReg$"],"sources":["C:/Users/fkuce/OneDrive/Desktop/Money Projects/Visualizer/frontend/src/components/Visualizer.js"],"sourcesContent":["import React, { useEffect, useRef, forwardRef, useState } from 'react';\r\nimport ThreeVisualizer from './ThreeVisualizer';\r\nimport './Visualizer.css';\r\n\r\nconst RESOLUTIONS = {\r\n  '4K': { width: 3840, height: 2160, className: 'aspect-ratio-4k' },\r\n  '1080p': { width: 1920, height: 1080, className: 'aspect-ratio-1080p' },\r\n  '720p': { width: 1280, height: 720, className: 'aspect-ratio-720p' },\r\n  'Square': { width: 720, height: 720, className: 'aspect-ratio-square' },\r\n  'Vertical': { width: 1080, height: 1920, className: 'aspect-ratio-vertical' }\r\n};\r\n\r\nconst Visualizer = forwardRef(({ audioFile, template, isPlaying, onAudioElementCreated, parameters = {} }, ref) => {\r\n  const canvasRef = useRef(null);\r\n  const containerRef = useRef(null);\r\n  const audioContextRef = useRef(null);\r\n  const analyserRef = useRef(null);\r\n  const animationFrameRef = useRef(null);\r\n  const sourceRef = useRef(null);\r\n  const audioElementRef = useRef(null);\r\n  const particlesRef = useRef([]);\r\n  const [resolution, setResolution] = useState('1080p'); // Default to 1080p\r\n  const [audioData, setAudioData] = useState(null);\r\n  const [use3D, setUse3D] = useState(false);\r\n\r\n  // Check if template is a 3D visualization\r\n  useEffect(() => {\r\n    // Define which templates should use 3D rendering\r\n    const threeDTemplates = ['particles3d', 'waveform3d', 'spiral3d', 'kaleidoscope3d'];\r\n    setUse3D(threeDTemplates.includes(template));\r\n  }, [template]);\r\n\r\n  // Audio initialization effect\r\n  useEffect(() => {\r\n    if (!audioFile) return;\r\n\r\n    let isInitialized = false;\r\n\r\n    const initAudio = async () => {\r\n      try {\r\n        // Initialize audio context only on first load or if it doesn't exist\r\n        if (!audioContextRef.current) {\r\n          // Create context on user interaction\r\n          const context = new (window.AudioContext || window.webkitAudioContext)();\r\n          audioContextRef.current = context;\r\n          \r\n          // Create analyzer\r\n          const analyser = context.createAnalyser();\r\n          analyser.fftSize = 2048;\r\n          analyserRef.current = analyser;\r\n        }\r\n\r\n        // Create and set up audio element\r\n        const audioElement = new Audio();\r\n        audioElement.crossOrigin = \"anonymous\";\r\n        audioElement.preload = \"auto\";\r\n\r\n        // Set the audio source\r\n        const timestamp = new Date().getTime();\r\n        audioElement.src = `http://localhost:5001${audioFile.path}?t=${timestamp}`;\r\n\r\n        // Wait for audio to be loaded enough to play\r\n        await new Promise((resolve, reject) => {\r\n          const loadHandler = () => {\r\n            console.log('Audio loaded, duration:', audioElement.duration);\r\n            resolve();\r\n          };\r\n\r\n          const errorHandler = (error) => {\r\n            console.error('Audio load error:', error);\r\n            reject(error);\r\n          };\r\n\r\n          audioElement.addEventListener('canplaythrough', loadHandler, { once: true });\r\n          audioElement.addEventListener('error', errorHandler, { once: true });\r\n          audioElement.load();\r\n        });\r\n\r\n        // Only create new media source if not already connected\r\n        if (!isInitialized) {\r\n          // Ensure old source is disconnected\r\n          if (sourceRef.current) {\r\n            sourceRef.current.disconnect();\r\n          }\r\n\r\n          // Create and connect new media source\r\n          const mediaSource = audioContextRef.current.createMediaElementSource(audioElement);\r\n          sourceRef.current = mediaSource;\r\n          mediaSource.connect(analyserRef.current);\r\n          analyserRef.current.connect(audioContextRef.current.destination);\r\n          isInitialized = true;\r\n        }\r\n\r\n        // Set up event listeners\r\n        const onSeeking = () => {\r\n          console.log('Seeking:', audioElement.currentTime);\r\n          if (isPlaying) startVisualization();\r\n        };\r\n\r\n        const onTimeUpdate = () => {\r\n          console.log('Time update:', audioElement.currentTime);\r\n          if (isPlaying) startVisualization();\r\n        };\r\n\r\n        audioElement.addEventListener('seeking', onSeeking);\r\n        audioElement.addEventListener('seeked', onSeeking);\r\n        audioElement.addEventListener('timeupdate', onTimeUpdate);\r\n\r\n        // Store reference and notify parent\r\n        audioElementRef.current = audioElement;\r\n        onAudioElementCreated(audioElement);\r\n\r\n        // Resume audio context if suspended\r\n        if (audioContextRef.current.state === 'suspended') {\r\n          await audioContextRef.current.resume();\r\n        }\r\n\r\n        return () => {\r\n          console.log('Cleaning up audio element');\r\n          audioElement.removeEventListener('seeking', onSeeking);\r\n          audioElement.removeEventListener('seeked', onSeeking);\r\n          audioElement.removeEventListener('timeupdate', onTimeUpdate);\r\n          audioElement.pause();\r\n          audioElement.src = '';\r\n          onAudioElementCreated(null);\r\n        };\r\n      } catch (error) {\r\n        console.error('Audio initialization error:', error);\r\n        alert('Error loading audio. Please try again.');\r\n      }\r\n    };\r\n\r\n    initAudio();\r\n  }, [audioFile]); // Remove isPlaying from dependencies\r\n\r\n  // Separate playback control effect\r\n  useEffect(() => {\r\n    const audioElement = audioElementRef.current;\r\n    if (!audioElement) return;\r\n\r\n    const playAudio = async () => {\r\n      try {\r\n        // Ensure audio context is running\r\n        if (audioContextRef.current?.state === 'suspended') {\r\n          await audioContextRef.current.resume();\r\n        }\r\n        \r\n        console.log('Playing audio...');\r\n        await audioElement.play();\r\n        startVisualization();\r\n      } catch (error) {\r\n        console.error('Playback error:', error);\r\n        alert('Error playing audio. Please try again.');\r\n      }\r\n    };\r\n\r\n    if (isPlaying) {\r\n      playAudio();\r\n    } else {\r\n      console.log('Pausing audio...');\r\n      audioElement.pause();\r\n      cancelAnimationFrame(animationFrameRef.current);\r\n    }\r\n  }, [isPlaying]);\r\n\r\n  // Add effect to handle template changes\r\n  useEffect(() => {\r\n    if (!canvasRef.current) return;\r\n    \r\n    const canvas = canvasRef.current;\r\n    const ctx = canvas.getContext('2d');\r\n    \r\n    // Clear the entire canvas\r\n    ctx.fillStyle = 'rgb(0, 0, 0)';\r\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\r\n\r\n    // Restart visualization if playing\r\n    if (isPlaying) {\r\n      startVisualization();\r\n    }\r\n  }, [template]);\r\n\r\n  // Update canvas size based on selected resolution\r\n  useEffect(() => {\r\n    if (!canvasRef.current) return;\r\n    \r\n    const canvas = canvasRef.current;\r\n    const { width, height } = RESOLUTIONS[resolution];\r\n    \r\n    // Set canvas dimensions to match the selected resolution\r\n    canvas.width = width;\r\n    canvas.height = height;\r\n    \r\n    // Clear canvas with new dimensions\r\n    const ctx = canvas.getContext('2d');\r\n    ctx.fillStyle = 'rgb(0, 0, 0)';\r\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\r\n    \r\n    // Adjust container styles based on aspect ratio\r\n    if (containerRef.current) {\r\n      if (resolution === 'Vertical') {\r\n        containerRef.current.style.width = 'auto';\r\n        containerRef.current.style.height = '80vh';\r\n      } else if (resolution === 'Square') {\r\n        containerRef.current.style.width = '720px';\r\n        containerRef.current.style.height = '720px';\r\n        containerRef.current.style.maxWidth = '720px';\r\n        containerRef.current.style.maxHeight = '720px';\r\n      } else {\r\n        containerRef.current.style.width = '100%';\r\n        containerRef.current.style.height = 'auto';\r\n        containerRef.current.style.maxWidth = `${width}px`;\r\n        containerRef.current.style.maxHeight = `${height}px`;\r\n      }\r\n    }\r\n    \r\n    // Restart visualization if playing\r\n    if (isPlaying) {\r\n      startVisualization();\r\n    }\r\n    \r\n    // Initialize particles for the new canvas size\r\n    if (template === 'particles') {\r\n      initParticles(ctx);\r\n    }\r\n  }, [resolution, isPlaying, template]);\r\n\r\n  // Function to change resolution\r\n  const changeResolution = (newResolution) => {\r\n    if (RESOLUTIONS[newResolution]) {\r\n      setResolution(newResolution);\r\n    }\r\n  };\r\n\r\n  // Expose changeResolution to parent via ref\r\n  React.useImperativeHandle(ref, () => ({\r\n    changeResolution,\r\n    getCurrentResolution: () => resolution,\r\n    updateParameters\r\n  }));\r\n\r\n  const initParticles = (ctx) => {\r\n    particlesRef.current = [];\r\n    const numParticles = 100;\r\n    \r\n    for (let i = 0; i < numParticles; i++) {\r\n      particlesRef.current.push({\r\n        x: Math.random() * ctx.canvas.width,\r\n        y: Math.random() * ctx.canvas.height,\r\n        size: Math.random() * 4 + 2,\r\n        speedX: Math.random() * 4 - 2,\r\n        speedY: Math.random() * 4 - 2,\r\n        hue: Math.random() * 360\r\n      });\r\n    }\r\n  };\r\n\r\n  const updateAndDrawParticles = (ctx, dataArray, bufferLength) => {\r\n    // Apply parameters\r\n    const color = parameters.color || '#ffffff';\r\n    const particleCount = Math.floor(((parameters.count || 50) / 100) * particlesRef.current.length);\r\n    const particleSize = (parameters.size || 50) / 10; // Convert to 0-10 scale\r\n    const speed = (parameters.speed || 50) / 50; // Convert to 0-2 scale\r\n    const reactivity = (parameters.reactivity || 50) / 50; // Convert to 0-2 scale\r\n    \r\n    // Clear canvas with fade effect\r\n    ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';\r\n    ctx.fillRect(0, 0, canvasRef.current.width, canvasRef.current.height);\r\n    \r\n    // Update and draw particles\r\n    for (let i = 0; i < particleCount; i++) {\r\n      const particle = particlesRef.current[i];\r\n      \r\n      // Get audio data for this particle\r\n      const dataIndex = Math.floor((i / particleCount) * bufferLength);\r\n      const audioValue = dataArray[dataIndex] / 256.0 * reactivity;\r\n      \r\n      // Update position\r\n      particle.x += particle.speedX * speed;\r\n      particle.y += particle.speedY * speed;\r\n      \r\n      // Apply audio reactivity\r\n      particle.size = particleSize * (1 + audioValue);\r\n      \r\n      // Wrap around edges\r\n      if (particle.x < 0) particle.x = canvasRef.current.width;\r\n      if (particle.x > canvasRef.current.width) particle.x = 0;\r\n      if (particle.y < 0) particle.y = canvasRef.current.height;\r\n      if (particle.y > canvasRef.current.height) particle.y = 0;\r\n      \r\n      // Draw particle\r\n      ctx.beginPath();\r\n      ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);\r\n      \r\n      // Use color parameter with slight variation\r\n      const particleColor = adjustColor(color, (i % 20) - 10);\r\n      ctx.fillStyle = particleColor;\r\n      \r\n      ctx.fill();\r\n    }\r\n  };\r\n\r\n  // Helper function to adjust colors\r\n  const adjustColor = (hexColor, amount) => {\r\n    // Convert hex to RGB\r\n    let r = parseInt(hexColor.substring(1, 3), 16);\r\n    let g = parseInt(hexColor.substring(3, 5), 16);\r\n    let b = parseInt(hexColor.substring(5, 7), 16);\r\n    \r\n    // Adjust RGB values\r\n    r = Math.max(0, Math.min(255, r + amount));\r\n    g = Math.max(0, Math.min(255, g + amount));\r\n    b = Math.max(0, Math.min(255, b + amount));\r\n    \r\n    // Convert back to hex\r\n    return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;\r\n  };\r\n\r\n  // Start visualization\r\n  const startVisualization = () => {\r\n    if (!analyserRef.current || !canvasRef.current) return;\r\n    \r\n    const analyser = analyserRef.current;\r\n    const canvas = canvasRef.current;\r\n    const ctx = canvas.getContext('2d');\r\n    \r\n    // Create data arrays for audio analysis\r\n    const bufferLength = analyser.frequencyBinCount;\r\n    const dataArray = new Uint8Array(bufferLength);\r\n    const timeArray = new Uint8Array(bufferLength);\r\n    \r\n    // Get initial data\r\n    analyser.getByteFrequencyData(dataArray);\r\n    analyser.getByteTimeDomainData(timeArray);\r\n    \r\n    // Update audio data for 3D visualizer\r\n    setAudioData({ \r\n      dataArray: Array.from(dataArray), \r\n      timeArray: Array.from(timeArray), \r\n      bufferLength \r\n    });\r\n    \r\n    // Cancel any existing animation frame\r\n    if (animationFrameRef.current) {\r\n      cancelAnimationFrame(animationFrameRef.current);\r\n    }\r\n    \r\n    // Skip 2D visualization if using 3D\r\n    if (use3D) {\r\n      // For 3D, we need to continuously update the audio data\r\n      const update3DAudio = () => {\r\n        animationFrameRef.current = requestAnimationFrame(update3DAudio);\r\n        \r\n        // Get frequency and time domain data\r\n        analyser.getByteFrequencyData(dataArray);\r\n        analyser.getByteTimeDomainData(timeArray);\r\n        \r\n        // Update audio data for 3D visualizer\r\n        setAudioData({ \r\n          dataArray: Array.from(dataArray), \r\n          timeArray: Array.from(timeArray), \r\n          bufferLength \r\n        });\r\n      };\r\n      \r\n      update3DAudio();\r\n      return;\r\n    }\r\n    \r\n    // Animation function for 2D visualizations\r\n    const draw = () => {\r\n      animationFrameRef.current = requestAnimationFrame(draw);\r\n      \r\n      // Get frequency and time domain data\r\n      analyser.getByteFrequencyData(dataArray);\r\n      analyser.getByteTimeDomainData(timeArray);\r\n      \r\n      // Clear canvas\r\n      ctx.fillStyle = 'rgb(0, 0, 0)';\r\n      ctx.fillRect(0, 0, canvas.width, canvas.height);\r\n      \r\n      // Draw visualization based on template\r\n      switch (template) {\r\n        case 'waveform':\r\n          drawWaveform(ctx, dataArray, bufferLength);\r\n          break;\r\n        case 'bars':\r\n          drawBars(ctx, dataArray, bufferLength);\r\n          break;\r\n        case 'circles':\r\n          drawCircles(ctx, dataArray, bufferLength);\r\n          break;\r\n        case 'kaleidoscope':\r\n          drawKaleidoscope(ctx, dataArray, timeArray, bufferLength);\r\n          break;\r\n        case 'spiral':\r\n          drawSpiral(ctx, dataArray, timeArray, bufferLength);\r\n          break;\r\n        case 'particles':\r\n          updateAndDrawParticles(ctx, dataArray, bufferLength);\r\n          break;\r\n        default:\r\n          drawWaveform(ctx, dataArray, bufferLength);\r\n      }\r\n    };\r\n    \r\n    draw();\r\n  };\r\n\r\n  const drawWaveform = (ctx, dataArray, bufferLength) => {\r\n    // Apply parameters\r\n    const lineWidth = parameters.lineWidth || 3;\r\n    const color = parameters.color || '#00aaff';\r\n    const reactivity = (parameters.reactivity || 50) / 50; // Convert to 0-2 scale\r\n    const smoothing = (parameters.smoothing || 50) / 100; // Convert to 0-1 scale\r\n    \r\n    ctx.lineWidth = lineWidth;\r\n    ctx.strokeStyle = color;\r\n    ctx.beginPath();\r\n    \r\n    const sliceWidth = (canvasRef.current.width * 1.0) / bufferLength;\r\n    let x = 0;\r\n    \r\n    for (let i = 0; i < bufferLength; i++) {\r\n      const v = dataArray[i] / 128.0 * reactivity;\r\n      const y = v * canvasRef.current.height / 2;\r\n      \r\n      if (i === 0) {\r\n        ctx.moveTo(x, y);\r\n      } else {\r\n        // Apply smoothing if enabled\r\n        if (smoothing > 0) {\r\n          const prevX = x - sliceWidth;\r\n          const prevY = dataArray[i - 1] / 128.0 * reactivity * canvasRef.current.height / 2;\r\n          const cpX1 = prevX + sliceWidth / 3;\r\n          const cpX2 = x - sliceWidth / 3;\r\n          const cpY1 = prevY;\r\n          const cpY2 = y;\r\n          \r\n          // Use bezier curve for smoothing\r\n          ctx.bezierCurveTo(cpX1, cpY1, cpX2, cpY2, x, y);\r\n        } else {\r\n          ctx.lineTo(x, y);\r\n        }\r\n      }\r\n      \r\n      x += sliceWidth;\r\n    }\r\n    \r\n    ctx.lineTo(canvasRef.current.width, canvasRef.current.height / 2);\r\n    ctx.stroke();\r\n  };\r\n\r\n  const drawBars = (ctx, dataArray, bufferLength) => {\r\n    // Apply parameters\r\n    const color = parameters.color || '#ff5500';\r\n    const barWidth = (parameters.barWidth || 50) / 100; // Convert to 0-1 scale\r\n    const spacing = (parameters.spacing || 30) / 100; // Convert to 0-1 scale\r\n    const reactivity = (parameters.reactivity || 50) / 25; // Convert to 0-4 scale\r\n    \r\n    const bars = Math.min(bufferLength, 256);\r\n    const width = canvasRef.current.width / bars;\r\n    const actualBarWidth = width * barWidth;\r\n    const barSpacing = width * spacing;\r\n    \r\n    for (let i = 0; i < bars; i++) {\r\n      const barHeight = dataArray[i] * reactivity;\r\n      \r\n      // Create gradient for each bar\r\n      const gradient = ctx.createLinearGradient(0, canvasRef.current.height, 0, canvasRef.current.height - barHeight);\r\n      gradient.addColorStop(0, color);\r\n      gradient.addColorStop(1, adjustColor(color, 30)); // Lighter at the top\r\n      \r\n      ctx.fillStyle = gradient;\r\n      ctx.fillRect(i * width + barSpacing/2, canvasRef.current.height - barHeight, actualBarWidth, barHeight);\r\n    }\r\n  };\r\n\r\n  const drawCircles = (ctx, dataArray, bufferLength) => {\r\n    // Apply parameters\r\n    const color = parameters.color || '#ff00ff';\r\n    const baseRadius = (parameters.radius || 50) / 100 * Math.min(canvasRef.current.width, canvasRef.current.height) / 2;\r\n    const circleCount = Math.max(1, Math.min(20, Math.floor((parameters.count || 50) / 5))); // 1-20 circles\r\n    const reactivity = (parameters.reactivity || 50) / 50; // Convert to 0-2 scale\r\n    \r\n    const centerX = canvasRef.current.width / 2;\r\n    const centerY = canvasRef.current.height / 2;\r\n    \r\n    for (let i = 0; i < circleCount; i++) {\r\n      const radius = baseRadius * (i + 1) / circleCount;\r\n      \r\n      ctx.beginPath();\r\n      ctx.strokeStyle = adjustColor(color, i * 5); // Slightly different color for each circle\r\n      \r\n      // Draw circle with audio-reactive distortion\r\n      for (let j = 0; j < 360; j += 5) {\r\n        const angleRad = j * Math.PI / 180;\r\n        const dataIndex = Math.floor(j / 360 * bufferLength);\r\n        const distortion = dataArray[dataIndex] / 128.0 * reactivity;\r\n        \r\n        const x = centerX + Math.cos(angleRad) * radius * distortion;\r\n        const y = centerY + Math.sin(angleRad) * radius * distortion;\r\n        \r\n        if (j === 0) {\r\n          ctx.moveTo(x, y);\r\n        } else {\r\n          ctx.lineTo(x, y);\r\n        }\r\n      }\r\n      \r\n      ctx.closePath();\r\n      ctx.stroke();\r\n    }\r\n  };\r\n\r\n  const drawKaleidoscope = (ctx, dataArray, timeArray, bufferLength) => {\r\n    // Apply parameters\r\n    const color = parameters.color || '#ffaa00';\r\n    const segments = parameters.segments || 8;\r\n    const speed = (parameters.speed || 50) / 1000; // Convert to 0-0.05 scale\r\n    const reactivity = (parameters.reactivity || 50) / 50; // Convert to 0-2 scale\r\n    \r\n    const centerX = canvasRef.current.width / 2;\r\n    const centerY = canvasRef.current.height / 2;\r\n    const radius = Math.min(centerX, centerY) * 0.8;\r\n    \r\n    // Rotate based on time and speed\r\n    ctx.translate(centerX, centerY);\r\n    ctx.rotate(timeRef.current * speed);\r\n    \r\n    // Draw kaleidoscope segments\r\n    for (let s = 0; s < segments; s++) {\r\n      ctx.rotate(Math.PI * 2 / segments);\r\n      \r\n      ctx.beginPath();\r\n      ctx.strokeStyle = adjustColor(color, s * 5);\r\n      \r\n      // Draw audio-reactive pattern\r\n      for (let i = 0; i < bufferLength; i += 8) {\r\n        const x = (dataArray[i] / 256.0) * radius * reactivity;\r\n        const y = (timeArray[i] / 256.0) * radius * reactivity;\r\n        \r\n        if (i === 0) {\r\n          ctx.moveTo(x, y);\r\n        } else {\r\n          ctx.lineTo(x, y);\r\n        }\r\n      }\r\n      \r\n      ctx.stroke();\r\n    }\r\n    \r\n    // Reset transformation\r\n    ctx.setTransform(1, 0, 0, 1, 0, 0);\r\n  };\r\n\r\n  const drawSpiral = (ctx, dataArray, timeArray, bufferLength) => {\r\n    // Apply parameters\r\n    const color = parameters.color || '#00ff99';\r\n    const arms = parameters.arms || 5;\r\n    const speed = (parameters.speed || 50) / 1000; // Convert to 0-0.05 scale\r\n    const reactivity = (parameters.reactivity || 50) / 50; // Convert to 0-2 scale\r\n    \r\n    const centerX = canvasRef.current.width / 2;\r\n    const centerY = canvasRef.current.height / 2;\r\n    const maxRadius = Math.min(centerX, centerY) * 0.9;\r\n    \r\n    // Rotate based on time and speed\r\n    ctx.translate(centerX, centerY);\r\n    ctx.rotate(timeRef.current * speed);\r\n    \r\n    // Draw spiral arms\r\n    for (let a = 0; a < arms; a++) {\r\n      const armAngle = (a / arms) * Math.PI * 2;\r\n      const hue = (a / arms) * 360;\r\n      \r\n      ctx.beginPath();\r\n      ctx.strokeStyle = adjustColor(color, a * 10);\r\n      \r\n      for (let i = 0; i < 100; i++) {\r\n        const t = i / 100;\r\n        const angle = armAngle + t * Math.PI * 6;\r\n        const radius = t * maxRadius;\r\n        \r\n        // Apply audio reactivity\r\n        const dataIndex = Math.floor(t * bufferLength);\r\n        const audioValue = dataArray[dataIndex] / 128.0 * reactivity;\r\n        \r\n        const x = Math.cos(angle) * radius * audioValue;\r\n        const y = Math.sin(angle) * radius * audioValue;\r\n        \r\n        if (i === 0) {\r\n          ctx.moveTo(x, y);\r\n        } else {\r\n          ctx.lineTo(x, y);\r\n        }\r\n      }\r\n      \r\n      ctx.stroke();\r\n    }\r\n    \r\n    // Reset transformation\r\n    ctx.setTransform(1, 0, 0, 1, 0, 0);\r\n  };\r\n\r\n  // Add a function to update parameters\r\n  const updateParameters = (newParameters) => {\r\n    console.log(\"Updating visualization parameters:\", newParameters);\r\n    // Parameters will be applied in the visualization functions\r\n  };\r\n\r\n  return (\r\n    <div className=\"visualizer-container\">\r\n      <div \r\n        ref={containerRef}\r\n        className={`visualizer-aspect-container ${RESOLUTIONS[resolution].className}`}\r\n      >\r\n        {use3D ? (\r\n          <ThreeVisualizer \r\n            audioData={audioData}\r\n            template={template.replace('3d', '')} // Remove '3d' suffix for the ThreeVisualizer\r\n            isPlaying={isPlaying}\r\n          />\r\n        ) : (\r\n          <canvas ref={canvasRef} className=\"visualizer-canvas\"></canvas>\r\n        )}\r\n        <div className=\"visualizer-overlay\"></div>\r\n        <div className=\"resolution-indicator\">{resolution} ({RESOLUTIONS[resolution].width}×{RESOLUTIONS[resolution].height})</div>\r\n      </div>\r\n    </div>\r\n  );\r\n});\r\n\r\nexport default Visualizer; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}