{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\fkuce\\\\OneDrive\\\\Desktop\\\\Money Projects\\\\Visualizer\\\\frontend\\\\src\\\\components\\\\VideoExporter.js\",\n  _s = $RefreshSig$();\nimport React, { useRef, useState, useEffect } from 'react';\nimport './VideoExporter.css';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst VideoExporter = ({\n  visualizerRef,\n  audioFile,\n  isPlaying\n}) => {\n  _s();\n  const [isExporting, setIsExporting] = useState(false);\n  const [progress, setProgress] = useState(0);\n  const mediaRecorderRef = useRef(null);\n  const chunksRef = useRef([]);\n  const startTimeRef = useRef(null);\n  const audioDurationRef = useRef(null);\n  const progressIntervalRef = useRef(null);\n\n  // Get audio duration when audio file changes\n  useEffect(() => {\n    if (audioFile) {\n      // Use the same URL format as in Visualizer component\n      const timestamp = new Date().getTime();\n      const audioUrl = `http://localhost:5001${audioFile.path}?t=${timestamp}`;\n      const audio = new Audio(audioUrl);\n      audio.addEventListener('loadedmetadata', () => {\n        audioDurationRef.current = audio.duration;\n      });\n\n      // Add error handling\n      audio.addEventListener('error', e => {\n        console.error('Error loading audio for duration calculation:', e);\n      });\n    }\n    return () => {\n      if (progressIntervalRef.current) {\n        clearInterval(progressIntervalRef.current);\n      }\n    };\n  }, [audioFile]);\n  const exportVideo = async () => {\n    if (!(visualizerRef !== null && visualizerRef !== void 0 && visualizerRef.current) || !audioFile) {\n      alert(\"Please upload an audio file first\");\n      return;\n    }\n    try {\n      setIsExporting(true);\n      setProgress(0);\n      startTimeRef.current = Date.now();\n\n      // Get the canvas element from the visualizer using the exposed method\n      const canvas = visualizerRef.current.getCanvas();\n      if (!canvas) {\n        throw new Error(\"Canvas element not found\");\n      }\n\n      // Create a stream from the canvas\n      let stream;\n      try {\n        // Try standard method first\n        stream = canvas.captureStream(30);\n      } catch (e) {\n        // Fallback for Firefox\n        stream = canvas.mozCaptureStream ? canvas.mozCaptureStream(30) : null;\n      }\n      if (!stream) {\n        throw new Error(\"Your browser doesn't support canvas streaming\");\n      }\n\n      // Create audio context and connect to stream\n      const audioContext = new (window.AudioContext || window.webkitAudioContext)();\n\n      // Use the same URL format as in Visualizer component\n      const timestamp = new Date().getTime();\n      const audioUrl = `http://localhost:5001${audioFile.path}?t=${timestamp}`;\n      const audioElement = new Audio(audioUrl);\n\n      // Add error handling for audio element\n      audioElement.addEventListener('error', e => {\n        console.error('Audio element error:', e);\n        throw new Error(`Failed to load audio: ${e.message}`);\n      });\n\n      // Wait for audio to be loadable before proceeding\n      await new Promise((resolve, reject) => {\n        audioElement.addEventListener('canplaythrough', resolve, {\n          once: true\n        });\n        audioElement.addEventListener('error', e => reject(new Error(`Audio load error: ${e.message}`)), {\n          once: true\n        });\n        audioElement.load();\n      });\n      const audioSource = audioContext.createMediaElementSource(audioElement);\n      const audioDestination = audioContext.createMediaStreamDestination();\n      audioSource.connect(audioDestination);\n      audioSource.connect(audioContext.destination); // Also connect to speakers\n\n      // Combine video and audio streams\n      const combinedStream = new MediaStream([...stream.getVideoTracks(), ...audioDestination.stream.getAudioTracks()]);\n\n      // Create media recorder with appropriate MIME type\n      let mimeType = 'video/webm;codecs=vp9,opus';\n      if (!MediaRecorder.isTypeSupported(mimeType)) {\n        // Fallback to more compatible options\n        if (MediaRecorder.isTypeSupported('video/webm;codecs=vp8,opus')) {\n          mimeType = 'video/webm;codecs=vp8,opus';\n        } else if (MediaRecorder.isTypeSupported('video/webm')) {\n          mimeType = 'video/webm';\n        }\n      }\n      const mediaRecorder = new MediaRecorder(combinedStream, {\n        mimeType\n      });\n      mediaRecorderRef.current = mediaRecorder;\n      chunksRef.current = [];\n\n      // Handle data available\n      mediaRecorder.ondataavailable = event => {\n        if (event.data.size > 0) {\n          chunksRef.current.push(event.data);\n        }\n      };\n\n      // Handle recording stop\n      mediaRecorder.onstop = () => {\n        const blob = new Blob(chunksRef.current, {\n          type: mimeType\n        });\n        const url = URL.createObjectURL(blob);\n\n        // Create filename based on audio file name\n        const fileName = audioFile.name.replace(/\\.[^/.]+$/, \"\") + \"_visualization.webm\";\n\n        // Download the file\n        const a = document.createElement('a');\n        a.href = url;\n        a.download = fileName;\n        a.click();\n\n        // Clean up\n        URL.revokeObjectURL(url);\n        setIsExporting(false);\n        setProgress(100);\n\n        // Clear progress interval\n        if (progressIntervalRef.current) {\n          clearInterval(progressIntervalRef.current);\n          progressIntervalRef.current = null;\n        }\n      };\n\n      // Start recording\n      mediaRecorder.start(1000); // Capture in 1-second chunks\n\n      // Start audio playback\n      try {\n        await audioElement.play();\n      } catch (playError) {\n        console.error('Error playing audio:', playError);\n        throw new Error(`Failed to play audio: ${playError.message}`);\n      }\n\n      // Update progress based on audio time\n      progressIntervalRef.current = setInterval(() => {\n        if (audioDurationRef.current) {\n          const elapsed = (Date.now() - startTimeRef.current) / 1000;\n          const percentage = Math.min(Math.floor(elapsed / audioDurationRef.current * 100), 99);\n          setProgress(percentage);\n        }\n      }, 500);\n\n      // Stop recording when audio ends\n      audioElement.onended = () => {\n        if (mediaRecorderRef.current && mediaRecorderRef.current.state === 'recording') {\n          mediaRecorderRef.current.stop();\n          audioElement.onended = null;\n        }\n      };\n    } catch (error) {\n      console.error(\"Error exporting video:\", error);\n      alert(`Error exporting video: ${error.message}`);\n      setIsExporting(false);\n    }\n  };\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"video-exporter\",\n    children: isExporting ? /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"export-progress\",\n      children: [/*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"progress-bar\",\n        children: /*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"progress-fill\",\n          style: {\n            width: `${progress}%`\n          }\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 188,\n          columnNumber: 13\n        }, this)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 187,\n        columnNumber: 11\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"progress-text\",\n        children: [progress, \"% Exporting...\"]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 190,\n        columnNumber: 11\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 186,\n      columnNumber: 9\n    }, this) : /*#__PURE__*/_jsxDEV(\"button\", {\n      className: \"export-button\",\n      onClick: exportVideo,\n      disabled: !visualizerRef || !audioFile || isPlaying,\n      children: \"Export Video\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 193,\n      columnNumber: 9\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 184,\n    columnNumber: 5\n  }, this);\n};\n_s(VideoExporter, \"faWanLLAELGD5wrrjZkWWPoOFGw=\");\n_c = VideoExporter;\nexport default VideoExporter;\nvar _c;\n$RefreshReg$(_c, \"VideoExporter\");","map":{"version":3,"names":["React","useRef","useState","useEffect","jsxDEV","_jsxDEV","VideoExporter","visualizerRef","audioFile","isPlaying","_s","isExporting","setIsExporting","progress","setProgress","mediaRecorderRef","chunksRef","startTimeRef","audioDurationRef","progressIntervalRef","timestamp","Date","getTime","audioUrl","path","audio","Audio","addEventListener","current","duration","e","console","error","clearInterval","exportVideo","alert","now","canvas","getCanvas","Error","stream","captureStream","mozCaptureStream","audioContext","window","AudioContext","webkitAudioContext","audioElement","message","Promise","resolve","reject","once","load","audioSource","createMediaElementSource","audioDestination","createMediaStreamDestination","connect","destination","combinedStream","MediaStream","getVideoTracks","getAudioTracks","mimeType","MediaRecorder","isTypeSupported","mediaRecorder","ondataavailable","event","data","size","push","onstop","blob","Blob","type","url","URL","createObjectURL","fileName","name","replace","a","document","createElement","href","download","click","revokeObjectURL","start","play","playError","setInterval","elapsed","percentage","Math","min","floor","onended","state","stop","className","children","style","width","_jsxFileName","lineNumber","columnNumber","onClick","disabled","_c","$RefreshReg$"],"sources":["C:/Users/fkuce/OneDrive/Desktop/Money Projects/Visualizer/frontend/src/components/VideoExporter.js"],"sourcesContent":["import React, { useRef, useState, useEffect } from 'react';\r\nimport './VideoExporter.css';\r\n\r\nconst VideoExporter = ({ visualizerRef, audioFile, isPlaying }) => {\r\n  const [isExporting, setIsExporting] = useState(false);\r\n  const [progress, setProgress] = useState(0);\r\n  const mediaRecorderRef = useRef(null);\r\n  const chunksRef = useRef([]);\r\n  const startTimeRef = useRef(null);\r\n  const audioDurationRef = useRef(null);\r\n  const progressIntervalRef = useRef(null);\r\n\r\n  // Get audio duration when audio file changes\r\n  useEffect(() => {\r\n    if (audioFile) {\r\n      // Use the same URL format as in Visualizer component\r\n      const timestamp = new Date().getTime();\r\n      const audioUrl = `http://localhost:5001${audioFile.path}?t=${timestamp}`;\r\n      const audio = new Audio(audioUrl);\r\n      \r\n      audio.addEventListener('loadedmetadata', () => {\r\n        audioDurationRef.current = audio.duration;\r\n      });\r\n      \r\n      // Add error handling\r\n      audio.addEventListener('error', (e) => {\r\n        console.error('Error loading audio for duration calculation:', e);\r\n      });\r\n    }\r\n    return () => {\r\n      if (progressIntervalRef.current) {\r\n        clearInterval(progressIntervalRef.current);\r\n      }\r\n    };\r\n  }, [audioFile]);\r\n\r\n  const exportVideo = async () => {\r\n    if (!visualizerRef?.current || !audioFile) {\r\n      alert(\"Please upload an audio file first\");\r\n      return;\r\n    }\r\n\r\n    try {\r\n      setIsExporting(true);\r\n      setProgress(0);\r\n      startTimeRef.current = Date.now();\r\n\r\n      // Get the canvas element from the visualizer using the exposed method\r\n      const canvas = visualizerRef.current.getCanvas();\r\n      if (!canvas) {\r\n        throw new Error(\"Canvas element not found\");\r\n      }\r\n\r\n      // Create a stream from the canvas\r\n      let stream;\r\n      try {\r\n        // Try standard method first\r\n        stream = canvas.captureStream(30);\r\n      } catch (e) {\r\n        // Fallback for Firefox\r\n        stream = canvas.mozCaptureStream ? canvas.mozCaptureStream(30) : null;\r\n      }\r\n\r\n      if (!stream) {\r\n        throw new Error(\"Your browser doesn't support canvas streaming\");\r\n      }\r\n\r\n      // Create audio context and connect to stream\r\n      const audioContext = new (window.AudioContext || window.webkitAudioContext)();\r\n      \r\n      // Use the same URL format as in Visualizer component\r\n      const timestamp = new Date().getTime();\r\n      const audioUrl = `http://localhost:5001${audioFile.path}?t=${timestamp}`;\r\n      const audioElement = new Audio(audioUrl);\r\n      \r\n      // Add error handling for audio element\r\n      audioElement.addEventListener('error', (e) => {\r\n        console.error('Audio element error:', e);\r\n        throw new Error(`Failed to load audio: ${e.message}`);\r\n      });\r\n      \r\n      // Wait for audio to be loadable before proceeding\r\n      await new Promise((resolve, reject) => {\r\n        audioElement.addEventListener('canplaythrough', resolve, { once: true });\r\n        audioElement.addEventListener('error', (e) => reject(new Error(`Audio load error: ${e.message}`)), { once: true });\r\n        audioElement.load();\r\n      });\r\n      \r\n      const audioSource = audioContext.createMediaElementSource(audioElement);\r\n      const audioDestination = audioContext.createMediaStreamDestination();\r\n      audioSource.connect(audioDestination);\r\n      audioSource.connect(audioContext.destination); // Also connect to speakers\r\n\r\n      // Combine video and audio streams\r\n      const combinedStream = new MediaStream([\r\n        ...stream.getVideoTracks(),\r\n        ...audioDestination.stream.getAudioTracks()\r\n      ]);\r\n\r\n      // Create media recorder with appropriate MIME type\r\n      let mimeType = 'video/webm;codecs=vp9,opus';\r\n      if (!MediaRecorder.isTypeSupported(mimeType)) {\r\n        // Fallback to more compatible options\r\n        if (MediaRecorder.isTypeSupported('video/webm;codecs=vp8,opus')) {\r\n          mimeType = 'video/webm;codecs=vp8,opus';\r\n        } else if (MediaRecorder.isTypeSupported('video/webm')) {\r\n          mimeType = 'video/webm';\r\n        }\r\n      }\r\n      \r\n      const mediaRecorder = new MediaRecorder(combinedStream, { mimeType });\r\n      mediaRecorderRef.current = mediaRecorder;\r\n      chunksRef.current = [];\r\n\r\n      // Handle data available\r\n      mediaRecorder.ondataavailable = (event) => {\r\n        if (event.data.size > 0) {\r\n          chunksRef.current.push(event.data);\r\n        }\r\n      };\r\n\r\n      // Handle recording stop\r\n      mediaRecorder.onstop = () => {\r\n        const blob = new Blob(chunksRef.current, { type: mimeType });\r\n        const url = URL.createObjectURL(blob);\r\n        \r\n        // Create filename based on audio file name\r\n        const fileName = audioFile.name.replace(/\\.[^/.]+$/, \"\") + \"_visualization.webm\";\r\n        \r\n        // Download the file\r\n        const a = document.createElement('a');\r\n        a.href = url;\r\n        a.download = fileName;\r\n        a.click();\r\n        \r\n        // Clean up\r\n        URL.revokeObjectURL(url);\r\n        setIsExporting(false);\r\n        setProgress(100);\r\n        \r\n        // Clear progress interval\r\n        if (progressIntervalRef.current) {\r\n          clearInterval(progressIntervalRef.current);\r\n          progressIntervalRef.current = null;\r\n        }\r\n      };\r\n\r\n      // Start recording\r\n      mediaRecorder.start(1000); // Capture in 1-second chunks\r\n\r\n      // Start audio playback\r\n      try {\r\n        await audioElement.play();\r\n      } catch (playError) {\r\n        console.error('Error playing audio:', playError);\r\n        throw new Error(`Failed to play audio: ${playError.message}`);\r\n      }\r\n\r\n      // Update progress based on audio time\r\n      progressIntervalRef.current = setInterval(() => {\r\n        if (audioDurationRef.current) {\r\n          const elapsed = (Date.now() - startTimeRef.current) / 1000;\r\n          const percentage = Math.min(Math.floor((elapsed / audioDurationRef.current) * 100), 99);\r\n          setProgress(percentage);\r\n        }\r\n      }, 500);\r\n\r\n      // Stop recording when audio ends\r\n      audioElement.onended = () => {\r\n        if (mediaRecorderRef.current && mediaRecorderRef.current.state === 'recording') {\r\n          mediaRecorderRef.current.stop();\r\n          audioElement.onended = null;\r\n        }\r\n      };\r\n\r\n    } catch (error) {\r\n      console.error(\"Error exporting video:\", error);\r\n      alert(`Error exporting video: ${error.message}`);\r\n      setIsExporting(false);\r\n    }\r\n  };\r\n\r\n  return (\r\n    <div className=\"video-exporter\">\r\n      {isExporting ? (\r\n        <div className=\"export-progress\">\r\n          <div className=\"progress-bar\">\r\n            <div className=\"progress-fill\" style={{ width: `${progress}%` }}></div>\r\n          </div>\r\n          <div className=\"progress-text\">{progress}% Exporting...</div>\r\n        </div>\r\n      ) : (\r\n        <button\r\n          className=\"export-button\"\r\n          onClick={exportVideo}\r\n          disabled={!visualizerRef || !audioFile || isPlaying}\r\n        >\r\n          Export Video\r\n        </button>\r\n      )}\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default VideoExporter; "],"mappings":";;AAAA,OAAOA,KAAK,IAAIC,MAAM,EAAEC,QAAQ,EAAEC,SAAS,QAAQ,OAAO;AAC1D,OAAO,qBAAqB;AAAC,SAAAC,MAAA,IAAAC,OAAA;AAE7B,MAAMC,aAAa,GAAGA,CAAC;EAAEC,aAAa;EAAEC,SAAS;EAAEC;AAAU,CAAC,KAAK;EAAAC,EAAA;EACjE,MAAM,CAACC,WAAW,EAAEC,cAAc,CAAC,GAAGV,QAAQ,CAAC,KAAK,CAAC;EACrD,MAAM,CAACW,QAAQ,EAAEC,WAAW,CAAC,GAAGZ,QAAQ,CAAC,CAAC,CAAC;EAC3C,MAAMa,gBAAgB,GAAGd,MAAM,CAAC,IAAI,CAAC;EACrC,MAAMe,SAAS,GAAGf,MAAM,CAAC,EAAE,CAAC;EAC5B,MAAMgB,YAAY,GAAGhB,MAAM,CAAC,IAAI,CAAC;EACjC,MAAMiB,gBAAgB,GAAGjB,MAAM,CAAC,IAAI,CAAC;EACrC,MAAMkB,mBAAmB,GAAGlB,MAAM,CAAC,IAAI,CAAC;;EAExC;EACAE,SAAS,CAAC,MAAM;IACd,IAAIK,SAAS,EAAE;MACb;MACA,MAAMY,SAAS,GAAG,IAAIC,IAAI,CAAC,CAAC,CAACC,OAAO,CAAC,CAAC;MACtC,MAAMC,QAAQ,GAAG,wBAAwBf,SAAS,CAACgB,IAAI,MAAMJ,SAAS,EAAE;MACxE,MAAMK,KAAK,GAAG,IAAIC,KAAK,CAACH,QAAQ,CAAC;MAEjCE,KAAK,CAACE,gBAAgB,CAAC,gBAAgB,EAAE,MAAM;QAC7CT,gBAAgB,CAACU,OAAO,GAAGH,KAAK,CAACI,QAAQ;MAC3C,CAAC,CAAC;;MAEF;MACAJ,KAAK,CAACE,gBAAgB,CAAC,OAAO,EAAGG,CAAC,IAAK;QACrCC,OAAO,CAACC,KAAK,CAAC,+CAA+C,EAAEF,CAAC,CAAC;MACnE,CAAC,CAAC;IACJ;IACA,OAAO,MAAM;MACX,IAAIX,mBAAmB,CAACS,OAAO,EAAE;QAC/BK,aAAa,CAACd,mBAAmB,CAACS,OAAO,CAAC;MAC5C;IACF,CAAC;EACH,CAAC,EAAE,CAACpB,SAAS,CAAC,CAAC;EAEf,MAAM0B,WAAW,GAAG,MAAAA,CAAA,KAAY;IAC9B,IAAI,EAAC3B,aAAa,aAAbA,aAAa,eAAbA,aAAa,CAAEqB,OAAO,KAAI,CAACpB,SAAS,EAAE;MACzC2B,KAAK,CAAC,mCAAmC,CAAC;MAC1C;IACF;IAEA,IAAI;MACFvB,cAAc,CAAC,IAAI,CAAC;MACpBE,WAAW,CAAC,CAAC,CAAC;MACdG,YAAY,CAACW,OAAO,GAAGP,IAAI,CAACe,GAAG,CAAC,CAAC;;MAEjC;MACA,MAAMC,MAAM,GAAG9B,aAAa,CAACqB,OAAO,CAACU,SAAS,CAAC,CAAC;MAChD,IAAI,CAACD,MAAM,EAAE;QACX,MAAM,IAAIE,KAAK,CAAC,0BAA0B,CAAC;MAC7C;;MAEA;MACA,IAAIC,MAAM;MACV,IAAI;QACF;QACAA,MAAM,GAAGH,MAAM,CAACI,aAAa,CAAC,EAAE,CAAC;MACnC,CAAC,CAAC,OAAOX,CAAC,EAAE;QACV;QACAU,MAAM,GAAGH,MAAM,CAACK,gBAAgB,GAAGL,MAAM,CAACK,gBAAgB,CAAC,EAAE,CAAC,GAAG,IAAI;MACvE;MAEA,IAAI,CAACF,MAAM,EAAE;QACX,MAAM,IAAID,KAAK,CAAC,+CAA+C,CAAC;MAClE;;MAEA;MACA,MAAMI,YAAY,GAAG,KAAKC,MAAM,CAACC,YAAY,IAAID,MAAM,CAACE,kBAAkB,EAAE,CAAC;;MAE7E;MACA,MAAM1B,SAAS,GAAG,IAAIC,IAAI,CAAC,CAAC,CAACC,OAAO,CAAC,CAAC;MACtC,MAAMC,QAAQ,GAAG,wBAAwBf,SAAS,CAACgB,IAAI,MAAMJ,SAAS,EAAE;MACxE,MAAM2B,YAAY,GAAG,IAAIrB,KAAK,CAACH,QAAQ,CAAC;;MAExC;MACAwB,YAAY,CAACpB,gBAAgB,CAAC,OAAO,EAAGG,CAAC,IAAK;QAC5CC,OAAO,CAACC,KAAK,CAAC,sBAAsB,EAAEF,CAAC,CAAC;QACxC,MAAM,IAAIS,KAAK,CAAC,yBAAyBT,CAAC,CAACkB,OAAO,EAAE,CAAC;MACvD,CAAC,CAAC;;MAEF;MACA,MAAM,IAAIC,OAAO,CAAC,CAACC,OAAO,EAAEC,MAAM,KAAK;QACrCJ,YAAY,CAACpB,gBAAgB,CAAC,gBAAgB,EAAEuB,OAAO,EAAE;UAAEE,IAAI,EAAE;QAAK,CAAC,CAAC;QACxEL,YAAY,CAACpB,gBAAgB,CAAC,OAAO,EAAGG,CAAC,IAAKqB,MAAM,CAAC,IAAIZ,KAAK,CAAC,qBAAqBT,CAAC,CAACkB,OAAO,EAAE,CAAC,CAAC,EAAE;UAAEI,IAAI,EAAE;QAAK,CAAC,CAAC;QAClHL,YAAY,CAACM,IAAI,CAAC,CAAC;MACrB,CAAC,CAAC;MAEF,MAAMC,WAAW,GAAGX,YAAY,CAACY,wBAAwB,CAACR,YAAY,CAAC;MACvE,MAAMS,gBAAgB,GAAGb,YAAY,CAACc,4BAA4B,CAAC,CAAC;MACpEH,WAAW,CAACI,OAAO,CAACF,gBAAgB,CAAC;MACrCF,WAAW,CAACI,OAAO,CAACf,YAAY,CAACgB,WAAW,CAAC,CAAC,CAAC;;MAE/C;MACA,MAAMC,cAAc,GAAG,IAAIC,WAAW,CAAC,CACrC,GAAGrB,MAAM,CAACsB,cAAc,CAAC,CAAC,EAC1B,GAAGN,gBAAgB,CAAChB,MAAM,CAACuB,cAAc,CAAC,CAAC,CAC5C,CAAC;;MAEF;MACA,IAAIC,QAAQ,GAAG,4BAA4B;MAC3C,IAAI,CAACC,aAAa,CAACC,eAAe,CAACF,QAAQ,CAAC,EAAE;QAC5C;QACA,IAAIC,aAAa,CAACC,eAAe,CAAC,4BAA4B,CAAC,EAAE;UAC/DF,QAAQ,GAAG,4BAA4B;QACzC,CAAC,MAAM,IAAIC,aAAa,CAACC,eAAe,CAAC,YAAY,CAAC,EAAE;UACtDF,QAAQ,GAAG,YAAY;QACzB;MACF;MAEA,MAAMG,aAAa,GAAG,IAAIF,aAAa,CAACL,cAAc,EAAE;QAAEI;MAAS,CAAC,CAAC;MACrEjD,gBAAgB,CAACa,OAAO,GAAGuC,aAAa;MACxCnD,SAAS,CAACY,OAAO,GAAG,EAAE;;MAEtB;MACAuC,aAAa,CAACC,eAAe,GAAIC,KAAK,IAAK;QACzC,IAAIA,KAAK,CAACC,IAAI,CAACC,IAAI,GAAG,CAAC,EAAE;UACvBvD,SAAS,CAACY,OAAO,CAAC4C,IAAI,CAACH,KAAK,CAACC,IAAI,CAAC;QACpC;MACF,CAAC;;MAED;MACAH,aAAa,CAACM,MAAM,GAAG,MAAM;QAC3B,MAAMC,IAAI,GAAG,IAAIC,IAAI,CAAC3D,SAAS,CAACY,OAAO,EAAE;UAAEgD,IAAI,EAAEZ;QAAS,CAAC,CAAC;QAC5D,MAAMa,GAAG,GAAGC,GAAG,CAACC,eAAe,CAACL,IAAI,CAAC;;QAErC;QACA,MAAMM,QAAQ,GAAGxE,SAAS,CAACyE,IAAI,CAACC,OAAO,CAAC,WAAW,EAAE,EAAE,CAAC,GAAG,qBAAqB;;QAEhF;QACA,MAAMC,CAAC,GAAGC,QAAQ,CAACC,aAAa,CAAC,GAAG,CAAC;QACrCF,CAAC,CAACG,IAAI,GAAGT,GAAG;QACZM,CAAC,CAACI,QAAQ,GAAGP,QAAQ;QACrBG,CAAC,CAACK,KAAK,CAAC,CAAC;;QAET;QACAV,GAAG,CAACW,eAAe,CAACZ,GAAG,CAAC;QACxBjE,cAAc,CAAC,KAAK,CAAC;QACrBE,WAAW,CAAC,GAAG,CAAC;;QAEhB;QACA,IAAIK,mBAAmB,CAACS,OAAO,EAAE;UAC/BK,aAAa,CAACd,mBAAmB,CAACS,OAAO,CAAC;UAC1CT,mBAAmB,CAACS,OAAO,GAAG,IAAI;QACpC;MACF,CAAC;;MAED;MACAuC,aAAa,CAACuB,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC;;MAE3B;MACA,IAAI;QACF,MAAM3C,YAAY,CAAC4C,IAAI,CAAC,CAAC;MAC3B,CAAC,CAAC,OAAOC,SAAS,EAAE;QAClB7D,OAAO,CAACC,KAAK,CAAC,sBAAsB,EAAE4D,SAAS,CAAC;QAChD,MAAM,IAAIrD,KAAK,CAAC,yBAAyBqD,SAAS,CAAC5C,OAAO,EAAE,CAAC;MAC/D;;MAEA;MACA7B,mBAAmB,CAACS,OAAO,GAAGiE,WAAW,CAAC,MAAM;QAC9C,IAAI3E,gBAAgB,CAACU,OAAO,EAAE;UAC5B,MAAMkE,OAAO,GAAG,CAACzE,IAAI,CAACe,GAAG,CAAC,CAAC,GAAGnB,YAAY,CAACW,OAAO,IAAI,IAAI;UAC1D,MAAMmE,UAAU,GAAGC,IAAI,CAACC,GAAG,CAACD,IAAI,CAACE,KAAK,CAAEJ,OAAO,GAAG5E,gBAAgB,CAACU,OAAO,GAAI,GAAG,CAAC,EAAE,EAAE,CAAC;UACvFd,WAAW,CAACiF,UAAU,CAAC;QACzB;MACF,CAAC,EAAE,GAAG,CAAC;;MAEP;MACAhD,YAAY,CAACoD,OAAO,GAAG,MAAM;QAC3B,IAAIpF,gBAAgB,CAACa,OAAO,IAAIb,gBAAgB,CAACa,OAAO,CAACwE,KAAK,KAAK,WAAW,EAAE;UAC9ErF,gBAAgB,CAACa,OAAO,CAACyE,IAAI,CAAC,CAAC;UAC/BtD,YAAY,CAACoD,OAAO,GAAG,IAAI;QAC7B;MACF,CAAC;IAEH,CAAC,CAAC,OAAOnE,KAAK,EAAE;MACdD,OAAO,CAACC,KAAK,CAAC,wBAAwB,EAAEA,KAAK,CAAC;MAC9CG,KAAK,CAAC,0BAA0BH,KAAK,CAACgB,OAAO,EAAE,CAAC;MAChDpC,cAAc,CAAC,KAAK,CAAC;IACvB;EACF,CAAC;EAED,oBACEP,OAAA;IAAKiG,SAAS,EAAC,gBAAgB;IAAAC,QAAA,EAC5B5F,WAAW,gBACVN,OAAA;MAAKiG,SAAS,EAAC,iBAAiB;MAAAC,QAAA,gBAC9BlG,OAAA;QAAKiG,SAAS,EAAC,cAAc;QAAAC,QAAA,eAC3BlG,OAAA;UAAKiG,SAAS,EAAC,eAAe;UAACE,KAAK,EAAE;YAAEC,KAAK,EAAE,GAAG5F,QAAQ;UAAI;QAAE;UAAAmE,QAAA,EAAA0B,YAAA;UAAAC,UAAA;UAAAC,YAAA;QAAA,OAAM;MAAC;QAAA5B,QAAA,EAAA0B,YAAA;QAAAC,UAAA;QAAAC,YAAA;MAAA,OACpE,CAAC,eACNvG,OAAA;QAAKiG,SAAS,EAAC,eAAe;QAAAC,QAAA,GAAE1F,QAAQ,EAAC,gBAAc;MAAA;QAAAmE,QAAA,EAAA0B,YAAA;QAAAC,UAAA;QAAAC,YAAA;MAAA,OAAK,CAAC;IAAA;MAAA5B,QAAA,EAAA0B,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,OAC1D,CAAC,gBAENvG,OAAA;MACEiG,SAAS,EAAC,eAAe;MACzBO,OAAO,EAAE3E,WAAY;MACrB4E,QAAQ,EAAE,CAACvG,aAAa,IAAI,CAACC,SAAS,IAAIC,SAAU;MAAA8F,QAAA,EACrD;IAED;MAAAvB,QAAA,EAAA0B,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,OAAQ;EACT;IAAA5B,QAAA,EAAA0B,YAAA;IAAAC,UAAA;IAAAC,YAAA;EAAA,OACE,CAAC;AAEV,CAAC;AAAClG,EAAA,CAvMIJ,aAAa;AAAAyG,EAAA,GAAbzG,aAAa;AAyMnB,eAAeA,aAAa;AAAC,IAAAyG,EAAA;AAAAC,YAAA,CAAAD,EAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}