{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\fkuce\\\\OneDrive\\\\Desktop\\\\Money Projects\\\\Visualizer\\\\frontend\\\\src\\\\components\\\\ThreeVisualizer.js\",\n  _s = $RefreshSig$();\nimport React, { useEffect, useRef, useState } from 'react';\nimport * as THREE from 'three';\nimport { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst ThreeVisualizer = ({\n  audioData,\n  template,\n  isPlaying,\n  parameters: initialParameters = {}\n}) => {\n  _s();\n  const mountRef = useRef(null);\n  const sceneRef = useRef(null);\n  const cameraRef = useRef(null);\n  const rendererRef = useRef(null);\n  const animationFrameRef = useRef(null);\n  const particlesRef = useRef(null);\n  const waveformRef = useRef(null);\n  const timeRef = useRef(0);\n  const controlsRef = useRef(null);\n  const [isInitialized, setIsInitialized] = useState(false);\n  const [parameters, setParameters] = useState(initialParameters);\n  console.log(\"ThreeVisualizer rendering with template:\", template);\n  console.log(\"Audio data:\", audioData);\n  console.log(\"Is playing:\", isPlaying);\n  console.log(\"Parameters:\", parameters);\n\n  // Update parameters when initialParameters change\n  useEffect(() => {\n    console.log(\"ThreeVisualizer received updated parameters:\", initialParameters);\n    if (initialParameters && Object.keys(initialParameters).length > 0) {\n      setParameters(initialParameters);\n      // No need to restart animation - parameters will be picked up in next frame\n    }\n  }, [initialParameters]);\n\n  // Initialize Three.js scene\n  useEffect(() => {\n    if (!mountRef.current) return;\n    console.log(\"Initializing Three.js scene\");\n    try {\n      // Create scene\n      const scene = new THREE.Scene();\n      sceneRef.current = scene;\n\n      // Create camera\n      const camera = new THREE.PerspectiveCamera(75, mountRef.current.clientWidth / mountRef.current.clientHeight, 0.1, 1000);\n      camera.position.z = 5;\n      cameraRef.current = camera;\n\n      // Create renderer\n      const renderer = new THREE.WebGLRenderer({\n        antialias: true,\n        alpha: true\n      });\n      renderer.setSize(mountRef.current.clientWidth, mountRef.current.clientHeight);\n      renderer.setClearColor(0x000000, 1);\n      mountRef.current.appendChild(renderer.domElement);\n      rendererRef.current = renderer;\n\n      // Add class to canvas for easier selection\n      renderer.domElement.classList.add('three-canvas');\n\n      // Add orbit controls for user interaction\n      const controls = new OrbitControls(camera, renderer.domElement);\n      controls.enableDamping = true;\n      controls.dampingFactor = 0.05;\n      controls.rotateSpeed = 0.5;\n      controlsRef.current = controls;\n\n      // Add ambient light\n      const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);\n      scene.add(ambientLight);\n\n      // Add directional light\n      const directionalLight = new THREE.DirectionalLight(0xffffff, 1);\n      directionalLight.position.set(0, 1, 1);\n      scene.add(directionalLight);\n\n      // Handle window resize\n      const handleResize = () => {\n        if (!mountRef.current || !cameraRef.current || !rendererRef.current) return;\n        const width = mountRef.current.clientWidth;\n        const height = mountRef.current.clientHeight;\n        cameraRef.current.aspect = width / height;\n        cameraRef.current.updateProjectionMatrix();\n        rendererRef.current.setSize(width, height);\n      };\n      window.addEventListener('resize', handleResize);\n\n      // Initial render\n      renderer.render(scene, camera);\n      setIsInitialized(true);\n      console.log(\"Three.js scene initialized successfully\");\n\n      // Clean up\n      return () => {\n        console.log(\"Cleaning up Three.js scene\");\n        window.removeEventListener('resize', handleResize);\n        if (rendererRef.current && mountRef.current) {\n          try {\n            mountRef.current.removeChild(rendererRef.current.domElement);\n          } catch (error) {\n            console.error(\"Error removing renderer:\", error);\n          }\n        }\n        if (animationFrameRef.current) {\n          cancelAnimationFrame(animationFrameRef.current);\n        }\n\n        // Dispose of Three.js objects\n        if (particlesRef.current) {\n          try {\n            particlesRef.current.geometry.dispose();\n            particlesRef.current.material.dispose();\n            sceneRef.current.remove(particlesRef.current);\n          } catch (error) {\n            console.error(\"Error disposing particles:\", error);\n          }\n        }\n        if (waveformRef.current) {\n          try {\n            waveformRef.current.geometry.dispose();\n            waveformRef.current.material.dispose();\n            sceneRef.current.remove(waveformRef.current);\n          } catch (error) {\n            console.error(\"Error disposing waveform:\", error);\n          }\n        }\n        setIsInitialized(false);\n      };\n    } catch (error) {\n      console.error(\"Error initializing Three.js:\", error);\n    }\n  }, []);\n\n  // Create or update visualization based on template\n  useEffect(() => {\n    if (!isInitialized || !sceneRef.current) {\n      console.log(\"Scene not initialized yet, skipping visualization creation\");\n      return;\n    }\n    console.log(\"Creating visualization for template:\", template);\n    try {\n      // Clear previous visualizations\n      if (particlesRef.current) {\n        particlesRef.current.geometry.dispose();\n        particlesRef.current.material.dispose();\n        sceneRef.current.remove(particlesRef.current);\n        particlesRef.current = null;\n      }\n      if (waveformRef.current) {\n        waveformRef.current.geometry.dispose();\n        waveformRef.current.material.dispose();\n        sceneRef.current.remove(waveformRef.current);\n        waveformRef.current = null;\n      }\n\n      // Create new visualization based on template\n      switch (template) {\n        case 'particles':\n          createParticleSystem();\n          break;\n        case 'waveform':\n          createWaveform();\n          break;\n        case 'spiral':\n          createSpiral();\n          break;\n        case 'kaleidoscope':\n          createKaleidoscope();\n          break;\n        default:\n          console.log(\"Unknown template, defaulting to particles\");\n          createParticleSystem();\n      }\n      console.log(\"Visualization created successfully\");\n\n      // Start animation if playing\n      if (isPlaying) {\n        animate();\n      }\n    } catch (error) {\n      console.error(\"Error creating visualization:\", error);\n    }\n  }, [template, isInitialized]);\n\n  // Handle play/pause\n  useEffect(() => {\n    console.log(\"Play state changed:\", isPlaying);\n    if (!isInitialized) {\n      console.log(\"Scene not initialized yet, skipping animation\");\n      return;\n    }\n    if (isPlaying) {\n      console.log(\"Starting animation\");\n      animate();\n    } else if (animationFrameRef.current) {\n      console.log(\"Stopping animation\");\n      cancelAnimationFrame(animationFrameRef.current);\n    }\n  }, [isPlaying, isInitialized]);\n\n  // Create particle system visualization\n  const createParticleSystem = () => {\n    console.log(\"Creating particle system\");\n    try {\n      // Use count parameter to determine particle count\n      const particleCount = Math.floor((parameters.count || 50) / 50 * 5000);\n      const particles = new THREE.BufferGeometry();\n      const positions = new Float32Array(particleCount * 3);\n      const colors = new Float32Array(particleCount * 3);\n      const sizes = new Float32Array(particleCount);\n\n      // Use color from parameters\n      const baseColor = parameters.color ? new THREE.Color(parameters.color) : new THREE.Color(0xffffff);\n      for (let i = 0; i < particleCount; i++) {\n        // Position particles in a sphere\n        const radius = 3 + Math.random() * 2;\n        const theta = Math.random() * Math.PI * 2;\n        const phi = Math.acos(2 * Math.random() - 1);\n        positions[i * 3] = radius * Math.sin(phi) * Math.cos(theta);\n        positions[i * 3 + 1] = radius * Math.sin(phi) * Math.sin(theta);\n        positions[i * 3 + 2] = radius * Math.cos(phi);\n\n        // Random colors based on parameter color\n        const color = baseColor.clone().offsetHSL((Math.random() - 0.5) * 0.2, 0, (Math.random() - 0.5) * 0.3);\n        colors[i * 3] = color.r;\n        colors[i * 3 + 1] = color.g;\n        colors[i * 3 + 2] = color.b;\n\n        // Random sizes based on size parameter\n        sizes[i] = (Math.random() * 0.5 + 0.5) * ((parameters.size || 50) / 25);\n      }\n      particles.setAttribute('position', new THREE.BufferAttribute(positions, 3));\n      particles.setAttribute('color', new THREE.BufferAttribute(colors, 3));\n      particles.setAttribute('size', new THREE.BufferAttribute(sizes, 1));\n\n      // Use simpler material for better compatibility\n      const particleMaterial = new THREE.PointsMaterial({\n        size: 0.1,\n        vertexColors: true,\n        transparent: true,\n        opacity: 0.8,\n        blending: THREE.AdditiveBlending\n      });\n      const particleSystem = new THREE.Points(particles, particleMaterial);\n\n      // Store parameters for animation\n      particleSystem.userData.rotationSpeed = {\n        x: 0.001 * ((parameters.speed || 50) / 50),\n        y: 0.002 * ((parameters.speed || 50) / 50)\n      };\n      particleSystem.userData.reactivity = (parameters.reactivity || 50) / 50;\n      sceneRef.current.add(particleSystem);\n      particlesRef.current = particleSystem;\n      console.log(\"Particle system created successfully\");\n    } catch (error) {\n      console.error(\"Error creating particle system:\", error);\n    }\n  };\n\n  // Create waveform visualization\n  const createWaveform = () => {\n    console.log(\"Creating waveform\");\n    try {\n      const geometry = new THREE.BufferGeometry();\n      const vertices = new Float32Array(128 * 3);\n      const colors = new Float32Array(128 * 3);\n\n      // Use color from parameters\n      const baseColor = parameters.color ? new THREE.Color(parameters.color) : new THREE.Color(0x00aaff);\n      for (let i = 0; i < 128; i++) {\n        const x = i / 128 * 10 - 5;\n        vertices[i * 3] = x;\n        vertices[i * 3 + 1] = 0;\n        vertices[i * 3 + 2] = 0;\n\n        // Color gradient based on parameter color\n        const hue = i / 128;\n        const color = baseColor.clone().offsetHSL(hue * 0.3, 0, 0); // Slight hue variation\n        colors[i * 3] = color.r;\n        colors[i * 3 + 1] = color.g;\n        colors[i * 3 + 2] = color.b;\n      }\n      geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));\n      geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));\n      const material = new THREE.LineBasicMaterial({\n        vertexColors: true,\n        linewidth: parameters.lineWidth || 2\n      });\n      const waveform = new THREE.Line(geometry, material);\n\n      // Store reactivity for animation\n      waveform.userData.reactivity = (parameters.reactivity || 50) / 50;\n\n      // Store height parameter\n      waveform.userData.height = (parameters.height || 50) / 50;\n      sceneRef.current.add(waveform);\n      waveformRef.current = waveform;\n      console.log(\"Waveform created successfully\");\n    } catch (error) {\n      console.error(\"Error creating waveform:\", error);\n    }\n  };\n\n  // Create spiral visualization\n  const createSpiral = () => {\n    console.log(\"Creating spiral\");\n    try {\n      const geometry = new THREE.BufferGeometry();\n      const armCount = parameters.arms || 5;\n      const pointsPerArm = 400;\n      const totalPoints = armCount * pointsPerArm;\n      const vertices = new Float32Array(totalPoints * 3);\n      const colors = new Float32Array(totalPoints * 3);\n\n      // Use color from parameters\n      const baseColor = parameters.color ? new THREE.Color(parameters.color) : new THREE.Color(0x00ff99);\n\n      // Create spiral with multiple arms\n      for (let arm = 0; arm < armCount; arm++) {\n        const armAngle = arm / armCount * Math.PI * 2;\n        for (let i = 0; i < pointsPerArm; i++) {\n          const index = (arm * pointsPerArm + i) * 3;\n          const t = i / pointsPerArm;\n          const angle = armAngle + t * Math.PI * 20;\n          const radius = t * 5;\n          vertices[index] = Math.cos(angle) * radius;\n          vertices[index + 1] = Math.sin(angle) * radius;\n          vertices[index + 2] = t * 2 - 1;\n\n          // Color gradient based on parameter color\n          const color = baseColor.clone().offsetHSL(t * 0.5, 0, 0); // Hue variation along spiral\n          colors[index] = color.r;\n          colors[index + 1] = color.g;\n          colors[index + 2] = color.b;\n        }\n      }\n      geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));\n      geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));\n      const material = new THREE.PointsMaterial({\n        size: 0.1,\n        vertexColors: true,\n        transparent: true,\n        opacity: 0.8,\n        blending: THREE.AdditiveBlending\n      });\n      const spiral = new THREE.Points(geometry, material);\n\n      // Store parameters for animation\n      spiral.userData.rotationSpeed = 0.005 * ((parameters.speed || 50) / 50);\n      spiral.userData.reactivity = (parameters.reactivity || 50) / 50;\n\n      // Apply radius parameter\n      const scale = (parameters.radius || 50) / 50;\n      spiral.scale.set(scale, scale, scale);\n      sceneRef.current.add(spiral);\n      particlesRef.current = spiral;\n      console.log(\"Spiral created successfully\");\n    } catch (error) {\n      console.error(\"Error creating spiral:\", error);\n    }\n  };\n\n  // Create kaleidoscope visualization\n  const createKaleidoscope = () => {\n    console.log(\"Creating kaleidoscope\");\n    try {\n      // Create a simpler geometry for better compatibility\n      const geometry = new THREE.IcosahedronGeometry(2, 2);\n\n      // Use MeshPhongMaterial for better color control\n      const material = new THREE.MeshPhongMaterial({\n        color: parameters.color || 0xffffff,\n        wireframe: true,\n        emissive: parameters.color ? new THREE.Color(parameters.color).multiplyScalar(0.5) : 0x444444,\n        specular: 0xffffff,\n        shininess: 100\n      });\n      const kaleidoscope = new THREE.Mesh(geometry, material);\n\n      // Store base scale for reactivity\n      kaleidoscope.userData.baseScale = 0.5 + (parameters.complexity || 50) / 100;\n      kaleidoscope.scale.set(kaleidoscope.userData.baseScale, kaleidoscope.userData.baseScale, kaleidoscope.userData.baseScale);\n\n      // Store rotation speed\n      kaleidoscope.userData.rotationSpeed = {\n        x: 0.005 * ((parameters.speed || 50) / 50),\n        y: 0.01 * ((parameters.speed || 50) / 50)\n      };\n      sceneRef.current.add(kaleidoscope);\n      particlesRef.current = kaleidoscope;\n      console.log(\"Kaleidoscope created successfully\");\n    } catch (error) {\n      console.error(\"Error creating kaleidoscope:\", error);\n    }\n  };\n\n  // Apply parameters to the visualizations\n  useEffect(() => {\n    if (!isInitialized || !sceneRef.current || !particlesRef.current) return;\n    console.log(\"Applying parameters to 3D visualization:\", parameters);\n    try {\n      // Apply common parameters\n      const reactivity = (parameters.reactivity || 50) / 50; // Convert to 0-2 scale\n      const speed = (parameters.speed || 50) / 50; // Convert to 0-2 scale\n\n      // Apply color if available\n      if (parameters.color && particlesRef.current.material) {\n        // Convert hex color to THREE.Color\n        const color = new THREE.Color(parameters.color);\n\n        // Apply color based on material type\n        if (particlesRef.current.material.color) {\n          particlesRef.current.material.color.set(color);\n        } else if (particlesRef.current.material.emissive) {\n          particlesRef.current.material.emissive.set(color);\n        }\n      }\n\n      // Apply template-specific parameters\n      switch (template) {\n        case 'particles':\n          // Apply particle count\n          if (parameters.count && particlesRef.current.geometry.attributes.size) {\n            // Can't change particle count dynamically, but we can hide some\n            const count = Math.floor(parameters.count / 100 * particlesRef.current.geometry.attributes.position.count);\n            const sizes = particlesRef.current.geometry.attributes.size.array;\n            for (let i = 0; i < sizes.length; i++) {\n              sizes[i] = i < count ? (parameters.size || 50) / 5 : 0;\n            }\n            particlesRef.current.geometry.attributes.size.needsUpdate = true;\n          }\n\n          // Apply size\n          if (parameters.size && particlesRef.current.geometry.attributes.size) {\n            const sizes = particlesRef.current.geometry.attributes.size.array;\n            const count = Math.floor((parameters.count || 50) / 100 * sizes.length);\n            for (let i = 0; i < count; i++) {\n              sizes[i] = (Math.random() * 0.5 + 0.5) * (parameters.size / 25);\n            }\n            particlesRef.current.geometry.attributes.size.needsUpdate = true;\n          }\n          break;\n        case 'kaleidoscope':\n          // Apply complexity\n          if (parameters.complexity && particlesRef.current.geometry) {\n            // Can't change geometry complexity dynamically, but we can scale it\n            const scale = 0.5 + parameters.complexity / 100;\n            particlesRef.current.userData.baseScale = scale;\n            particlesRef.current.scale.set(scale, scale, scale);\n          }\n          break;\n        case 'spiral':\n          // Apply arms count\n          if (parameters.arms && particlesRef.current.geometry) {\n            // Can't change arms dynamically, but we can adjust rotation speed\n            const rotationSpeed = 0.005 * (parameters.arms / 5);\n            particlesRef.current.userData.rotationSpeed = rotationSpeed;\n          }\n\n          // Apply radius\n          if (parameters.radius && particlesRef.current.geometry) {\n            const scale = parameters.radius / 50;\n            particlesRef.current.scale.set(scale, scale, scale);\n          }\n          break;\n        case 'waveform':\n          // Apply line width\n          if (parameters.lineWidth && particlesRef.current.material) {\n            particlesRef.current.material.linewidth = parameters.lineWidth;\n          }\n          break;\n      }\n\n      // Store reactivity and speed in userData for use in animation\n      particlesRef.current.userData.reactivity = reactivity;\n      particlesRef.current.userData.speed = speed;\n    } catch (error) {\n      console.error(\"Error applying parameters:\", error);\n    }\n  }, [parameters, template, isInitialized]);\n\n  // Animation loop\n  const animate = () => {\n    if (!sceneRef.current || !cameraRef.current || !rendererRef.current) {\n      console.log(\"Missing required refs for animation\");\n      return;\n    }\n    try {\n      animationFrameRef.current = requestAnimationFrame(animate);\n      timeRef.current += 0.01;\n\n      // Update based on template\n      if (particlesRef.current) {\n        if (template === 'particles') {\n          // Use stored rotation speeds\n          const rotationSpeed = particlesRef.current.userData.rotationSpeed || {\n            x: 0.001,\n            y: 0.002\n          };\n          particlesRef.current.rotation.y += rotationSpeed.y;\n          particlesRef.current.rotation.x += rotationSpeed.x;\n\n          // Apply audio reactivity if available\n          if (audioData && audioData.dataArray && particlesRef.current.geometry.attributes.size) {\n            const sizes = particlesRef.current.geometry.attributes.size.array;\n            const reactivity = particlesRef.current.userData.reactivity || 1;\n            for (let i = 0; i < sizes.length; i++) {\n              const dataIndex = i % Math.min(128, audioData.dataArray.length);\n              const audioValue = audioData.dataArray[dataIndex] / 255;\n              const baseSize = sizes[i] / (1 + reactivity); // Get base size without reactivity\n\n              // Apply reactivity\n              sizes[i] = baseSize * (1 + audioValue * reactivity);\n            }\n            particlesRef.current.geometry.attributes.size.needsUpdate = true;\n          }\n        } else if (template === 'spiral') {\n          // Use stored rotation speed\n          const rotationSpeed = particlesRef.current.userData.rotationSpeed || 0.005;\n          particlesRef.current.rotation.z += rotationSpeed;\n\n          // Apply audio reactivity if available\n          if (audioData && audioData.dataArray && particlesRef.current.geometry.attributes.position) {\n            const positions = particlesRef.current.geometry.attributes.position.array;\n            const originalPositions = particlesRef.current.userData.originalPositions;\n            const reactivity = particlesRef.current.userData.reactivity || 1;\n\n            // Store original positions if not already stored\n            if (!originalPositions) {\n              particlesRef.current.userData.originalPositions = new Float32Array(positions.length);\n              for (let i = 0; i < positions.length; i++) {\n                particlesRef.current.userData.originalPositions[i] = positions[i];\n              }\n            }\n\n            // Apply audio reactivity\n            for (let i = 0; i < positions.length / 3; i++) {\n              const dataIndex = i % Math.min(128, audioData.dataArray.length);\n              const audioValue = audioData.dataArray[dataIndex] / 255 * reactivity;\n              if (originalPositions) {\n                positions[i * 3] = originalPositions[i * 3] * (1 + audioValue * 0.3);\n                positions[i * 3 + 1] = originalPositions[i * 3 + 1] * (1 + audioValue * 0.3);\n              }\n            }\n            particlesRef.current.geometry.attributes.position.needsUpdate = true;\n          }\n        } else if (template === 'kaleidoscope') {\n          // Use stored rotation speeds\n          const rotationSpeed = particlesRef.current.userData.rotationSpeed || {\n            x: 0.005,\n            y: 0.01\n          };\n          particlesRef.current.rotation.x += rotationSpeed.x;\n          particlesRef.current.rotation.y += rotationSpeed.y;\n\n          // Scale based on audio if available\n          if (audioData && audioData.dataArray) {\n            let avgAudio = 0;\n            for (let i = 0; i < Math.min(128, audioData.dataArray.length); i++) {\n              avgAudio += audioData.dataArray[i];\n            }\n            avgAudio = avgAudio / Math.min(128, audioData.dataArray.length) / 255;\n\n            // Apply reactivity parameter\n            const reactivity = particlesRef.current.userData.reactivity || 1;\n            avgAudio *= reactivity;\n            const baseScale = particlesRef.current.userData.baseScale || 1;\n            particlesRef.current.scale.set(baseScale * (1 + avgAudio), baseScale * (1 + avgAudio), baseScale * (1 + avgAudio));\n          }\n        }\n      }\n\n      // Update waveform if available\n      if (waveformRef.current && audioData && audioData.dataArray) {\n        const positions = waveformRef.current.geometry.attributes.position.array;\n        const reactivity = waveformRef.current.userData.reactivity || 1;\n        const height = waveformRef.current.userData.height || 1;\n        for (let i = 0; i < Math.min(128, audioData.dataArray.length); i++) {\n          positions[i * 3 + 1] = audioData.dataArray[i] / 128 * 2 * reactivity * height - 1;\n        }\n        waveformRef.current.geometry.attributes.position.needsUpdate = true;\n      }\n\n      // Update controls\n      if (controlsRef.current) {\n        controlsRef.current.update();\n      }\n\n      // Render scene\n      rendererRef.current.render(sceneRef.current, cameraRef.current);\n    } catch (error) {\n      console.error(\"Error in animation loop:\", error);\n      cancelAnimationFrame(animationFrameRef.current);\n    }\n  };\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    ref: mountRef,\n    className: \"three-visualizer-container\",\n    style: {\n      width: '100%',\n      height: '100%'\n    }\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 662,\n    columnNumber: 10\n  }, this);\n};\n_s(ThreeVisualizer, \"FxMDg2k676Tf2uIq1RK9qE8DBQ8=\");\n_c = ThreeVisualizer;\nexport default ThreeVisualizer;\nvar _c;\n$RefreshReg$(_c, \"ThreeVisualizer\");","map":{"version":3,"names":["React","useEffect","useRef","useState","THREE","OrbitControls","jsxDEV","_jsxDEV","ThreeVisualizer","audioData","template","isPlaying","parameters","initialParameters","_s","mountRef","sceneRef","cameraRef","rendererRef","animationFrameRef","particlesRef","waveformRef","timeRef","controlsRef","isInitialized","setIsInitialized","setParameters","console","log","Object","keys","length","current","scene","Scene","camera","PerspectiveCamera","clientWidth","clientHeight","position","z","renderer","WebGLRenderer","antialias","alpha","setSize","setClearColor","appendChild","domElement","classList","add","controls","enableDamping","dampingFactor","rotateSpeed","ambientLight","AmbientLight","directionalLight","DirectionalLight","set","handleResize","width","height","aspect","updateProjectionMatrix","window","addEventListener","render","removeEventListener","removeChild","error","cancelAnimationFrame","geometry","dispose","material","remove","createParticleSystem","createWaveform","createSpiral","createKaleidoscope","animate","particleCount","Math","floor","count","particles","BufferGeometry","positions","Float32Array","colors","sizes","baseColor","color","Color","i","radius","random","theta","PI","phi","acos","sin","cos","clone","offsetHSL","r","g","b","size","setAttribute","BufferAttribute","particleMaterial","PointsMaterial","vertexColors","transparent","opacity","blending","AdditiveBlending","particleSystem","Points","userData","rotationSpeed","x","speed","y","reactivity","vertices","hue","LineBasicMaterial","linewidth","lineWidth","waveform","Line","armCount","arms","pointsPerArm","totalPoints","arm","armAngle","index","t","angle","spiral","scale","IcosahedronGeometry","MeshPhongMaterial","wireframe","emissive","multiplyScalar","specular","shininess","kaleidoscope","Mesh","baseScale","complexity","attributes","array","needsUpdate","requestAnimationFrame","rotation","dataArray","dataIndex","min","audioValue","baseSize","originalPositions","avgAudio","update","ref","className","style","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["C:/Users/fkuce/OneDrive/Desktop/Money Projects/Visualizer/frontend/src/components/ThreeVisualizer.js"],"sourcesContent":["import React, { useEffect, useRef, useState } from 'react';\nimport * as THREE from 'three';\nimport { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';\n\nconst ThreeVisualizer = ({ audioData, template, isPlaying, parameters: initialParameters = {} }) => {\n  const mountRef = useRef(null);\n  const sceneRef = useRef(null);\n  const cameraRef = useRef(null);\n  const rendererRef = useRef(null);\n  const animationFrameRef = useRef(null);\n  const particlesRef = useRef(null);\n  const waveformRef = useRef(null);\n  const timeRef = useRef(0);\n  const controlsRef = useRef(null);\n  const [isInitialized, setIsInitialized] = useState(false);\n  const [parameters, setParameters] = useState(initialParameters);\n\n  console.log(\"ThreeVisualizer rendering with template:\", template);\n  console.log(\"Audio data:\", audioData);\n  console.log(\"Is playing:\", isPlaying);\n  console.log(\"Parameters:\", parameters);\n\n  // Update parameters when initialParameters change\n  useEffect(() => {\n    console.log(\"ThreeVisualizer received updated parameters:\", initialParameters);\n    if (initialParameters && Object.keys(initialParameters).length > 0) {\n      setParameters(initialParameters);\n      // No need to restart animation - parameters will be picked up in next frame\n    }\n  }, [initialParameters]);\n\n  // Initialize Three.js scene\n  useEffect(() => {\n    if (!mountRef.current) return;\n    \n    console.log(\"Initializing Three.js scene\");\n\n    try {\n      // Create scene\n      const scene = new THREE.Scene();\n      sceneRef.current = scene;\n\n      // Create camera\n      const camera = new THREE.PerspectiveCamera(\n        75,\n        mountRef.current.clientWidth / mountRef.current.clientHeight,\n        0.1,\n        1000\n      );\n      camera.position.z = 5;\n      cameraRef.current = camera;\n\n      // Create renderer\n      const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });\n      renderer.setSize(mountRef.current.clientWidth, mountRef.current.clientHeight);\n      renderer.setClearColor(0x000000, 1);\n      mountRef.current.appendChild(renderer.domElement);\n      rendererRef.current = renderer;\n\n      // Add class to canvas for easier selection\n      renderer.domElement.classList.add('three-canvas');\n\n      // Add orbit controls for user interaction\n      const controls = new OrbitControls(camera, renderer.domElement);\n      controls.enableDamping = true;\n      controls.dampingFactor = 0.05;\n      controls.rotateSpeed = 0.5;\n      controlsRef.current = controls;\n\n      // Add ambient light\n      const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);\n      scene.add(ambientLight);\n\n      // Add directional light\n      const directionalLight = new THREE.DirectionalLight(0xffffff, 1);\n      directionalLight.position.set(0, 1, 1);\n      scene.add(directionalLight);\n\n      // Handle window resize\n      const handleResize = () => {\n        if (!mountRef.current || !cameraRef.current || !rendererRef.current) return;\n        \n        const width = mountRef.current.clientWidth;\n        const height = mountRef.current.clientHeight;\n        \n        cameraRef.current.aspect = width / height;\n        cameraRef.current.updateProjectionMatrix();\n        \n        rendererRef.current.setSize(width, height);\n      };\n\n      window.addEventListener('resize', handleResize);\n      \n      // Initial render\n      renderer.render(scene, camera);\n      setIsInitialized(true);\n      \n      console.log(\"Three.js scene initialized successfully\");\n\n      // Clean up\n      return () => {\n        console.log(\"Cleaning up Three.js scene\");\n        window.removeEventListener('resize', handleResize);\n        \n        if (rendererRef.current && mountRef.current) {\n          try {\n            mountRef.current.removeChild(rendererRef.current.domElement);\n          } catch (error) {\n            console.error(\"Error removing renderer:\", error);\n          }\n        }\n        \n        if (animationFrameRef.current) {\n          cancelAnimationFrame(animationFrameRef.current);\n        }\n        \n        // Dispose of Three.js objects\n        if (particlesRef.current) {\n          try {\n            particlesRef.current.geometry.dispose();\n            particlesRef.current.material.dispose();\n            sceneRef.current.remove(particlesRef.current);\n          } catch (error) {\n            console.error(\"Error disposing particles:\", error);\n          }\n        }\n        \n        if (waveformRef.current) {\n          try {\n            waveformRef.current.geometry.dispose();\n            waveformRef.current.material.dispose();\n            sceneRef.current.remove(waveformRef.current);\n          } catch (error) {\n            console.error(\"Error disposing waveform:\", error);\n          }\n        }\n        \n        setIsInitialized(false);\n      };\n    } catch (error) {\n      console.error(\"Error initializing Three.js:\", error);\n    }\n  }, []);\n\n  // Create or update visualization based on template\n  useEffect(() => {\n    if (!isInitialized || !sceneRef.current) {\n      console.log(\"Scene not initialized yet, skipping visualization creation\");\n      return;\n    }\n    \n    console.log(\"Creating visualization for template:\", template);\n\n    try {\n      // Clear previous visualizations\n      if (particlesRef.current) {\n        particlesRef.current.geometry.dispose();\n        particlesRef.current.material.dispose();\n        sceneRef.current.remove(particlesRef.current);\n        particlesRef.current = null;\n      }\n\n      if (waveformRef.current) {\n        waveformRef.current.geometry.dispose();\n        waveformRef.current.material.dispose();\n        sceneRef.current.remove(waveformRef.current);\n        waveformRef.current = null;\n      }\n\n      // Create new visualization based on template\n      switch (template) {\n        case 'particles':\n          createParticleSystem();\n          break;\n        case 'waveform':\n          createWaveform();\n          break;\n        case 'spiral':\n          createSpiral();\n          break;\n        case 'kaleidoscope':\n          createKaleidoscope();\n          break;\n        default:\n          console.log(\"Unknown template, defaulting to particles\");\n          createParticleSystem();\n      }\n      \n      console.log(\"Visualization created successfully\");\n\n      // Start animation if playing\n      if (isPlaying) {\n        animate();\n      }\n    } catch (error) {\n      console.error(\"Error creating visualization:\", error);\n    }\n  }, [template, isInitialized]);\n\n  // Handle play/pause\n  useEffect(() => {\n    console.log(\"Play state changed:\", isPlaying);\n    \n    if (!isInitialized) {\n      console.log(\"Scene not initialized yet, skipping animation\");\n      return;\n    }\n\n    if (isPlaying) {\n      console.log(\"Starting animation\");\n      animate();\n    } else if (animationFrameRef.current) {\n      console.log(\"Stopping animation\");\n      cancelAnimationFrame(animationFrameRef.current);\n    }\n  }, [isPlaying, isInitialized]);\n\n  // Create particle system visualization\n  const createParticleSystem = () => {\n    console.log(\"Creating particle system\");\n    \n    try {\n      // Use count parameter to determine particle count\n      const particleCount = Math.floor(((parameters.count || 50) / 50) * 5000);\n      const particles = new THREE.BufferGeometry();\n      \n      const positions = new Float32Array(particleCount * 3);\n      const colors = new Float32Array(particleCount * 3);\n      const sizes = new Float32Array(particleCount);\n      \n      // Use color from parameters\n      const baseColor = parameters.color ? new THREE.Color(parameters.color) : new THREE.Color(0xffffff);\n      \n      for (let i = 0; i < particleCount; i++) {\n        // Position particles in a sphere\n        const radius = 3 + Math.random() * 2;\n        const theta = Math.random() * Math.PI * 2;\n        const phi = Math.acos(2 * Math.random() - 1);\n        \n        positions[i * 3] = radius * Math.sin(phi) * Math.cos(theta);\n        positions[i * 3 + 1] = radius * Math.sin(phi) * Math.sin(theta);\n        positions[i * 3 + 2] = radius * Math.cos(phi);\n        \n        // Random colors based on parameter color\n        const color = baseColor.clone().offsetHSL((Math.random() - 0.5) * 0.2, 0, (Math.random() - 0.5) * 0.3);\n        colors[i * 3] = color.r;\n        colors[i * 3 + 1] = color.g;\n        colors[i * 3 + 2] = color.b;\n        \n        // Random sizes based on size parameter\n        sizes[i] = (Math.random() * 0.5 + 0.5) * ((parameters.size || 50) / 25);\n      }\n      \n      particles.setAttribute('position', new THREE.BufferAttribute(positions, 3));\n      particles.setAttribute('color', new THREE.BufferAttribute(colors, 3));\n      particles.setAttribute('size', new THREE.BufferAttribute(sizes, 1));\n      \n      // Use simpler material for better compatibility\n      const particleMaterial = new THREE.PointsMaterial({\n        size: 0.1,\n        vertexColors: true,\n        transparent: true,\n        opacity: 0.8,\n        blending: THREE.AdditiveBlending\n      });\n      \n      const particleSystem = new THREE.Points(particles, particleMaterial);\n      \n      // Store parameters for animation\n      particleSystem.userData.rotationSpeed = {\n        x: 0.001 * ((parameters.speed || 50) / 50),\n        y: 0.002 * ((parameters.speed || 50) / 50)\n      };\n      particleSystem.userData.reactivity = (parameters.reactivity || 50) / 50;\n      \n      sceneRef.current.add(particleSystem);\n      particlesRef.current = particleSystem;\n      \n      console.log(\"Particle system created successfully\");\n    } catch (error) {\n      console.error(\"Error creating particle system:\", error);\n    }\n  };\n\n  // Create waveform visualization\n  const createWaveform = () => {\n    console.log(\"Creating waveform\");\n    \n    try {\n      const geometry = new THREE.BufferGeometry();\n      const vertices = new Float32Array(128 * 3);\n      const colors = new Float32Array(128 * 3);\n      \n      // Use color from parameters\n      const baseColor = parameters.color ? new THREE.Color(parameters.color) : new THREE.Color(0x00aaff);\n      \n      for (let i = 0; i < 128; i++) {\n        const x = (i / 128) * 10 - 5;\n        vertices[i * 3] = x;\n        vertices[i * 3 + 1] = 0;\n        vertices[i * 3 + 2] = 0;\n        \n        // Color gradient based on parameter color\n        const hue = i / 128;\n        const color = baseColor.clone().offsetHSL(hue * 0.3, 0, 0); // Slight hue variation\n        colors[i * 3] = color.r;\n        colors[i * 3 + 1] = color.g;\n        colors[i * 3 + 2] = color.b;\n      }\n      \n      geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));\n      geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));\n      \n      const material = new THREE.LineBasicMaterial({\n        vertexColors: true,\n        linewidth: parameters.lineWidth || 2,\n      });\n      \n      const waveform = new THREE.Line(geometry, material);\n      \n      // Store reactivity for animation\n      waveform.userData.reactivity = (parameters.reactivity || 50) / 50;\n      \n      // Store height parameter\n      waveform.userData.height = (parameters.height || 50) / 50;\n      \n      sceneRef.current.add(waveform);\n      waveformRef.current = waveform;\n      \n      console.log(\"Waveform created successfully\");\n    } catch (error) {\n      console.error(\"Error creating waveform:\", error);\n    }\n  };\n\n  // Create spiral visualization\n  const createSpiral = () => {\n    console.log(\"Creating spiral\");\n    \n    try {\n      const geometry = new THREE.BufferGeometry();\n      const armCount = parameters.arms || 5;\n      const pointsPerArm = 400;\n      const totalPoints = armCount * pointsPerArm;\n      const vertices = new Float32Array(totalPoints * 3);\n      const colors = new Float32Array(totalPoints * 3);\n      \n      // Use color from parameters\n      const baseColor = parameters.color ? new THREE.Color(parameters.color) : new THREE.Color(0x00ff99);\n      \n      // Create spiral with multiple arms\n      for (let arm = 0; arm < armCount; arm++) {\n        const armAngle = (arm / armCount) * Math.PI * 2;\n        \n        for (let i = 0; i < pointsPerArm; i++) {\n          const index = (arm * pointsPerArm + i) * 3;\n          const t = i / pointsPerArm;\n          const angle = armAngle + t * Math.PI * 20;\n          const radius = t * 5;\n          \n          vertices[index] = Math.cos(angle) * radius;\n          vertices[index + 1] = Math.sin(angle) * radius;\n          vertices[index + 2] = t * 2 - 1;\n          \n          // Color gradient based on parameter color\n          const color = baseColor.clone().offsetHSL(t * 0.5, 0, 0); // Hue variation along spiral\n          colors[index] = color.r;\n          colors[index + 1] = color.g;\n          colors[index + 2] = color.b;\n        }\n      }\n      \n      geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));\n      geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));\n      \n      const material = new THREE.PointsMaterial({\n        size: 0.1,\n        vertexColors: true,\n        transparent: true,\n        opacity: 0.8,\n        blending: THREE.AdditiveBlending,\n      });\n      \n      const spiral = new THREE.Points(geometry, material);\n      \n      // Store parameters for animation\n      spiral.userData.rotationSpeed = 0.005 * ((parameters.speed || 50) / 50);\n      spiral.userData.reactivity = (parameters.reactivity || 50) / 50;\n      \n      // Apply radius parameter\n      const scale = (parameters.radius || 50) / 50;\n      spiral.scale.set(scale, scale, scale);\n      \n      sceneRef.current.add(spiral);\n      particlesRef.current = spiral;\n      \n      console.log(\"Spiral created successfully\");\n    } catch (error) {\n      console.error(\"Error creating spiral:\", error);\n    }\n  };\n\n  // Create kaleidoscope visualization\n  const createKaleidoscope = () => {\n    console.log(\"Creating kaleidoscope\");\n    \n    try {\n      // Create a simpler geometry for better compatibility\n      const geometry = new THREE.IcosahedronGeometry(2, 2);\n      \n      // Use MeshPhongMaterial for better color control\n      const material = new THREE.MeshPhongMaterial({\n        color: parameters.color || 0xffffff,\n        wireframe: true,\n        emissive: parameters.color ? new THREE.Color(parameters.color).multiplyScalar(0.5) : 0x444444,\n        specular: 0xffffff,\n        shininess: 100,\n      });\n      \n      const kaleidoscope = new THREE.Mesh(geometry, material);\n      \n      // Store base scale for reactivity\n      kaleidoscope.userData.baseScale = 0.5 + ((parameters.complexity || 50) / 100);\n      kaleidoscope.scale.set(\n        kaleidoscope.userData.baseScale,\n        kaleidoscope.userData.baseScale,\n        kaleidoscope.userData.baseScale\n      );\n      \n      // Store rotation speed\n      kaleidoscope.userData.rotationSpeed = {\n        x: 0.005 * ((parameters.speed || 50) / 50),\n        y: 0.01 * ((parameters.speed || 50) / 50)\n      };\n      \n      sceneRef.current.add(kaleidoscope);\n      particlesRef.current = kaleidoscope;\n      \n      console.log(\"Kaleidoscope created successfully\");\n    } catch (error) {\n      console.error(\"Error creating kaleidoscope:\", error);\n    }\n  };\n\n  // Apply parameters to the visualizations\n  useEffect(() => {\n    if (!isInitialized || !sceneRef.current || !particlesRef.current) return;\n    \n    console.log(\"Applying parameters to 3D visualization:\", parameters);\n    \n    try {\n      // Apply common parameters\n      const reactivity = (parameters.reactivity || 50) / 50; // Convert to 0-2 scale\n      const speed = (parameters.speed || 50) / 50; // Convert to 0-2 scale\n      \n      // Apply color if available\n      if (parameters.color && particlesRef.current.material) {\n        // Convert hex color to THREE.Color\n        const color = new THREE.Color(parameters.color);\n        \n        // Apply color based on material type\n        if (particlesRef.current.material.color) {\n          particlesRef.current.material.color.set(color);\n        } else if (particlesRef.current.material.emissive) {\n          particlesRef.current.material.emissive.set(color);\n        }\n      }\n      \n      // Apply template-specific parameters\n      switch (template) {\n        case 'particles':\n          // Apply particle count\n          if (parameters.count && particlesRef.current.geometry.attributes.size) {\n            // Can't change particle count dynamically, but we can hide some\n            const count = Math.floor((parameters.count / 100) * particlesRef.current.geometry.attributes.position.count);\n            const sizes = particlesRef.current.geometry.attributes.size.array;\n            \n            for (let i = 0; i < sizes.length; i++) {\n              sizes[i] = i < count ? (parameters.size || 50) / 5 : 0;\n            }\n            \n            particlesRef.current.geometry.attributes.size.needsUpdate = true;\n          }\n          \n          // Apply size\n          if (parameters.size && particlesRef.current.geometry.attributes.size) {\n            const sizes = particlesRef.current.geometry.attributes.size.array;\n            const count = Math.floor((parameters.count || 50) / 100 * sizes.length);\n            \n            for (let i = 0; i < count; i++) {\n              sizes[i] = (Math.random() * 0.5 + 0.5) * (parameters.size / 25);\n            }\n            \n            particlesRef.current.geometry.attributes.size.needsUpdate = true;\n          }\n          break;\n          \n        case 'kaleidoscope':\n          // Apply complexity\n          if (parameters.complexity && particlesRef.current.geometry) {\n            // Can't change geometry complexity dynamically, but we can scale it\n            const scale = 0.5 + (parameters.complexity / 100);\n            particlesRef.current.userData.baseScale = scale;\n            particlesRef.current.scale.set(scale, scale, scale);\n          }\n          break;\n          \n        case 'spiral':\n          // Apply arms count\n          if (parameters.arms && particlesRef.current.geometry) {\n            // Can't change arms dynamically, but we can adjust rotation speed\n            const rotationSpeed = 0.005 * (parameters.arms / 5);\n            particlesRef.current.userData.rotationSpeed = rotationSpeed;\n          }\n          \n          // Apply radius\n          if (parameters.radius && particlesRef.current.geometry) {\n            const scale = parameters.radius / 50;\n            particlesRef.current.scale.set(scale, scale, scale);\n          }\n          break;\n          \n        case 'waveform':\n          // Apply line width\n          if (parameters.lineWidth && particlesRef.current.material) {\n            particlesRef.current.material.linewidth = parameters.lineWidth;\n          }\n          break;\n      }\n      \n      // Store reactivity and speed in userData for use in animation\n      particlesRef.current.userData.reactivity = reactivity;\n      particlesRef.current.userData.speed = speed;\n      \n    } catch (error) {\n      console.error(\"Error applying parameters:\", error);\n    }\n  }, [parameters, template, isInitialized]);\n\n  // Animation loop\n  const animate = () => {\n    if (!sceneRef.current || !cameraRef.current || !rendererRef.current) {\n      console.log(\"Missing required refs for animation\");\n      return;\n    }\n    \n    try {\n      animationFrameRef.current = requestAnimationFrame(animate);\n      \n      timeRef.current += 0.01;\n      \n      // Update based on template\n      if (particlesRef.current) {\n        if (template === 'particles') {\n          // Use stored rotation speeds\n          const rotationSpeed = particlesRef.current.userData.rotationSpeed || { x: 0.001, y: 0.002 };\n          particlesRef.current.rotation.y += rotationSpeed.y;\n          particlesRef.current.rotation.x += rotationSpeed.x;\n          \n          // Apply audio reactivity if available\n          if (audioData && audioData.dataArray && particlesRef.current.geometry.attributes.size) {\n            const sizes = particlesRef.current.geometry.attributes.size.array;\n            const reactivity = particlesRef.current.userData.reactivity || 1;\n            \n            for (let i = 0; i < sizes.length; i++) {\n              const dataIndex = i % Math.min(128, audioData.dataArray.length);\n              const audioValue = audioData.dataArray[dataIndex] / 255;\n              const baseSize = sizes[i] / (1 + reactivity); // Get base size without reactivity\n              \n              // Apply reactivity\n              sizes[i] = baseSize * (1 + audioValue * reactivity);\n            }\n            \n            particlesRef.current.geometry.attributes.size.needsUpdate = true;\n          }\n        } else if (template === 'spiral') {\n          // Use stored rotation speed\n          const rotationSpeed = particlesRef.current.userData.rotationSpeed || 0.005;\n          particlesRef.current.rotation.z += rotationSpeed;\n          \n          // Apply audio reactivity if available\n          if (audioData && audioData.dataArray && particlesRef.current.geometry.attributes.position) {\n            const positions = particlesRef.current.geometry.attributes.position.array;\n            const originalPositions = particlesRef.current.userData.originalPositions;\n            const reactivity = particlesRef.current.userData.reactivity || 1;\n            \n            // Store original positions if not already stored\n            if (!originalPositions) {\n              particlesRef.current.userData.originalPositions = new Float32Array(positions.length);\n              for (let i = 0; i < positions.length; i++) {\n                particlesRef.current.userData.originalPositions[i] = positions[i];\n              }\n            }\n            \n            // Apply audio reactivity\n            for (let i = 0; i < positions.length / 3; i++) {\n              const dataIndex = i % Math.min(128, audioData.dataArray.length);\n              const audioValue = audioData.dataArray[dataIndex] / 255 * reactivity;\n              \n              if (originalPositions) {\n                positions[i * 3] = originalPositions[i * 3] * (1 + audioValue * 0.3);\n                positions[i * 3 + 1] = originalPositions[i * 3 + 1] * (1 + audioValue * 0.3);\n              }\n            }\n            \n            particlesRef.current.geometry.attributes.position.needsUpdate = true;\n          }\n        } else if (template === 'kaleidoscope') {\n          // Use stored rotation speeds\n          const rotationSpeed = particlesRef.current.userData.rotationSpeed || { x: 0.005, y: 0.01 };\n          particlesRef.current.rotation.x += rotationSpeed.x;\n          particlesRef.current.rotation.y += rotationSpeed.y;\n          \n          // Scale based on audio if available\n          if (audioData && audioData.dataArray) {\n            let avgAudio = 0;\n            for (let i = 0; i < Math.min(128, audioData.dataArray.length); i++) {\n              avgAudio += audioData.dataArray[i];\n            }\n            avgAudio = avgAudio / Math.min(128, audioData.dataArray.length) / 255;\n            \n            // Apply reactivity parameter\n            const reactivity = particlesRef.current.userData.reactivity || 1;\n            avgAudio *= reactivity;\n            \n            const baseScale = particlesRef.current.userData.baseScale || 1;\n            particlesRef.current.scale.set(\n              baseScale * (1 + avgAudio),\n              baseScale * (1 + avgAudio),\n              baseScale * (1 + avgAudio)\n            );\n          }\n        }\n      }\n      \n      // Update waveform if available\n      if (waveformRef.current && audioData && audioData.dataArray) {\n        const positions = waveformRef.current.geometry.attributes.position.array;\n        const reactivity = waveformRef.current.userData.reactivity || 1;\n        const height = waveformRef.current.userData.height || 1;\n        \n        for (let i = 0; i < Math.min(128, audioData.dataArray.length); i++) {\n          positions[i * 3 + 1] = (audioData.dataArray[i] / 128) * 2 * reactivity * height - 1;\n        }\n        \n        waveformRef.current.geometry.attributes.position.needsUpdate = true;\n      }\n      \n      // Update controls\n      if (controlsRef.current) {\n        controlsRef.current.update();\n      }\n      \n      // Render scene\n      rendererRef.current.render(sceneRef.current, cameraRef.current);\n    } catch (error) {\n      console.error(\"Error in animation loop:\", error);\n      cancelAnimationFrame(animationFrameRef.current);\n    }\n  };\n\n  return <div ref={mountRef} className=\"three-visualizer-container\" style={{ width: '100%', height: '100%' }} />;\n};\n\nexport default ThreeVisualizer; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}