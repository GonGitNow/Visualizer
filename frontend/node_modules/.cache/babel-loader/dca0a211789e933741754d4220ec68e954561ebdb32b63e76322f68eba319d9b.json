{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\fkuce\\\\OneDrive\\\\Desktop\\\\Money Projects\\\\Visualizer\\\\frontend\\\\src\\\\components\\\\Visualizer.js\",\n  _s = $RefreshSig$();\nimport React, { useEffect, useRef, forwardRef, useState, useImperativeHandle } from 'react';\nimport ThreeVisualizer from './ThreeVisualizer';\nimport './Visualizer.css';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst RESOLUTIONS = {\n  '4K': {\n    width: 3840,\n    height: 2160,\n    className: 'aspect-ratio-4k'\n  },\n  '1080p': {\n    width: 1920,\n    height: 1080,\n    className: 'aspect-ratio-1080p'\n  },\n  '720p': {\n    width: 1280,\n    height: 720,\n    className: 'aspect-ratio-720p'\n  },\n  'Square': {\n    width: 720,\n    height: 720,\n    className: 'aspect-ratio-square'\n  },\n  'Vertical': {\n    width: 1080,\n    height: 1920,\n    className: 'aspect-ratio-vertical'\n  }\n};\nconst Visualizer = /*#__PURE__*/_s(/*#__PURE__*/forwardRef(_c = _s(({\n  audioFile,\n  template,\n  isPlaying,\n  onAudioElementCreated,\n  parameters: initialParameters = {}\n}, ref) => {\n  _s();\n  const canvasRef = useRef(null);\n  const containerRef = useRef(null);\n  const audioContextRef = useRef(null);\n  const analyserRef = useRef(null);\n  const animationFrameRef = useRef(null);\n  const sourceRef = useRef(null);\n  const audioElementRef = useRef(null);\n  const particlesRef = useRef([]);\n  const timeRef = useRef(0); // Add timeRef to track animation time\n  const [resolution, setResolution] = useState('1080p'); // Default to 1080p\n  const [audioData, setAudioData] = useState(null);\n  const [use3D, setUse3D] = useState(false);\n  const [parameters, setParameters] = useState(initialParameters);\n\n  // Check if template is a 3D visualization\n  useEffect(() => {\n    // Define which templates should use 3D rendering\n    const threeDTemplates = ['particles3d', 'waveform3d', 'spiral3d', 'kaleidoscope3d'];\n    setUse3D(threeDTemplates.includes(template));\n  }, [template]);\n\n  // Audio initialization effect\n  useEffect(() => {\n    if (!audioFile) return;\n    let isInitialized = false;\n    const initAudio = async () => {\n      try {\n        // Initialize audio context only on first load or if it doesn't exist\n        if (!audioContextRef.current) {\n          // Create context on user interaction\n          const context = new (window.AudioContext || window.webkitAudioContext)();\n          audioContextRef.current = context;\n\n          // Create analyzer with improved settings for better reactivity\n          const analyser = context.createAnalyser();\n          analyser.fftSize = 2048; // Increased for more detailed frequency data\n          analyser.smoothingTimeConstant = 0.8; // Higher smoothing for more consistent movement\n          analyserRef.current = analyser;\n        }\n\n        // Create and set up audio element\n        const audioElement = new Audio();\n        audioElement.crossOrigin = \"anonymous\";\n        audioElement.preload = \"auto\";\n\n        // Set the audio source\n        const timestamp = new Date().getTime();\n        audioElement.src = `http://localhost:5001${audioFile.path}?t=${timestamp}`;\n\n        // Wait for audio to be loaded enough to play\n        await new Promise((resolve, reject) => {\n          const loadHandler = () => {\n            console.log('Audio loaded, duration:', audioElement.duration);\n            resolve();\n          };\n          const errorHandler = error => {\n            console.error('Audio load error:', error);\n            reject(error);\n          };\n          audioElement.addEventListener('canplaythrough', loadHandler, {\n            once: true\n          });\n          audioElement.addEventListener('error', errorHandler, {\n            once: true\n          });\n          audioElement.load();\n        });\n\n        // Only create new media source if not already connected\n        if (!isInitialized) {\n          // Ensure old source is disconnected\n          if (sourceRef.current) {\n            sourceRef.current.disconnect();\n          }\n\n          // Create and connect new media source\n          const mediaSource = audioContextRef.current.createMediaElementSource(audioElement);\n          sourceRef.current = mediaSource;\n          mediaSource.connect(analyserRef.current);\n          analyserRef.current.connect(audioContextRef.current.destination);\n          isInitialized = true;\n        }\n\n        // Set up event listeners - REMOVE timeupdate listener which causes visualization restarts\n        const onSeeking = () => {\n          console.log('Seeking:', audioElement.currentTime);\n          if (isPlaying) startVisualization();\n        };\n        audioElement.addEventListener('seeking', onSeeking);\n        audioElement.addEventListener('seeked', onSeeking);\n        // Removed timeupdate listener which was causing visualization restarts\n\n        // Store reference and notify parent\n        audioElementRef.current = audioElement;\n        onAudioElementCreated(audioElement);\n\n        // Resume audio context if suspended\n        if (audioContextRef.current.state === 'suspended') {\n          await audioContextRef.current.resume();\n        }\n        return () => {\n          console.log('Cleaning up audio element');\n          audioElement.removeEventListener('seeking', onSeeking);\n          audioElement.removeEventListener('seeked', onSeeking);\n          // Removed timeupdate listener cleanup\n          audioElement.pause();\n          audioElement.src = '';\n          onAudioElementCreated(null);\n        };\n      } catch (error) {\n        console.error('Audio initialization error:', error);\n        alert('Error loading audio. Please try again.');\n      }\n    };\n    initAudio();\n  }, [audioFile]); // Remove isPlaying from dependencies\n\n  // Separate playback control effect\n  useEffect(() => {\n    const audioElement = audioElementRef.current;\n    if (!audioElement) return;\n    const playAudio = async () => {\n      try {\n        var _audioContextRef$curr;\n        // Ensure audio context is running\n        if (((_audioContextRef$curr = audioContextRef.current) === null || _audioContextRef$curr === void 0 ? void 0 : _audioContextRef$curr.state) === 'suspended') {\n          await audioContextRef.current.resume();\n        }\n        console.log('Playing audio...');\n        await audioElement.play();\n        startVisualization();\n      } catch (error) {\n        console.error('Playback error:', error);\n        alert('Error playing audio. Please try again.');\n      }\n    };\n    if (isPlaying) {\n      playAudio();\n    } else {\n      console.log('Pausing audio...');\n      audioElement.pause();\n      cancelAnimationFrame(animationFrameRef.current);\n    }\n  }, [isPlaying]);\n\n  // Add effect to handle template changes\n  useEffect(() => {\n    if (!canvasRef.current) return;\n    const canvas = canvasRef.current;\n    const ctx = canvas.getContext('2d');\n\n    // Clear the entire canvas\n    ctx.fillStyle = 'rgb(0, 0, 0)';\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n    // Restart visualization if playing\n    if (isPlaying) {\n      startVisualization();\n    }\n  }, [template]);\n\n  // Update canvas size based on selected resolution\n  useEffect(() => {\n    if (!canvasRef.current) return;\n    const canvas = canvasRef.current;\n    const {\n      width,\n      height\n    } = RESOLUTIONS[resolution];\n\n    // Set canvas dimensions to match the selected resolution\n    canvas.width = width;\n    canvas.height = height;\n\n    // Clear canvas with new dimensions\n    const ctx = canvas.getContext('2d');\n    ctx.fillStyle = 'rgb(0, 0, 0)';\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n    // Adjust container styles based on aspect ratio\n    if (containerRef.current) {\n      if (resolution === 'Vertical') {\n        containerRef.current.style.width = 'auto';\n        containerRef.current.style.height = '80vh';\n      } else if (resolution === 'Square') {\n        containerRef.current.style.width = '720px';\n        containerRef.current.style.height = '720px';\n        containerRef.current.style.maxWidth = '720px';\n        containerRef.current.style.maxHeight = '720px';\n      } else {\n        containerRef.current.style.width = '100%';\n        containerRef.current.style.height = 'auto';\n        containerRef.current.style.maxWidth = `${width}px`;\n        containerRef.current.style.maxHeight = `${height}px`;\n      }\n    }\n\n    // Restart visualization if playing\n    if (isPlaying) {\n      startVisualization();\n    }\n\n    // Initialize particles for the new canvas size\n    if (template === 'particles') {\n      initParticles(ctx);\n    }\n  }, [resolution, isPlaying, template]);\n\n  // Function to change resolution\n  const changeResolution = newResolution => {\n    if (RESOLUTIONS[newResolution]) {\n      setResolution(newResolution);\n    }\n  };\n\n  // Expose changeResolution to parent via ref\n  useImperativeHandle(ref, () => ({\n    changeResolution,\n    getCurrentResolution: () => resolution,\n    updateParameters\n  }));\n  const initParticles = ctx => {\n    // Safety check - ensure context exists\n    if (!ctx || !ctx.canvas) {\n      console.error(\"Canvas context is null in initParticles\");\n      return;\n    }\n    const count = Math.floor((parameters.count || 50) / 50 * 200); // 100-400 particles based on count parameter\n    particlesRef.current = [];\n    for (let i = 0; i < count; i++) {\n      particlesRef.current.push({\n        x: Math.random() * ctx.canvas.width,\n        y: Math.random() * ctx.canvas.height,\n        size: Math.random() * ((parameters.size || 50) / 10) + 1,\n        // 1-6 size based on size parameter\n        vx: (Math.random() - 0.5) * ((parameters.speed || 50) / 25),\n        // Speed based on speed parameter\n        vy: (Math.random() - 0.5) * ((parameters.speed || 50) / 25),\n        hue: Math.random() * 360\n      });\n    }\n  };\n  const updateAndDrawParticles = (ctx, dataArray, bufferLength, cachedParameters) => {\n    // Safety check - ensure canvas reference exists\n    if (!canvasRef.current) {\n      console.error(\"Canvas reference is null in updateAndDrawParticles\");\n      return;\n    }\n\n    // Safety check - ensure particles array exists\n    if (!particlesRef.current || particlesRef.current.length === 0) {\n      console.log(\"Initializing particles in updateAndDrawParticles\");\n      initParticles(ctx);\n\n      // Double-check initialization worked\n      if (!particlesRef.current || particlesRef.current.length === 0) {\n        console.error(\"Failed to initialize particles\");\n        return;\n      }\n    }\n\n    // Apply parameters\n    const color = cachedParameters.color || '#ffffff';\n    const particleCount = Math.floor((cachedParameters.count || 50) / 100 * particlesRef.current.length);\n    const particleSize = (cachedParameters.size || 50) / 10; // Convert to 0-10 scale\n    const speed = (cachedParameters.speed || 50) / 50; // Convert to 0-2 scale\n    const reactivity = (cachedParameters.reactivity || 50) / 50; // Convert to 0-2 scale\n\n    // Clear canvas with fade effect\n    ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';\n    ctx.fillRect(0, 0, canvasRef.current.width, canvasRef.current.height);\n\n    // Update and draw particles\n    for (let i = 0; i < particleCount; i++) {\n      const particle = particlesRef.current[i];\n\n      // Apply audio reactivity\n      const dataIndex = Math.floor(i / particleCount * bufferLength);\n      const audioValue = dataArray[dataIndex] / 255.0 * reactivity;\n\n      // Update position\n      particle.x += particle.vx * speed;\n      particle.y += particle.vy * speed;\n\n      // Bounce off edges\n      if (particle.x < 0 || particle.x > canvasRef.current.width) {\n        particle.vx = -particle.vx;\n      }\n      if (particle.y < 0 || particle.y > canvasRef.current.height) {\n        particle.vy = -particle.vy;\n      }\n\n      // Draw particle\n      const size = particleSize * (1 + audioValue);\n      ctx.beginPath();\n      ctx.arc(particle.x, particle.y, size, 0, Math.PI * 2);\n      ctx.fillStyle = adjustColor(color, audioValue * 50);\n      ctx.fill();\n    }\n  };\n\n  // Helper function to adjust colors\n  const adjustColor = (hexColor, amount) => {\n    // Convert hex to RGB\n    let r = parseInt(hexColor.substring(1, 3), 16);\n    let g = parseInt(hexColor.substring(3, 5), 16);\n    let b = parseInt(hexColor.substring(5, 7), 16);\n\n    // Adjust RGB values\n    r = Math.max(0, Math.min(255, r + amount));\n    g = Math.max(0, Math.min(255, g + amount));\n    b = Math.max(0, Math.min(255, b + amount));\n\n    // Convert back to hex with proper padding\n    const rHex = Math.round(r).toString(16).padStart(2, '0');\n    const gHex = Math.round(g).toString(16).padStart(2, '0');\n    const bHex = Math.round(b).toString(16).padStart(2, '0');\n    return `#${rHex}${gHex}${bHex}`;\n  };\n\n  // Start visualization\n  const startVisualization = () => {\n    if (!analyserRef.current) {\n      console.error(\"Analyzer reference is null in startVisualization\");\n      return;\n    }\n    const analyser = analyserRef.current;\n\n    // Create data arrays for audio analysis\n    const bufferLength = analyser.frequencyBinCount;\n    const dataArray = new Uint8Array(bufferLength);\n    const timeArray = new Uint8Array(bufferLength);\n\n    // Get initial data\n    analyser.getByteFrequencyData(dataArray);\n    analyser.getByteTimeDomainData(timeArray);\n\n    // Cancel any existing animation frame\n    if (animationFrameRef.current) {\n      cancelAnimationFrame(animationFrameRef.current);\n    }\n\n    // Reset animation time to ensure consistent animation speed\n    timeRef.current = 0;\n\n    // Track frame timing for consistent animation speed\n    let lastFrameTime = performance.now();\n    const targetFrameRate = 30; // Reduced to 30 FPS for smoother, slower animations\n    const frameInterval = 1000 / targetFrameRate;\n\n    // Handle 3D visualization\n    if (use3D) {\n      // For 3D, we need to continuously update the audio data\n      const update3DAudio = currentTime => {\n        animationFrameRef.current = requestAnimationFrame(update3DAudio);\n\n        // Calculate delta time for smooth animation regardless of frame rate\n        const deltaTime = (currentTime - lastFrameTime) / frameInterval;\n        lastFrameTime = currentTime;\n\n        // Increment time for animations with consistent speed\n        timeRef.current += 0.005 * Math.min(deltaTime, 2);\n\n        // Get frequency and time domain data\n        analyser.getByteFrequencyData(dataArray);\n        analyser.getByteTimeDomainData(timeArray);\n\n        // Update audio data for 3D visualizer with more efficient approach\n        const newDataArray = new Array(bufferLength);\n        const newTimeArray = new Array(bufferLength);\n\n        // Use logarithmic sampling to focus more on lower frequencies\n        for (let i = 0; i < bufferLength; i++) {\n          // Logarithmic mapping to emphasize lower frequencies\n          const logIndex = Math.min(bufferLength - 1, Math.floor(Math.pow(i / bufferLength, 0.5) * bufferLength));\n          newDataArray[i] = dataArray[logIndex];\n          newTimeArray[i] = timeArray[logIndex];\n        }\n        setAudioData({\n          dataArray: newDataArray,\n          timeArray: newTimeArray,\n          bufferLength\n        });\n      };\n      update3DAudio(performance.now());\n      return;\n    }\n\n    // For 2D visualizations, ensure canvas exists\n    if (!canvasRef.current) {\n      console.error(\"Canvas reference is null in startVisualization for 2D visualization\");\n      return;\n    }\n    const canvas = canvasRef.current;\n    const ctx = canvas.getContext('2d', {\n      alpha: false\n    }); // Optimize by disabling alpha\n\n    // Cache parameter values outside the animation loop for better performance\n    let cachedParameters = {\n      ...parameters\n    };\n\n    // Animation function for 2D visualizations\n    const draw = currentTime => {\n      animationFrameRef.current = requestAnimationFrame(draw);\n\n      // Calculate delta time for smooth animation regardless of frame rate\n      const deltaTime = (currentTime - lastFrameTime) / frameInterval;\n      lastFrameTime = currentTime;\n\n      // Increment time for animations with consistent speed\n      timeRef.current += 0.005 * Math.min(deltaTime, 2);\n\n      // Get frequency and time domain data\n      analyser.getByteFrequencyData(dataArray);\n      analyser.getByteTimeDomainData(timeArray);\n\n      // Clear canvas\n      ctx.fillStyle = 'rgb(0, 0, 0)';\n      ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n      // Check if parameters have changed\n      if (JSON.stringify(cachedParameters) !== JSON.stringify(parameters)) {\n        cachedParameters = {\n          ...parameters\n        };\n      }\n\n      // Draw visualization based on template\n      switch (template) {\n        case 'waveform':\n          drawWaveform(ctx, dataArray, bufferLength, cachedParameters);\n          break;\n        case 'bars':\n          drawBars(ctx, dataArray, bufferLength, cachedParameters);\n          break;\n        case 'circles':\n          drawCircles(ctx, dataArray, bufferLength, cachedParameters);\n          break;\n        case 'kaleidoscope':\n          drawKaleidoscope(ctx, dataArray, timeArray, bufferLength, cachedParameters);\n          break;\n        case 'spiral':\n          drawSpiral(ctx, dataArray, timeArray, bufferLength, cachedParameters);\n          break;\n        case 'particles':\n          updateAndDrawParticles(ctx, dataArray, bufferLength, cachedParameters);\n          break;\n        case 'ripple':\n          drawRipples(ctx, dataArray, timeArray, bufferLength, cachedParameters);\n          break;\n        case 'terrain':\n          drawTerrain(ctx, dataArray, timeArray, bufferLength, cachedParameters);\n          break;\n        case 'starburst':\n          drawStarburst(ctx, dataArray, timeArray, bufferLength, cachedParameters);\n          break;\n        case 'fractal':\n          drawFractal(ctx, dataArray, timeArray, bufferLength, cachedParameters);\n          break;\n        case 'liquid':\n          drawLiquid(ctx, dataArray, timeArray, bufferLength, cachedParameters);\n          break;\n        case 'mesh':\n          drawMesh(ctx, dataArray, timeArray, bufferLength, cachedParameters);\n          break;\n        case 'clock':\n          drawClock(ctx, dataArray, timeArray, bufferLength, cachedParameters);\n          break;\n        case 'nebula':\n          drawNebula(ctx, dataArray, timeArray, bufferLength, cachedParameters);\n          break;\n        case 'cityscape':\n          drawCityscape(ctx, dataArray, timeArray, bufferLength, cachedParameters);\n          break;\n        case 'waterfall':\n          drawWaterfall(ctx, dataArray, timeArray, bufferLength, cachedParameters);\n          break;\n        case 'constellation':\n          drawConstellation(ctx, dataArray, timeArray, bufferLength, cachedParameters);\n          break;\n        case 'mandala':\n          drawMandala(ctx, dataArray, timeArray, bufferLength, cachedParameters);\n          break;\n        case 'ocean':\n          drawOcean(ctx, dataArray, timeArray, bufferLength, cachedParameters);\n          break;\n        case 'dna':\n          drawDNA(ctx, dataArray, timeArray, bufferLength, cachedParameters);\n          break;\n        case 'forest':\n          drawForest(ctx, dataArray, timeArray, bufferLength, cachedParameters);\n          break;\n        case 'snake':\n          drawSnake(ctx, dataArray, timeArray, bufferLength, cachedParameters);\n          break;\n        default:\n          drawWaveform(ctx, dataArray, bufferLength, cachedParameters);\n      }\n    };\n    draw(performance.now());\n  };\n  const drawWaveform = (ctx, dataArray, bufferLength, cachedParameters) => {\n    // Safety check - ensure canvas reference exists\n    if (!canvasRef.current) {\n      console.error(\"Canvas reference is null in drawWaveform\");\n      return;\n    }\n\n    // Apply parameters\n    const lineWidth = cachedParameters.lineWidth || 3;\n    const color = cachedParameters.color || '#00aaff';\n    const reactivity = (cachedParameters.reactivity || 50) / 40; // Adjusted for better responsiveness\n    const smoothing = (cachedParameters.smoothing || 50) / 100; // Convert to 0-1 scale\n\n    ctx.lineWidth = lineWidth;\n    ctx.strokeStyle = color;\n    ctx.beginPath();\n    const sliceWidth = canvasRef.current.width * 1.0 / bufferLength;\n    let x = 0;\n\n    // Use fewer points for better performance\n    const step = Math.max(1, Math.floor(bufferLength / 256));\n    for (let i = 0; i < bufferLength; i += step) {\n      const v = dataArray[i] / 128.0 * reactivity;\n      const y = v * canvasRef.current.height / 2;\n      if (i === 0) {\n        ctx.moveTo(x, y);\n      } else {\n        // Apply smoothing if enabled\n        if (smoothing > 0) {\n          const prevX = x - sliceWidth * step;\n          const prevY = dataArray[i - step] / 128.0 * reactivity * canvasRef.current.height / 2;\n          const cpX1 = prevX + sliceWidth * step / 3;\n          const cpX2 = x - sliceWidth * step / 3;\n          const cpY1 = prevY;\n          const cpY2 = y;\n\n          // Use bezier curve for smoothing\n          ctx.bezierCurveTo(cpX1, cpY1, cpX2, cpY2, x, y);\n        } else {\n          ctx.lineTo(x, y);\n        }\n      }\n      x += sliceWidth * step;\n    }\n    ctx.lineTo(canvasRef.current.width, canvasRef.current.height / 2);\n    ctx.stroke();\n  };\n  const drawBars = (ctx, dataArray, bufferLength, cachedParameters) => {\n    // Safety check - ensure canvas reference exists\n    if (!canvasRef.current) {\n      console.error(\"Canvas reference is null in drawBars\");\n      return;\n    }\n\n    // Apply parameters\n    const color = cachedParameters.color || '#ff5500';\n    const barWidth = (cachedParameters.barWidth || 50) / 100; // Convert to 0-1 scale\n    const spacing = (cachedParameters.spacing || 30) / 100; // Convert to 0-1 scale\n    const reactivity = (cachedParameters.reactivity || 50) / 20; // Adjusted for better responsiveness\n\n    const bars = Math.min(bufferLength, 128); // Reduced number of bars for better performance\n    const width = canvasRef.current.width;\n    const height = canvasRef.current.height;\n    const barWidthPx = width / bars * barWidth;\n    const barSpacing = width / bars * spacing;\n    const totalBarWidth = barWidthPx + barSpacing;\n    for (let i = 0; i < bars; i++) {\n      // Use logarithmic mapping to emphasize lower frequencies\n      // Focus more on the lower half of the frequency spectrum\n      const freqRatio = i / bars;\n      const dataIndex = Math.min(bufferLength - 1, Math.floor(Math.pow(freqRatio, 0.8) * (bufferLength / 2)));\n      const barHeight = dataArray[dataIndex] * reactivity;\n      const x = i * totalBarWidth;\n      const y = height - barHeight;\n      ctx.fillStyle = adjustColor(color, i / bars * 30);\n      ctx.fillRect(x, y, barWidthPx, barHeight);\n    }\n  };\n  const drawCircles = (ctx, dataArray, bufferLength, cachedParameters) => {\n    // Safety check - ensure canvas reference exists\n    if (!canvasRef.current) {\n      console.error(\"Canvas reference is null in drawCircles\");\n      return;\n    }\n\n    // Apply parameters\n    const color = cachedParameters.color || '#ff00ff';\n    const baseRadius = (cachedParameters.radius || 50) / 100 * Math.min(canvasRef.current.width, canvasRef.current.height) / 2;\n    const circleCount = Math.max(1, Math.min(20, Math.floor((cachedParameters.count || 50) / 5))); // 1-20 circles\n    const reactivity = (cachedParameters.reactivity || 50) / 40; // Adjusted for better responsiveness\n\n    const centerX = canvasRef.current.width / 2;\n    const centerY = canvasRef.current.height / 2;\n\n    // Draw circles\n    for (let c = 0; c < circleCount; c++) {\n      // Focus on lower frequencies for outer circles, higher frequencies for inner circles\n      const freqRatio = c / circleCount;\n      const freqIndex = Math.floor(Math.pow(freqRatio, 0.7) * (bufferLength / 2));\n      const circleIndex = Math.min(bufferLength - 1, freqIndex);\n      const audioValue = dataArray[circleIndex] / 128.0 * reactivity;\n      const radius = baseRadius * (c + 1) / circleCount * audioValue;\n      ctx.beginPath();\n      ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);\n      ctx.strokeStyle = adjustColor(color, c / circleCount * 50);\n      ctx.stroke();\n    }\n  };\n  const drawKaleidoscope = (ctx, dataArray, timeArray, bufferLength, cachedParameters) => {\n    // Safety check - ensure canvas reference exists\n    if (!canvasRef.current) {\n      console.error(\"Canvas reference is null in drawKaleidoscope\");\n      return;\n    }\n\n    // Apply parameters\n    const color = cachedParameters.color || '#ffaa00';\n    const segments = cachedParameters.segments || 8;\n    const speed = (cachedParameters.speed || 50) / 2000; // Reduced speed for slower rotation\n    const reactivity = (cachedParameters.reactivity || 50) / 40; // Adjusted for better responsiveness\n\n    const centerX = canvasRef.current.width / 2;\n    const centerY = canvasRef.current.height / 2;\n    const radius = Math.min(centerX, centerY) * 0.8;\n\n    // Rotate based on time and speed\n    ctx.translate(centerX, centerY);\n    ctx.rotate(timeRef.current * speed);\n\n    // Draw kaleidoscope segments\n    for (let s = 0; s < segments; s++) {\n      ctx.rotate(Math.PI * 2 / segments);\n      ctx.beginPath();\n      ctx.strokeStyle = adjustColor(color, s * 5);\n\n      // Draw audio-reactive pattern\n      // Use fewer points for better performance\n      const step = Math.max(8, Math.floor(bufferLength / 64));\n      for (let i = 0; i < bufferLength; i += step) {\n        // Focus on lower frequencies which typically contain more rhythm information\n        const dataIndex = Math.min(bufferLength - 1, Math.floor(Math.pow(i / bufferLength, 0.7) * bufferLength));\n        const x = dataArray[dataIndex] / 256.0 * radius * reactivity;\n        const y = timeArray[dataIndex] / 256.0 * radius * reactivity;\n        if (i === 0) {\n          ctx.moveTo(x, y);\n        } else {\n          ctx.lineTo(x, y);\n        }\n      }\n      ctx.stroke();\n    }\n\n    // Reset transformation\n    ctx.setTransform(1, 0, 0, 1, 0, 0);\n  };\n  const drawSpiral = (ctx, dataArray, timeArray, bufferLength, cachedParameters) => {\n    // Safety check - ensure canvas reference exists\n    if (!canvasRef.current) {\n      console.error(\"Canvas reference is null in drawSpiral\");\n      return;\n    }\n\n    // Apply parameters\n    const color = cachedParameters.color || '#00ff99';\n    const arms = cachedParameters.arms || 5;\n    const speed = (cachedParameters.speed || 50) / 2000; // Reduced speed for slower rotation\n    const reactivity = (cachedParameters.reactivity || 50) / 40; // Adjusted for better responsiveness\n\n    const centerX = canvasRef.current.width / 2;\n    const centerY = canvasRef.current.height / 2;\n    const maxRadius = Math.min(centerX, centerY) * 0.9;\n\n    // Rotate based on time and speed\n    ctx.translate(centerX, centerY);\n    ctx.rotate(timeRef.current * speed);\n\n    // Pre-calculate common values\n    const PI2 = Math.PI * 2;\n    const PI6 = Math.PI * 6;\n\n    // Pre-calculate arm colors to avoid recalculating in the loop\n    const armColors = [];\n    for (let a = 0; a < arms; a++) {\n      armColors[a] = adjustColor(color, a * 10);\n    }\n\n    // Draw spiral arms\n    for (let a = 0; a < arms; a++) {\n      const armAngle = a / arms * PI2;\n      ctx.beginPath();\n      ctx.strokeStyle = armColors[a];\n\n      // Use a more efficient approach for drawing the spiral\n      // but maintain the original visual appearance with 100 points\n      const pointsPerArm = 100;\n\n      // Sample audio data less frequently for performance\n      const sampleStep = Math.max(1, Math.floor(bufferLength / 128));\n      for (let i = 0; i < pointsPerArm; i++) {\n        const t = i / pointsPerArm;\n        const angle = armAngle + t * PI6;\n        const radius = t * maxRadius;\n\n        // Apply audio reactivity - use a more efficient data sampling approach\n        // Focus on lower frequencies which typically contain more rhythm information\n        const freqIndex = Math.min(bufferLength - 1, Math.floor(t * bufferLength / 4));\n        const dataIndex = Math.min(bufferLength - 1, freqIndex);\n        const audioValue = dataArray[dataIndex] / 128.0 * reactivity;\n\n        // Pre-calculate trig functions for performance\n        const cosAngle = Math.cos(angle);\n        const sinAngle = Math.sin(angle);\n        const x = cosAngle * radius * audioValue;\n        const y = sinAngle * radius * audioValue;\n        if (i === 0) {\n          ctx.moveTo(x, y);\n        } else {\n          ctx.lineTo(x, y);\n        }\n      }\n      ctx.stroke();\n    }\n\n    // Reset transformation\n    ctx.setTransform(1, 0, 0, 1, 0, 0);\n  };\n\n  // Add a new ripple visualization\n  const drawRipples = (ctx, dataArray, timeArray, bufferLength, cachedParameters) => {\n    // Safety check - ensure canvas reference exists\n    if (!canvasRef.current) {\n      console.error(\"Canvas reference is null in drawRipples\");\n      return;\n    }\n\n    // Apply parameters\n    const color = cachedParameters.color || '#00ffff';\n    const reactivity = (cachedParameters.reactivity || 50) / 40;\n    const speed = (cachedParameters.speed || 50) / 50;\n    const density = (cachedParameters.density || 50) / 50;\n    const width = canvasRef.current.width;\n    const height = canvasRef.current.height;\n    const centerX = width / 2;\n    const centerY = height / 2;\n    const maxRadius = Math.sqrt(width * width + height * height) / 2;\n\n    // Initialize ripples array if it doesn't exist\n    if (!window.ripples) {\n      window.ripples = [];\n    }\n\n    // Detect beats for creating new ripples\n    let bassEnergy = 0;\n    for (let i = 0; i < 8; i++) {\n      bassEnergy += dataArray[i];\n    }\n    bassEnergy = bassEnergy / (8 * 255);\n\n    // Create new ripple on strong beats\n    if (bassEnergy > 0.6 && Math.random() < 0.3 * density) {\n      // Get a frequency band for this ripple's color\n      const freqBand = Math.floor(Math.random() * (bufferLength / 4));\n      const freqIntensity = dataArray[freqBand] / 255;\n\n      // Create a new ripple\n      window.ripples.push({\n        radius: 0,\n        maxRadius: maxRadius * (0.3 + Math.random() * 0.7),\n        lineWidth: 1 + Math.random() * 4,\n        alpha: 0.7 + Math.random() * 0.3,\n        speed: (0.5 + Math.random() * 1.5) * speed,\n        color: adjustColor(color, freqIntensity * 50 - 25)\n      });\n    }\n\n    // Draw and update ripples\n    for (let i = 0; i < window.ripples.length; i++) {\n      const ripple = window.ripples[i];\n\n      // Update radius\n      ripple.radius += ripple.speed;\n\n      // Decrease alpha as the ripple expands\n      ripple.alpha *= 0.98;\n\n      // Draw ripple\n      ctx.beginPath();\n      ctx.arc(centerX, centerY, ripple.radius, 0, Math.PI * 2);\n      ctx.strokeStyle = ripple.color;\n      ctx.globalAlpha = ripple.alpha;\n      ctx.lineWidth = ripple.lineWidth;\n      ctx.stroke();\n      ctx.globalAlpha = 1.0;\n    }\n\n    // Remove ripples that have expanded beyond their max radius or faded out\n    window.ripples = window.ripples.filter(ripple => ripple.radius < ripple.maxRadius && ripple.alpha > 0.01);\n  };\n\n  // Add a new terrain visualization\n  const drawTerrain = (ctx, dataArray, timeArray, bufferLength, cachedParameters) => {\n    // Safety check - ensure canvas reference exists\n    if (!canvasRef.current) {\n      console.error(\"Canvas reference is null in drawTerrain\");\n      return;\n    }\n\n    // Apply parameters\n    const color = cachedParameters.color || '#33cc33';\n    const reactivity = (cachedParameters.reactivity || 50) / 40;\n    const detail = (cachedParameters.detail || 50) / 50;\n    const speed = (cachedParameters.speed || 50) / 100;\n    const width = canvasRef.current.width;\n    const height = canvasRef.current.height;\n\n    // Calculate number of terrain points based on detail parameter\n    const points = Math.max(20, Math.floor(width / (10 / detail)));\n    const pointWidth = width / points;\n\n    // Create terrain heights based on audio data\n    const terrainHeights = [];\n\n    // Sample audio data for terrain heights\n    for (let i = 0; i < points; i++) {\n      // Map point index to frequency data index\n      const dataIndex = Math.floor(i / points * (bufferLength / 2));\n\n      // Get audio value and apply reactivity\n      const audioValue = dataArray[dataIndex] / 255.0 * reactivity;\n\n      // Calculate terrain height\n      const terrainHeight = height * 0.1 + audioValue * height * 0.6;\n      terrainHeights.push(terrainHeight);\n    }\n\n    // Smooth terrain heights\n    const smoothedHeights = [];\n    for (let i = 0; i < points; i++) {\n      let sum = 0;\n      let count = 0;\n\n      // Apply smoothing by averaging neighboring points\n      for (let j = Math.max(0, i - 2); j <= Math.min(points - 1, i + 2); j++) {\n        sum += terrainHeights[j];\n        count++;\n      }\n      smoothedHeights.push(sum / count);\n    }\n\n    // Create a gradient for the terrain\n    const gradient = ctx.createLinearGradient(0, height, 0, height / 2);\n    gradient.addColorStop(0, color);\n    gradient.addColorStop(1, adjustColor(color, 30));\n\n    // Draw terrain\n    ctx.fillStyle = gradient;\n    ctx.beginPath();\n    ctx.moveTo(0, height);\n\n    // Draw terrain path\n    for (let i = 0; i < points; i++) {\n      const x = i * pointWidth;\n      const y = height - smoothedHeights[i];\n      if (i === 0) {\n        ctx.lineTo(x, y);\n      } else {\n        // Use quadratic curves for smoother terrain\n        const prevX = (i - 1) * pointWidth;\n        const prevY = height - smoothedHeights[i - 1];\n        const cpX = (prevX + x) / 2;\n        const cpY = (prevY + y) / 2;\n        ctx.quadraticCurveTo(cpX, cpY, x, y);\n      }\n    }\n\n    // Complete the path\n    ctx.lineTo(width, height);\n    ctx.closePath();\n    ctx.fill();\n\n    // Draw a reflection effect\n    ctx.globalAlpha = 0.3;\n    ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';\n\n    // Draw reflection path (inverted terrain)\n    ctx.beginPath();\n    ctx.moveTo(0, height);\n    for (let i = 0; i < points; i++) {\n      const x = i * pointWidth;\n      const terrainY = height - smoothedHeights[i];\n      const reflectionHeight = smoothedHeights[i] * 0.3; // Smaller reflection\n      const y = height + reflectionHeight;\n      if (i === 0) {\n        ctx.lineTo(x, y);\n      } else {\n        // Use quadratic curves for smoother terrain\n        const prevX = (i - 1) * pointWidth;\n        const prevY = height + smoothedHeights[i - 1] * 0.3;\n        const cpX = (prevX + x) / 2;\n        const cpY = (prevY + y) / 2;\n        ctx.quadraticCurveTo(cpX, cpY, x, y);\n      }\n    }\n\n    // Complete the reflection path\n    ctx.lineTo(width, height);\n    ctx.closePath();\n    ctx.fill();\n\n    // Reset alpha\n    ctx.globalAlpha = 1.0;\n\n    // Draw stars in the sky\n    if (!window.stars) {\n      // Initialize stars\n      window.stars = [];\n      const starCount = 50;\n      for (let i = 0; i < starCount; i++) {\n        window.stars.push({\n          x: Math.random() * width,\n          y: Math.random() * height * 0.5,\n          size: 0.5 + Math.random() * 1.5,\n          brightness: 0.3 + Math.random() * 0.7\n        });\n      }\n    }\n\n    // Draw stars with audio reactivity\n    for (let i = 0; i < window.stars.length; i++) {\n      const star = window.stars[i];\n\n      // Make stars twinkle based on audio\n      const dataIndex = Math.floor(Math.random() * (bufferLength / 4));\n      const twinkle = 0.5 + dataArray[dataIndex] / 255.0 * 0.5;\n      ctx.fillStyle = `rgba(255, 255, 255, ${star.brightness * twinkle})`;\n      ctx.beginPath();\n      ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);\n      ctx.fill();\n    }\n  };\n\n  // Add a new starburst visualization\n  const drawStarburst = (ctx, dataArray, timeArray, bufferLength, cachedParameters) => {\n    // Safety check - ensure canvas reference exists\n    if (!canvasRef.current) {\n      console.error(\"Canvas reference is null in drawStarburst\");\n      return;\n    }\n\n    // Apply parameters\n    const color = cachedParameters.color || '#ff9900';\n    const reactivity = (cachedParameters.reactivity || 50) / 40;\n    const particleCount = (cachedParameters.count || 50) / 50 * 100; // 0-100 particles\n    const particleSize = (cachedParameters.size || 50) / 50 * 5; // 0-5 size\n\n    const width = canvasRef.current.width;\n    const height = canvasRef.current.height;\n    const centerX = width / 2;\n    const centerY = height / 2;\n\n    // Initialize particles array if it doesn't exist\n    if (!window.starburstParticles) {\n      window.starburstParticles = [];\n    }\n\n    // Detect beats for creating new bursts\n    let bassEnergy = 0;\n    for (let i = 0; i < 8; i++) {\n      bassEnergy += dataArray[i];\n    }\n    bassEnergy = bassEnergy / (8 * 255);\n\n    // Create new burst on strong beats\n    if (bassEnergy > 0.6 && (window.lastBurstTime === undefined || timeRef.current - window.lastBurstTime > 0.5)) {\n      window.lastBurstTime = timeRef.current;\n\n      // Create a burst of particles\n      const burstSize = Math.floor(particleCount * (0.5 + bassEnergy * 0.5));\n      const burstColor = adjustColor(color, Math.random() * 40 - 20);\n      for (let i = 0; i < burstSize; i++) {\n        const angle = Math.random() * Math.PI * 2;\n        const speed = (1 + Math.random() * 3) * reactivity;\n        const size = (0.5 + Math.random() * 1.5) * particleSize;\n        const life = 1.0; // Full life\n\n        window.starburstParticles.push({\n          x: centerX,\n          y: centerY,\n          vx: Math.cos(angle) * speed,\n          vy: Math.sin(angle) * speed,\n          size: size,\n          color: burstColor,\n          life: life,\n          decay: 0.01 + Math.random() * 0.02 // Random decay rate\n        });\n      }\n    }\n\n    // Clear canvas with fade effect for trails\n    ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';\n    ctx.fillRect(0, 0, width, height);\n\n    // Update and draw particles\n    for (let i = 0; i < window.starburstParticles.length; i++) {\n      const particle = window.starburstParticles[i];\n\n      // Update position\n      particle.x += particle.vx;\n      particle.y += particle.vy;\n\n      // Apply gravity\n      particle.vy += 0.05;\n\n      // Update life\n      particle.life -= particle.decay;\n\n      // Draw particle\n      if (particle.life > 0) {\n        ctx.globalAlpha = particle.life;\n        ctx.fillStyle = particle.color;\n        ctx.beginPath();\n        ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);\n        ctx.fill();\n      }\n    }\n\n    // Reset alpha\n    ctx.globalAlpha = 1.0;\n\n    // Remove dead particles\n    window.starburstParticles = window.starburstParticles.filter(p => p.life > 0);\n  };\n\n  // Add a new fractal tree visualization\n  const drawFractal = (ctx, dataArray, timeArray, bufferLength, cachedParameters) => {\n    // Safety check - ensure canvas reference exists\n    if (!canvasRef.current) {\n      console.error(\"Canvas reference is null in drawFractal\");\n      return;\n    }\n\n    // Apply parameters\n    const color = cachedParameters.color || '#66ff66';\n    const reactivity = (cachedParameters.reactivity || 50) / 40;\n    const complexity = (cachedParameters.complexity || 50) / 50; // 0-1 complexity\n    const variation = (cachedParameters.variation || 50) / 50; // 0-1 variation\n\n    const width = canvasRef.current.width;\n    const height = canvasRef.current.height;\n\n    // Clear canvas\n    ctx.fillStyle = 'rgb(0, 0, 0)';\n    ctx.fillRect(0, 0, width, height);\n\n    // Calculate audio energy for different frequency bands\n    const lowEnergy = getAverageEnergy(dataArray, 0, 10) * reactivity;\n    const midEnergy = getAverageEnergy(dataArray, 10, 100) * reactivity;\n    const highEnergy = getAverageEnergy(dataArray, 100, 200) * reactivity;\n\n    // Calculate overall energy to scale the tree appropriately\n    const overallEnergy = (lowEnergy + midEnergy + highEnergy) / 3;\n\n    // Calculate tree parameters based on audio\n    // Limit trunk length to prevent excessive growth\n    const maxTrunkLength = height * 0.3; // Maximum 30% of screen height\n    const trunkLength = Math.min(maxTrunkLength, height * 0.25 * (0.8 + lowEnergy * 0.3));\n\n    // Limit branch angle to prevent excessive spreading\n    const branchAngle = Math.PI / 6 + midEnergy * Math.PI / 15;\n\n    // Limit branch ratio to prevent excessive growth\n    const branchRatio = Math.min(0.67 + highEnergy * 0.08, 0.75);\n\n    // Calculate max depth based on complexity but cap it to prevent excessive recursion\n    const maxDepth = Math.floor(4 + complexity * 3);\n\n    // Draw tree\n    ctx.strokeStyle = color;\n    ctx.lineWidth = 2;\n\n    // Start tree from bottom center\n    const startX = width / 2;\n    const startY = height * 0.9;\n\n    // Draw trunk\n    ctx.beginPath();\n    ctx.moveTo(startX, startY);\n    ctx.lineTo(startX, startY - trunkLength);\n    ctx.stroke();\n\n    // Draw branches recursively with boundary information\n    drawBranch(ctx, startX, startY - trunkLength, trunkLength, -Math.PI / 2, maxDepth, branchAngle, branchRatio, color, variation, timeRef.current, {\n      width,\n      height,\n      startX,\n      startY\n    } // Pass boundary information\n    );\n\n    // Helper function to calculate average energy in a frequency range\n    function getAverageEnergy(data, startBin, endBin) {\n      let sum = 0;\n      const binCount = Math.min(endBin - startBin, data.length - startBin);\n      if (binCount <= 0) return 0;\n      for (let i = startBin; i < startBin + binCount; i++) {\n        sum += data[i] / 255.0;\n      }\n      return sum / binCount;\n    }\n\n    // Recursive function to draw branches\n    function drawBranch(ctx, x, y, length, angle, depth, branchAngle, branchRatio, color, variation, time, bounds) {\n      if (depth === 0) return;\n\n      // Calculate new branch length\n      const newLength = length * branchRatio;\n\n      // Add some variation based on time, but limit the variation as depth increases\n      const variationScale = Math.max(0, 1 - depth / maxDepth); // Reduce variation for deeper branches\n      const timeVariation = Math.sin(time * 2 + depth) * variation * 0.1 * variationScale;\n\n      // Calculate endpoints for left and right branches\n      const leftAngle = angle - branchAngle + timeVariation;\n      const rightAngle = angle + branchAngle + timeVariation;\n      const leftX = x + Math.cos(leftAngle) * newLength;\n      const leftY = y + Math.sin(leftAngle) * newLength;\n      const rightX = x + Math.cos(rightAngle) * newLength;\n      const rightY = y + Math.sin(rightAngle) * newLength;\n\n      // Check if branches are within screen bounds\n      const leftInBounds = isInBounds(leftX, leftY, bounds);\n      const rightInBounds = isInBounds(rightX, rightY, bounds);\n\n      // Adjust color based on depth\n      const branchColor = adjustColor(color, depth * 10);\n      ctx.strokeStyle = branchColor;\n\n      // Adjust line width based on depth\n      ctx.lineWidth = Math.max(1, 3 - depth * 0.5);\n\n      // Draw left branch if in bounds\n      if (leftInBounds) {\n        ctx.beginPath();\n        ctx.moveTo(x, y);\n        ctx.lineTo(leftX, leftY);\n        ctx.stroke();\n\n        // Recursively draw sub-branches\n        drawBranch(ctx, leftX, leftY, newLength, leftAngle, depth - 1, branchAngle, branchRatio, color, variation, time, bounds);\n      }\n\n      // Draw right branch if in bounds\n      if (rightInBounds) {\n        ctx.beginPath();\n        ctx.moveTo(x, y);\n        ctx.lineTo(rightX, rightY);\n        ctx.stroke();\n\n        // Recursively draw sub-branches\n        drawBranch(ctx, rightX, rightY, newLength, rightAngle, depth - 1, branchAngle, branchRatio, color, variation, time, bounds);\n      }\n    }\n\n    // Helper function to check if a point is within screen bounds with some margin\n    function isInBounds(x, y, bounds) {\n      const margin = 10; // Small margin to prevent drawing right at the edge\n      return x >= margin && x <= bounds.width - margin && y >= margin && y <= bounds.height - margin;\n    }\n  };\n\n  // Add a new liquid wave visualization\n  const drawLiquid = (ctx, dataArray, timeArray, bufferLength, cachedParameters) => {\n    // Safety check - ensure canvas reference exists\n    if (!canvasRef.current) {\n      console.error(\"Canvas reference is null in drawLiquid\");\n      return;\n    }\n\n    // Apply parameters\n    const color = cachedParameters.color || '#0099ff';\n    const reactivity = (cachedParameters.reactivity || 50) / 40;\n    const complexity = (cachedParameters.complexity || 50) / 50; // 0-1 complexity\n    const speed = (cachedParameters.speed || 50) / 50; // 0-1 speed\n\n    const width = canvasRef.current.width;\n    const height = canvasRef.current.height;\n\n    // Initialize wave points if they don't exist\n    if (!window.liquidPoints) {\n      window.liquidPoints = [];\n      const pointCount = Math.floor(20 + complexity * 30); // 20-50 points based on complexity\n\n      for (let i = 0; i < pointCount; i++) {\n        window.liquidPoints.push({\n          x: width * (i / (pointCount - 1)),\n          y: height / 2,\n          vy: 0\n        });\n      }\n    }\n\n    // Ensure we have the right number of points if complexity changes\n    const targetPointCount = Math.floor(20 + complexity * 30);\n    if (window.liquidPoints.length !== targetPointCount) {\n      const newPoints = [];\n      for (let i = 0; i < targetPointCount; i++) {\n        if (i < window.liquidPoints.length) {\n          newPoints.push(window.liquidPoints[i]);\n        } else {\n          newPoints.push({\n            x: width * (i / (targetPointCount - 1)),\n            y: height / 2,\n            vy: 0\n          });\n        }\n      }\n      window.liquidPoints = newPoints;\n    }\n\n    // Clear canvas with gradient background\n    const gradient = ctx.createLinearGradient(0, 0, 0, height);\n    gradient.addColorStop(0, 'rgb(0, 10, 30)');\n    gradient.addColorStop(1, 'rgb(0, 0, 10)');\n    ctx.fillStyle = gradient;\n    ctx.fillRect(0, 0, width, height);\n\n    // Calculate audio energy for different frequency bands\n    const frequencyBands = 8;\n    const energyBands = [];\n    for (let i = 0; i < frequencyBands; i++) {\n      const startBin = Math.floor(i / frequencyBands * (bufferLength / 2));\n      const endBin = Math.floor((i + 1) / frequencyBands * (bufferLength / 2));\n      energyBands.push(getAverageEnergy(dataArray, startBin, endBin) * reactivity);\n    }\n\n    // Update wave points based on audio\n    const pointCount = window.liquidPoints.length;\n    const dampening = 0.95;\n    const tension = 0.025;\n    const timeScale = speed * 0.5;\n\n    // Apply forces to points\n    for (let i = 0; i < pointCount; i++) {\n      const point = window.liquidPoints[i];\n\n      // Determine which frequency band affects this point\n      const bandIndex = Math.floor(i / pointCount * frequencyBands);\n      const energy = energyBands[bandIndex];\n\n      // Apply force based on audio energy\n      point.vy += (Math.random() * 2 - 1) * energy * 2;\n\n      // Apply time-based oscillation\n      const timeOffset = i / pointCount * Math.PI * 2;\n      point.vy += Math.sin(timeRef.current * timeScale + timeOffset) * 0.2;\n\n      // Apply physics\n      point.y += point.vy;\n      point.vy *= dampening;\n\n      // Apply tension to return to center\n      point.vy += (height / 2 - point.y) * tension;\n    }\n\n    // Draw the liquid\n    ctx.fillStyle = color;\n    ctx.beginPath();\n    ctx.moveTo(0, height);\n\n    // Draw first point\n    ctx.lineTo(window.liquidPoints[0].x, window.liquidPoints[0].y);\n\n    // Draw curve through points\n    for (let i = 0; i < pointCount - 1; i++) {\n      const current = window.liquidPoints[i];\n      const next = window.liquidPoints[i + 1];\n\n      // Use quadratic curves for smoother liquid\n      const cpX = (current.x + next.x) / 2;\n      const cpY = (current.y + next.y) / 2;\n      ctx.quadraticCurveTo(current.x, current.y, cpX, cpY);\n    }\n\n    // Draw last point\n    const lastPoint = window.liquidPoints[pointCount - 1];\n    ctx.lineTo(lastPoint.x, lastPoint.y);\n\n    // Complete the path\n    ctx.lineTo(width, height);\n    ctx.closePath();\n    ctx.fill();\n\n    // Add highlights\n    ctx.strokeStyle = adjustColor(color, 30);\n    ctx.lineWidth = 2;\n    ctx.beginPath();\n\n    // Draw curve through points for highlight\n    ctx.moveTo(window.liquidPoints[0].x, window.liquidPoints[0].y);\n    for (let i = 0; i < pointCount - 1; i++) {\n      const current = window.liquidPoints[i];\n      const next = window.liquidPoints[i + 1];\n\n      // Use quadratic curves for smoother liquid\n      const cpX = (current.x + next.x) / 2;\n      const cpY = (current.y + next.y) / 2;\n      ctx.quadraticCurveTo(current.x, current.y, cpX, cpY);\n    }\n\n    // Draw last point for highlight\n    ctx.lineTo(lastPoint.x, lastPoint.y);\n    ctx.stroke();\n\n    // Add bubbles for extra effect\n    if (!window.liquidBubbles) {\n      window.liquidBubbles = [];\n    }\n\n    // Create new bubbles based on audio energy\n    const bassEnergy = energyBands[0];\n    if (Math.random() < bassEnergy * 0.3) {\n      const bubbleX = Math.random() * width;\n      const bubbleSize = 2 + Math.random() * 8;\n      window.liquidBubbles.push({\n        x: bubbleX,\n        y: height,\n        size: bubbleSize,\n        speed: 0.5 + Math.random() * 2,\n        opacity: 0.1 + Math.random() * 0.4\n      });\n    }\n\n    // Update and draw bubbles\n    ctx.fillStyle = adjustColor(color, 50);\n    for (let i = 0; i < window.liquidBubbles.length; i++) {\n      const bubble = window.liquidBubbles[i];\n\n      // Update position\n      bubble.y -= bubble.speed;\n\n      // Draw bubble\n      ctx.globalAlpha = bubble.opacity;\n      ctx.beginPath();\n      ctx.arc(bubble.x, bubble.y, bubble.size, 0, Math.PI * 2);\n      ctx.fill();\n    }\n\n    // Reset alpha\n    ctx.globalAlpha = 1.0;\n\n    // Remove bubbles that have risen to the top\n    window.liquidBubbles = window.liquidBubbles.filter(b => b.y > -b.size);\n\n    // Helper function to calculate average energy in a frequency range\n    function getAverageEnergy(data, startBin, endBin) {\n      let sum = 0;\n      const binCount = Math.min(endBin - startBin, data.length - startBin);\n      if (binCount <= 0) return 0;\n      for (let i = startBin; i < startBin + binCount; i++) {\n        sum += data[i] / 255.0;\n      }\n      return sum / binCount;\n    }\n  };\n\n  // Add a new audio mesh visualization\n  const drawMesh = (ctx, dataArray, timeArray, bufferLength, cachedParameters) => {\n    // Safety check - ensure canvas reference exists\n    if (!canvasRef.current) {\n      console.error(\"Canvas reference is null in drawMesh\");\n      return;\n    }\n\n    // Apply parameters\n    const color = cachedParameters.color || '#ff00cc';\n    const reactivity = (cachedParameters.reactivity || 50) / 40;\n    const density = (cachedParameters.density || 50) / 50; // 0-1 density\n    const perspective = (cachedParameters.perspective || 50) / 50; // 0-1 perspective\n\n    const width = canvasRef.current.width;\n    const height = canvasRef.current.height;\n\n    // Clear canvas with gradient background\n    const gradient = ctx.createLinearGradient(0, 0, 0, height);\n    gradient.addColorStop(0, 'rgb(0, 0, 0)');\n    gradient.addColorStop(1, 'rgb(20, 0, 20)');\n    ctx.fillStyle = gradient;\n    ctx.fillRect(0, 0, width, height);\n\n    // Calculate grid dimensions based on density\n    const gridSize = Math.max(8, Math.floor(8 + density * 16)); // 8-24 grid size\n    const cellWidth = width / gridSize;\n    const cellHeight = height / gridSize;\n\n    // Create perspective projection\n    const focalLength = 400 * perspective;\n    const viewDistance = 200 + 300 * perspective;\n    const eyeZ = -viewDistance;\n\n    // Calculate time-based rotation\n    const rotationX = timeRef.current * 0.1;\n    const rotationY = timeRef.current * 0.15;\n    const rotationZ = timeRef.current * 0.05;\n\n    // Create 3D grid points\n    const grid = [];\n    for (let y = 0; y < gridSize; y++) {\n      const row = [];\n      for (let x = 0; x < gridSize; x++) {\n        // Map grid position to frequency data\n        const freqX = Math.floor(x / gridSize * (bufferLength / 4));\n        const freqY = Math.floor(y / gridSize * (bufferLength / 4));\n        const freqIndex = (freqX + freqY) % (bufferLength / 2);\n\n        // Get audio value and apply reactivity\n        const audioValue = dataArray[freqIndex] / 255.0 * reactivity;\n\n        // Calculate 3D coordinates\n        const xPos = (x - gridSize / 2) * cellWidth * 1.5;\n        const yPos = (y - gridSize / 2) * cellHeight * 1.5;\n        const zPos = audioValue * 100; // Z-axis deformation based on audio\n\n        // Apply 3D rotation\n        const point = rotate3D(xPos, yPos, zPos, rotationX, rotationY, rotationZ);\n\n        // Apply perspective projection\n        const scale = focalLength / (focalLength + point.z - eyeZ);\n        const projX = width / 2 + point.x * scale;\n        const projY = height / 2 + point.y * scale;\n\n        // Store projected point\n        row.push({\n          x: projX,\n          y: projY,\n          z: point.z,\n          scale: scale,\n          value: audioValue\n        });\n      }\n      grid.push(row);\n    }\n\n    // Draw mesh lines\n    ctx.lineWidth = 1;\n\n    // Draw horizontal lines\n    for (let y = 0; y < gridSize; y++) {\n      for (let x = 0; x < gridSize - 1; x++) {\n        const point1 = grid[y][x];\n        const point2 = grid[y][x + 1];\n\n        // Skip lines that would be behind the viewer\n        if (point1.z < eyeZ || point2.z < eyeZ) continue;\n\n        // Calculate line color based on audio value and depth\n        const lineValue = (point1.value + point2.value) / 2;\n        const depthFactor = Math.min(1, Math.max(0, (point1.z + point2.z) / 400 + 0.5));\n        const lineColor = adjustColor(color, depthFactor * 50 - 25);\n\n        // Draw line with opacity based on depth\n        ctx.strokeStyle = lineColor;\n        ctx.globalAlpha = depthFactor * 0.8 + 0.2;\n        ctx.beginPath();\n        ctx.moveTo(point1.x, point1.y);\n        ctx.lineTo(point2.x, point2.y);\n        ctx.stroke();\n      }\n    }\n\n    // Draw vertical lines\n    for (let x = 0; x < gridSize; x++) {\n      for (let y = 0; y < gridSize - 1; y++) {\n        const point1 = grid[y][x];\n        const point2 = grid[y + 1][x];\n\n        // Skip lines that would be behind the viewer\n        if (point1.z < eyeZ || point2.z < eyeZ) continue;\n\n        // Calculate line color based on audio value and depth\n        const lineValue = (point1.value + point2.value) / 2;\n        const depthFactor = Math.min(1, Math.max(0, (point1.z + point2.z) / 400 + 0.5));\n        const lineColor = adjustColor(color, depthFactor * 50 - 25);\n\n        // Draw line with opacity based on depth\n        ctx.strokeStyle = lineColor;\n        ctx.globalAlpha = depthFactor * 0.8 + 0.2;\n        ctx.beginPath();\n        ctx.moveTo(point1.x, point1.y);\n        ctx.lineTo(point2.x, point2.y);\n        ctx.stroke();\n      }\n    }\n\n    // Draw grid points\n    for (let y = 0; y < gridSize; y++) {\n      for (let x = 0; x < gridSize; x++) {\n        const point = grid[y][x];\n\n        // Skip points that would be behind the viewer\n        if (point.z < eyeZ) continue;\n\n        // Calculate point size and color based on audio value and depth\n        const pointSize = 1 + point.value * 3 * point.scale;\n        const depthFactor = Math.min(1, Math.max(0, point.z / 200 + 0.5));\n        const pointColor = adjustColor(color, depthFactor * 60);\n\n        // Draw point with opacity based on depth\n        ctx.fillStyle = pointColor;\n        ctx.globalAlpha = depthFactor * 0.8 + 0.2;\n        ctx.beginPath();\n        ctx.arc(point.x, point.y, pointSize, 0, Math.PI * 2);\n        ctx.fill();\n      }\n    }\n\n    // Reset alpha\n    ctx.globalAlpha = 1.0;\n\n    // Helper function for 3D rotation\n    function rotate3D(x, y, z, rotX, rotY, rotZ) {\n      // Rotate around X axis\n      let y1 = y * Math.cos(rotX) - z * Math.sin(rotX);\n      let z1 = y * Math.sin(rotX) + z * Math.cos(rotX);\n\n      // Rotate around Y axis\n      let x2 = x * Math.cos(rotY) + z1 * Math.sin(rotY);\n      let z2 = -x * Math.sin(rotY) + z1 * Math.cos(rotY);\n\n      // Rotate around Z axis\n      let x3 = x2 * Math.cos(rotZ) - y1 * Math.sin(rotZ);\n      let y3 = x2 * Math.sin(rotZ) + y1 * Math.cos(rotZ);\n      return {\n        x: x3,\n        y: y3,\n        z: z2\n      };\n    }\n  };\n\n  // Add a new spectrum clock visualization\n  const drawClock = (ctx, dataArray, timeArray, bufferLength, cachedParameters) => {\n    // Safety check - ensure canvas reference exists\n    if (!canvasRef.current) {\n      console.error(\"Canvas reference is null in drawClock\");\n      return;\n    }\n\n    // Apply parameters\n    const color = cachedParameters.color || '#ffcc00';\n    const reactivity = (cachedParameters.reactivity || 50) / 40;\n    const detail = (cachedParameters.detail || 50) / 50; // 0-1 detail\n    const speed = (cachedParameters.speed || 50) / 50; // 0-1 speed\n\n    const width = canvasRef.current.width;\n    const height = canvasRef.current.height;\n    const centerX = width / 2;\n    const centerY = height / 2;\n    const radius = Math.min(centerX, centerY) * 0.85;\n\n    // Clear canvas with radial gradient background\n    const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, radius * 1.5);\n    gradient.addColorStop(0, 'rgb(10, 10, 10)');\n    gradient.addColorStop(1, 'rgb(0, 0, 0)');\n    ctx.fillStyle = gradient;\n    ctx.fillRect(0, 0, width, height);\n\n    // Draw clock face\n    ctx.strokeStyle = adjustColor(color, -20);\n    ctx.lineWidth = 2;\n    ctx.beginPath();\n    ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);\n    ctx.stroke();\n\n    // Draw hour markers\n    ctx.fillStyle = color;\n    for (let i = 0; i < 12; i++) {\n      const angle = i / 12 * Math.PI * 2 - Math.PI / 2;\n      const markerRadius = radius * 0.9;\n      const x = centerX + Math.cos(angle) * markerRadius;\n      const y = centerY + Math.sin(angle) * markerRadius;\n      ctx.beginPath();\n      ctx.arc(x, y, 3, 0, Math.PI * 2);\n      ctx.fill();\n    }\n\n    // Calculate frequency bands for clock hands\n    const bandCount = Math.floor(8 + detail * 16); // 8-24 bands\n    const hands = [];\n\n    // Calculate average energy for each frequency band\n    for (let i = 0; i < bandCount; i++) {\n      const startBin = Math.floor(i / bandCount * (bufferLength / 2));\n      const endBin = Math.floor((i + 1) / bandCount * (bufferLength / 2));\n      let sum = 0;\n      for (let j = startBin; j < endBin; j++) {\n        sum += dataArray[j] / 255.0;\n      }\n      const avgEnergy = sum / (endBin - startBin) * reactivity;\n\n      // Calculate hand properties\n      const baseLength = radius * (0.3 + i / bandCount * 0.6); // Shorter to longer\n      const length = baseLength * (0.5 + avgEnergy * 0.5); // Extend based on energy\n      const width = 1 + (bandCount - i) / bandCount * 4; // Thicker to thinner\n      const speed = 0.2 + i / bandCount * 0.8; // Slower to faster\n      const angle = i / bandCount * Math.PI * 2 + timeRef.current * speed * speed;\n      hands.push({\n        angle: angle,\n        length: length,\n        width: width,\n        energy: avgEnergy,\n        hue: i / bandCount * 360\n      });\n    }\n\n    // Draw clock hands\n    for (let i = 0; i < hands.length; i++) {\n      const hand = hands[i];\n\n      // Calculate hand position\n      const endX = centerX + Math.cos(hand.angle) * hand.length;\n      const endY = centerY + Math.sin(hand.angle) * hand.length;\n\n      // Create gradient for hand\n      const gradient = ctx.createLinearGradient(centerX, centerY, endX, endY);\n      gradient.addColorStop(0, adjustColor(color, -30));\n      gradient.addColorStop(1, adjustColor(color, hand.energy * 50));\n\n      // Draw hand\n      ctx.strokeStyle = gradient;\n      ctx.lineWidth = hand.width;\n      ctx.beginPath();\n      ctx.moveTo(centerX, centerY);\n      ctx.lineTo(endX, endY);\n      ctx.stroke();\n\n      // Draw hand endpoint\n      ctx.fillStyle = adjustColor(color, hand.energy * 70);\n      ctx.beginPath();\n      ctx.arc(endX, endY, hand.width * 0.8, 0, Math.PI * 2);\n      ctx.fill();\n    }\n\n    // Draw center circle\n    const centerGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, 10);\n    centerGradient.addColorStop(0, color);\n    centerGradient.addColorStop(1, adjustColor(color, -20));\n    ctx.fillStyle = centerGradient;\n    ctx.beginPath();\n    ctx.arc(centerX, centerY, 8, 0, Math.PI * 2);\n    ctx.fill();\n\n    // Draw frequency spectrum around the clock\n    ctx.lineWidth = 1;\n    ctx.strokeStyle = adjustColor(color, 10);\n    ctx.beginPath();\n    const spectrumRadius = radius * 1.1;\n    const spectrumWidth = radius * 0.1;\n    for (let i = 0; i < bufferLength / 4; i++) {\n      const angle = i / (bufferLength / 4) * Math.PI * 2 - Math.PI / 2;\n      const value = dataArray[i] / 255.0 * reactivity;\n      const innerRadius = spectrumRadius;\n      const outerRadius = spectrumRadius + value * spectrumWidth;\n      const x1 = centerX + Math.cos(angle) * innerRadius;\n      const y1 = centerY + Math.sin(angle) * innerRadius;\n      const x2 = centerX + Math.cos(angle) * outerRadius;\n      const y2 = centerY + Math.sin(angle) * outerRadius;\n      if (i === 0) {\n        ctx.moveTo(x2, y2);\n      } else {\n        ctx.lineTo(x2, y2);\n      }\n    }\n\n    // Close the spectrum path\n    ctx.closePath();\n    ctx.stroke();\n\n    // Fill the spectrum with a gradient\n    const spectrumGradient = ctx.createRadialGradient(centerX, centerY, spectrumRadius, centerX, centerY, spectrumRadius + spectrumWidth);\n    spectrumGradient.addColorStop(0, 'rgba(0, 0, 0, 0)');\n    const adjustedColor = adjustColor(color, 20);\n    spectrumGradient.addColorStop(1, adjustedColor.slice(0, 7) + '33'); // 20% opacity\n\n    ctx.fillStyle = spectrumGradient;\n    ctx.fill();\n  };\n  const drawNebula = (ctx, dataArray, timeArray, bufferLength, cachedParameters) => {\n    // Safety check - ensure canvas reference exists\n    if (!canvasRef.current) {\n      console.error(\"Canvas reference is null in drawNebula\");\n      return;\n    }\n\n    // Apply parameters\n    const color = cachedParameters.color || '#4b0082'; // Deep purple default\n    const reactivity = (cachedParameters.reactivity || 50) / 50; // 0-1 reactivity\n    const complexity = (cachedParameters.complexity || 50) / 50; // 0-1 complexity\n    const speed = (cachedParameters.speed || 50) / 100; // 0-0.5 speed\n\n    const width = canvasRef.current.width;\n    const height = canvasRef.current.height;\n    const centerX = width / 2;\n    const centerY = height / 2;\n\n    // Create a dark background with subtle gradient\n    const bgGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, Math.max(width, height));\n    bgGradient.addColorStop(0, 'rgba(5, 0, 10, 1)');\n    bgGradient.addColorStop(1, 'rgba(0, 0, 5, 1)');\n    ctx.fillStyle = bgGradient;\n    ctx.fillRect(0, 0, width, height);\n\n    // Calculate average energy in different frequency bands\n    const bassEnergy = getAverageEnergy(dataArray, 0, Math.floor(bufferLength * 0.1)) * reactivity;\n    const midEnergy = getAverageEnergy(dataArray, Math.floor(bufferLength * 0.1), Math.floor(bufferLength * 0.5)) * reactivity;\n    const highEnergy = getAverageEnergy(dataArray, Math.floor(bufferLength * 0.5), bufferLength) * reactivity;\n\n    // Core size based on bass energy\n    const coreSize = 50 + bassEnergy * 100;\n\n    // Draw nebula core\n    const coreGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, coreSize);\n    coreGradient.addColorStop(0, adjustColor(color, 50));\n    coreGradient.addColorStop(0.6, adjustColor(color, 20));\n    coreGradient.addColorStop(1, 'rgba(0, 0, 0, 0)');\n    ctx.globalCompositeOperation = 'lighter';\n    ctx.fillStyle = coreGradient;\n    ctx.beginPath();\n    ctx.arc(centerX, centerY, coreSize, 0, Math.PI * 2);\n    ctx.fill();\n\n    // Number of wisps based on complexity\n    const wispCount = Math.floor(10 + complexity * 30);\n\n    // Draw nebula wisps\n    for (let i = 0; i < wispCount; i++) {\n      // Use different frequency bands to affect different wisps\n      const energyFactor = i < wispCount / 3 ? bassEnergy : i < wispCount * 2 / 3 ? midEnergy : highEnergy;\n\n      // Base angle for this wisp\n      const baseAngle = i / wispCount * Math.PI * 2;\n      // Rotation based on time\n      const rotation = timeRef.current * speed * (1 + i % 3 * 0.2);\n      const angle = baseAngle + rotation;\n\n      // Wisp length based on energy\n      const length = 100 + energyFactor * 200 + Math.sin(timeRef.current + i) * 50;\n\n      // Wisp width varies\n      const width = 20 + i % 5 * 10 + energyFactor * 30;\n\n      // Wisp starting point (from core edge)\n      const startX = centerX + Math.cos(angle) * coreSize * 0.8;\n      const startY = centerY + Math.sin(angle) * coreSize * 0.8;\n\n      // Wisp end point\n      const endX = centerX + Math.cos(angle) * (coreSize + length);\n      const endY = centerY + Math.sin(angle) * (coreSize + length);\n\n      // Control points for curved wisp\n      const ctrlX1 = centerX + Math.cos(angle + 0.2) * (coreSize + length * 0.3);\n      const ctrlY1 = centerY + Math.sin(angle + 0.2) * (coreSize + length * 0.3);\n      const ctrlX2 = centerX + Math.cos(angle - 0.2) * (coreSize + length * 0.6);\n      const ctrlY2 = centerY + Math.sin(angle - 0.2) * (coreSize + length * 0.6);\n\n      // Wisp color based on position in spectrum\n      const hue = i / wispCount * 60 + 240; // Blue to purple range\n      const wispColor = `hsla(${hue}, 100%, ${50 + energyFactor * 30}%, ${0.2 + energyFactor * 0.3})`;\n\n      // Draw the wisp as a gradient along a bezier curve\n      const gradient = ctx.createLinearGradient(startX, startY, endX, endY);\n      gradient.addColorStop(0, adjustColor(color, 20) + '80'); // Semi-transparent\n      gradient.addColorStop(0.5, wispColor);\n      gradient.addColorStop(1, 'rgba(0, 0, 0, 0)'); // Fade out\n\n      ctx.strokeStyle = gradient;\n      ctx.lineWidth = width;\n      ctx.lineCap = 'round';\n\n      // Draw curved wisp\n      ctx.beginPath();\n      ctx.moveTo(startX, startY);\n      ctx.bezierCurveTo(ctrlX1, ctrlY1, ctrlX2, ctrlY2, endX, endY);\n      ctx.stroke();\n    }\n\n    // Add some stars in the background\n    const starCount = 100;\n    ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';\n    for (let i = 0; i < starCount; i++) {\n      // Star position based on index but with some variation over time\n      const angle = i / starCount * Math.PI * 2 + timeRef.current * 0.01;\n      const distance = 100 + i % 10 * 50 + Math.sin(timeRef.current * 0.2 + i) * 20;\n      const x = centerX + Math.cos(angle) * distance;\n      const y = centerY + Math.sin(angle) * distance;\n\n      // Star size pulsates with high frequencies\n      const size = 1 + dataArray[Math.floor(i / starCount * bufferLength)] / 255 * 2;\n      ctx.beginPath();\n      ctx.arc(x, y, size, 0, Math.PI * 2);\n      ctx.fill();\n    }\n\n    // Reset composite operation\n    ctx.globalCompositeOperation = 'source-over';\n  };\n  const drawCityscape = (ctx, dataArray, timeArray, bufferLength, cachedParameters) => {\n    // Safety check - ensure canvas reference exists\n    if (!canvasRef.current) {\n      console.error(\"Canvas reference is null in drawCityscape\");\n      return;\n    }\n\n    // Apply parameters\n    const color = cachedParameters.color || '#ff9900'; // Orange default\n    const reactivity = (cachedParameters.reactivity || 50) / 50; // 0-1 reactivity\n    const density = (cachedParameters.density || 50) / 50; // 0-1 density\n    const detail = (cachedParameters.detail || 50) / 50; // 0-1 detail\n\n    const width = canvasRef.current.width;\n    const height = canvasRef.current.height;\n\n    // Define maxHeight at the top level of the function\n    const maxHeight = height * 0.7; // Max 70% of screen height\n\n    // Create night sky gradient background\n    const skyGradient = ctx.createLinearGradient(0, 0, 0, height);\n    skyGradient.addColorStop(0, 'rgb(0, 5, 20)');\n    skyGradient.addColorStop(1, 'rgb(20, 10, 40)');\n    ctx.fillStyle = skyGradient;\n    ctx.fillRect(0, 0, width, height);\n\n    // Add stars to the sky\n    const starCount = Math.floor(100 * detail);\n    ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';\n    for (let i = 0; i < starCount; i++) {\n      const x = Math.random() * width;\n      const y = Math.random() * height * 0.6; // Stars only in top 60% (sky)\n      const size = Math.random() * 2 + 0.5;\n\n      // Make stars twinkle based on high frequencies\n      const twinkle = 0.5 + dataArray[Math.floor(bufferLength * 0.8 + i % 20)] / 255 * 0.5;\n      ctx.globalAlpha = twinkle;\n      ctx.beginPath();\n      ctx.arc(x, y, size, 0, Math.PI * 2);\n      ctx.fill();\n    }\n    ctx.globalAlpha = 1.0;\n\n    // Add a moon\n    const moonX = width * 0.8;\n    const moonY = height * 0.2;\n    const moonSize = width * 0.05;\n    const moonGlow = ctx.createRadialGradient(moonX, moonY, 0, moonX, moonY, moonSize * 2);\n    moonGlow.addColorStop(0, 'rgba(255, 255, 230, 1)');\n    moonGlow.addColorStop(0.5, 'rgba(255, 255, 230, 0.3)');\n    moonGlow.addColorStop(1, 'rgba(255, 255, 230, 0)');\n    ctx.fillStyle = moonGlow;\n    ctx.beginPath();\n    ctx.arc(moonX, moonY, moonSize * 2, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.fillStyle = 'rgba(255, 255, 230, 1)';\n    ctx.beginPath();\n    ctx.arc(moonX, moonY, moonSize, 0, Math.PI * 2);\n    ctx.fill();\n\n    // Calculate frequency bands for buildings\n    const bandCount = Math.floor(20 + density * 60); // 20-80 buildings\n    const buildings = [];\n\n    // Calculate average energy for each frequency band\n    for (let i = 0; i < bandCount; i++) {\n      const startBin = Math.floor(i / bandCount * (bufferLength / 2));\n      const endBin = Math.floor((i + 1) / bandCount * (bufferLength / 2));\n      const energy = getAverageEnergy(dataArray, startBin, endBin) * reactivity;\n\n      // Building properties\n      const buildingWidth = width / bandCount;\n      // maxHeight is now defined at the top level\n      const buildingHeight = (0.1 + energy * 0.9) * maxHeight; // Min 10% height\n\n      // Building position\n      const x = i * buildingWidth;\n      const y = height - buildingHeight;\n\n      // Building color based on height (taller = brighter)\n      const brightness = 20 + buildingHeight / maxHeight * 60;\n      const buildingColor = adjustColor(color, brightness - 40);\n      buildings.push({\n        x,\n        y,\n        width: buildingWidth,\n        height: buildingHeight,\n        color: buildingColor,\n        energy\n      });\n    }\n\n    // Draw buildings from back to front\n    buildings.forEach((building, i) => {\n      // Draw main building shape\n      ctx.fillStyle = building.color;\n      ctx.fillRect(building.x, building.y, building.width, building.height);\n\n      // Add building details based on detail parameter\n      if (detail > 0.3) {\n        // Add windows\n        const windowSize = Math.max(3, building.width * 0.15);\n        const windowSpacing = windowSize * 1.5;\n        const windowsPerRow = Math.floor(building.width / windowSpacing);\n        const windowsPerColumn = Math.floor(building.height / windowSpacing);\n\n        // Window color based on energy (more energy = more lit windows)\n        const windowAlpha = 0.3 + building.energy * 0.7;\n        const windowColor = `rgba(255, 255, 200, ${windowAlpha})`;\n        ctx.fillStyle = windowColor;\n        for (let row = 0; row < windowsPerColumn; row++) {\n          for (let col = 0; col < windowsPerRow; col++) {\n            // Randomly light up windows based on energy\n            if (Math.random() < 0.2 + building.energy * 0.8) {\n              const windowX = building.x + col * windowSpacing + (windowSpacing - windowSize) / 2;\n              const windowY = building.y + row * windowSpacing + (windowSpacing - windowSize) / 2;\n              ctx.fillRect(windowX, windowY, windowSize, windowSize);\n            }\n          }\n        }\n\n        // Add building top details for taller buildings\n        if (building.height > maxHeight * 0.4 && detail > 0.6) {\n          // Antenna or spire\n          ctx.strokeStyle = 'rgba(100, 100, 100, 0.7)';\n          ctx.lineWidth = 2;\n          ctx.beginPath();\n          const antennaX = building.x + building.width / 2;\n          const antennaHeight = building.height * 0.2;\n          ctx.moveTo(antennaX, building.y);\n          ctx.lineTo(antennaX, building.y - antennaHeight);\n          ctx.stroke();\n\n          // Blinking light on top that pulses with beat\n          const beatEnergy = getAverageEnergy(dataArray, 0, 10) * reactivity;\n          if (beatEnergy > 0.7 || Math.sin(timeRef.current * 2) > 0.7) {\n            ctx.fillStyle = 'rgba(255, 0, 0, 0.8)';\n            ctx.beginPath();\n            ctx.arc(antennaX, building.y - antennaHeight, 3, 0, Math.PI * 2);\n            ctx.fill();\n          }\n        }\n      }\n    });\n\n    // Add foreground silhouette\n    const foregroundHeight = height * 0.05;\n    ctx.fillStyle = 'rgb(0, 0, 0)';\n    ctx.fillRect(0, height - foregroundHeight, width, foregroundHeight);\n  };\n  const drawWaterfall = (ctx, dataArray, timeArray, bufferLength, cachedParameters) => {\n    // Safety check - ensure canvas reference exists\n    if (!canvasRef.current) {\n      console.error(\"Canvas reference is null in drawWaterfall\");\n      return;\n    }\n\n    // Apply parameters\n    const color = cachedParameters.color || '#00ccff'; // Cyan default\n    const reactivity = (cachedParameters.reactivity || 50) / 50; // 0-1 reactivity\n    const speed = (cachedParameters.speed || 50) / 50; // 0-1 speed\n    const detail = (cachedParameters.detail || 50) / 50; // 0-1 detail\n\n    const width = canvasRef.current.width;\n    const height = canvasRef.current.height;\n\n    // Initialize waterfall history if it doesn't exist\n    if (!window.waterfallHistory) {\n      window.waterfallHistory = [];\n      for (let i = 0; i < height; i++) {\n        window.waterfallHistory.push(new Uint8Array(bufferLength));\n      }\n    }\n\n    // Update waterfall history - shift all rows down\n    if (Math.random() < speed * 0.2 + 0.1) {\n      // Control speed of waterfall\n      for (let i = window.waterfallHistory.length - 1; i > 0; i--) {\n        window.waterfallHistory[i] = window.waterfallHistory[i - 1];\n      }\n\n      // Add new data at the top\n      window.waterfallHistory[0] = new Uint8Array(dataArray);\n    }\n\n    // Create a dark blue background\n    const bgGradient = ctx.createLinearGradient(0, 0, 0, height);\n    bgGradient.addColorStop(0, 'rgb(0, 10, 30)');\n    bgGradient.addColorStop(1, 'rgb(0, 5, 15)');\n    ctx.fillStyle = bgGradient;\n    ctx.fillRect(0, 0, width, height);\n\n    // Draw the waterfall\n    const barWidth = width / bufferLength;\n    const barCount = Math.min(bufferLength, Math.floor(width / 2)); // Limit for performance\n    const skipFactor = Math.floor(bufferLength / barCount);\n\n    // Draw each row of the waterfall\n    for (let row = 0; row < window.waterfallHistory.length; row++) {\n      const rowData = window.waterfallHistory[row];\n      for (let i = 0; i < barCount; i++) {\n        const dataIndex = i * skipFactor;\n        const value = rowData[dataIndex] / 255.0 * reactivity;\n        if (value < 0.05) continue; // Skip very low values for performance\n\n        // Calculate position\n        const x = i * barWidth * skipFactor;\n        const y = row;\n\n        // Color based on frequency and intensity\n        const hue = i / barCount * 180 + 180; // Blue to cyan range\n        const saturation = 80 + value * 20;\n        const lightness = value * 60;\n        const alpha = 0.3 + value * 0.7;\n        ctx.fillStyle = `hsla(${hue}, ${saturation}%, ${lightness}%, ${alpha})`;\n        ctx.fillRect(x, y, barWidth * skipFactor, 1);\n      }\n    }\n\n    // Draw water surface at the top with reflection\n    const surfaceY = 50;\n    ctx.fillStyle = 'rgba(0, 150, 255, 0.2)';\n    ctx.fillRect(0, 0, width, surfaceY);\n\n    // Draw ripples on the surface based on bass frequencies\n    const rippleCount = Math.floor(5 + detail * 15);\n    const bassEnergy = getAverageEnergy(dataArray, 0, Math.floor(bufferLength * 0.1)) * reactivity;\n    ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';\n    ctx.lineWidth = 1;\n    for (let i = 0; i < rippleCount; i++) {\n      if (Math.random() > bassEnergy * 0.5) continue;\n      const x = Math.random() * width;\n      const y = Math.random() * surfaceY;\n      const size = 5 + Math.random() * 20 * bassEnergy;\n      ctx.beginPath();\n      ctx.arc(x, y, size, 0, Math.PI * 2);\n      ctx.stroke();\n\n      // Smaller inner ripple\n      ctx.beginPath();\n      ctx.arc(x, y, size * 0.7, 0, Math.PI * 2);\n      ctx.stroke();\n    }\n\n    // Draw splashes when bass hits are detected\n    if (bassEnergy > 0.7) {\n      const splashCount = Math.floor(bassEnergy * 10);\n      for (let i = 0; i < splashCount; i++) {\n        // Create splash particles\n        const x = Math.random() * width;\n        const particleCount = Math.floor(5 + Math.random() * 10);\n        ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';\n        for (let j = 0; j < particleCount; j++) {\n          const particleX = x + (Math.random() - 0.5) * 40;\n          const particleY = Math.random() * 30;\n          const size = 1 + Math.random() * 3;\n          ctx.beginPath();\n          ctx.arc(particleX, particleY, size, 0, Math.PI * 2);\n          ctx.fill();\n        }\n      }\n    }\n\n    // Draw waterfall edge highlights\n    const edgeGradient = ctx.createLinearGradient(0, surfaceY, 0, height);\n    edgeGradient.addColorStop(0, 'rgba(255, 255, 255, 0.4)');\n    edgeGradient.addColorStop(0.1, 'rgba(255, 255, 255, 0.1)');\n    edgeGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');\n    ctx.fillStyle = edgeGradient;\n    ctx.fillRect(0, surfaceY, 10, height - surfaceY); // Left edge\n    ctx.fillRect(width - 10, surfaceY, 10, height - surfaceY); // Right edge\n\n    // Draw mist at the bottom\n    const mistGradient = ctx.createLinearGradient(0, height - 100, 0, height);\n    mistGradient.addColorStop(0, 'rgba(255, 255, 255, 0)');\n    mistGradient.addColorStop(1, 'rgba(255, 255, 255, 0.2)');\n    ctx.fillStyle = mistGradient;\n    ctx.fillRect(0, height - 100, width, 100);\n  };\n  const drawConstellation = (ctx, dataArray, timeArray, bufferLength, cachedParameters) => {\n    // Safety check - ensure canvas reference exists\n    if (!canvasRef.current) {\n      console.error(\"Canvas reference is null in drawConstellation\");\n      return;\n    }\n\n    // Apply parameters\n    const color = cachedParameters.color || '#ffffff'; // White default\n    const reactivity = (cachedParameters.reactivity || 50) / 50; // 0-1 reactivity\n    const density = (cachedParameters.density || 50) / 50; // 0-1 density\n    const speed = (cachedParameters.speed || 50) / 100; // 0-0.5 speed\n\n    const width = canvasRef.current.width;\n    const height = canvasRef.current.height;\n\n    // Create a dark space background\n    const bgGradient = ctx.createRadialGradient(width / 2, height / 2, 0, width / 2, height / 2, Math.max(width, height));\n    bgGradient.addColorStop(0, 'rgb(10, 10, 30)');\n    bgGradient.addColorStop(1, 'rgb(0, 0, 10)');\n    ctx.fillStyle = bgGradient;\n    ctx.fillRect(0, 0, width, height);\n\n    // Calculate overall audio energy for dynamic connection behavior\n    let overallEnergy = 0;\n    const sampleSize = Math.min(bufferLength, 100); // Sample a portion of the frequency data\n    for (let i = 0; i < sampleSize; i++) {\n      overallEnergy += dataArray[i] / 255.0;\n    }\n    overallEnergy = overallEnergy / sampleSize * reactivity;\n\n    // Initialize stars if they don't exist\n    if (!window.constellationStars) {\n      window.constellationStars = [];\n      const starCount = Math.floor(50 + density * 150); // 50-200 stars\n\n      for (let i = 0; i < starCount; i++) {\n        // Assign each star to a frequency band\n        const freqBand = Math.floor(Math.random() * bufferLength);\n        window.constellationStars.push({\n          x: Math.random() * width,\n          y: Math.random() * height,\n          size: 1 + Math.random() * 3,\n          brightness: 0.3 + Math.random() * 0.7,\n          freqBand: freqBand,\n          hue: Math.random() * 60 + 180,\n          // Blue to cyan range\n          connections: []\n        });\n      }\n    }\n\n    // Update star positions slightly based on time\n    const stars = window.constellationStars;\n    const rotationCenter = {\n      x: width / 2,\n      y: height / 2\n    };\n    // Reduce rotation speed significantly (5x slower)\n    const rotationSpeed = speed * 0.002; // Changed from 0.01 to 0.002\n\n    for (let i = 0; i < stars.length; i++) {\n      const star = stars[i];\n\n      // Calculate distance from center\n      const dx = star.x - rotationCenter.x;\n      const dy = star.y - rotationCenter.y;\n      const distance = Math.sqrt(dx * dx + dy * dy);\n\n      // Calculate rotation angle (further stars rotate slower)\n      const rotationFactor = 1 - distance / Math.max(width, height);\n      const angle = rotationSpeed * rotationFactor;\n\n      // Apply rotation\n      const cos = Math.cos(angle);\n      const sin = Math.sin(angle);\n      const newX = rotationCenter.x + (dx * cos - dy * sin);\n      const newY = rotationCenter.y + (dx * sin + dy * cos);\n\n      // Keep stars within bounds\n      star.x = Math.max(0, Math.min(width, newX));\n      star.y = Math.max(0, Math.min(height, newY));\n\n      // Update star brightness based on its frequency band\n      const freqValue = dataArray[star.freqBand] / 255.0;\n      star.brightness = 0.3 + freqValue * reactivity * 0.7;\n    }\n\n    // Find connections between stars based on audio patterns\n    // Adjust max connections based on overall energy - more connections when music is louder\n    const baseMaxConnections = Math.floor(density * 100);\n    const maxConnections = Math.floor(baseMaxConnections * (1 + overallEnergy));\n\n    // Adjust connection threshold based on energy - allow longer connections when music is louder\n    const baseConnectionThreshold = 150 * (1 - density * 0.5);\n    const connectionThreshold = baseConnectionThreshold * (1 + overallEnergy * 0.5);\n\n    // Clear previous connections\n    stars.forEach(star => star.connections = []);\n\n    // Find new connections\n    let connectionCount = 0;\n\n    // Detect beats for connection triggers\n    const bassEnergy = getAverageEnergy(dataArray, 0, Math.floor(bufferLength * 0.1)) * reactivity;\n    const midEnergy = getAverageEnergy(dataArray, Math.floor(bufferLength * 0.1), Math.floor(bufferLength * 0.5)) * reactivity;\n    const beatDetected = bassEnergy > 0.6 || midEnergy > 0.7;\n    for (let i = 0; i < stars.length && connectionCount < maxConnections; i++) {\n      const star1 = stars[i];\n      for (let j = i + 1; j < stars.length && connectionCount < maxConnections; j++) {\n        const star2 = stars[j];\n\n        // Calculate distance between stars\n        const dx = star1.x - star2.x;\n        const dy = star1.y - star2.y;\n        const distance = Math.sqrt(dx * dx + dy * dy);\n\n        // Connect stars if they're close enough and their frequencies are related\n        const freqDiff = Math.abs(star1.freqBand - star2.freqBand);\n\n        // More sophisticated rhythm pattern detection\n        const rhythmicPattern = beatDetected || timeRef.current * 2 % 1 < 0.3 + overallEnergy * 0.4;\n\n        // Lower connection threshold when beat is detected\n        const effectiveThreshold = beatDetected ? connectionThreshold * 1.3 : connectionThreshold;\n        if (distance < effectiveThreshold && (freqDiff < 10 || freqDiff > bufferLength - 10 || rhythmicPattern)) {\n          // Calculate connection strength based on audio energy\n          const freqAvg = (dataArray[star1.freqBand] + dataArray[star2.freqBand]) / (2 * 255);\n\n          // Increase strength during beats\n          const strengthMultiplier = beatDetected ? 1.5 : 1.0;\n          const strength = (0.1 + freqAvg * reactivity * 0.9) * strengthMultiplier;\n\n          // Lower threshold during high energy moments\n          const energyThreshold = 0.2 - overallEnergy * 0.1;\n          if (strength > energyThreshold) {\n            // Only connect if there's enough energy\n            star1.connections.push({\n              star: star2,\n              strength\n            });\n            connectionCount++;\n          }\n        }\n      }\n    }\n\n    // Draw connections first (behind stars)\n    ctx.lineCap = 'round';\n    stars.forEach(star => {\n      star.connections.forEach(conn => {\n        const gradient = ctx.createLinearGradient(star.x, star.y, conn.star.x, conn.star.y);\n\n        // Create gradient based on star colors\n        const color1 = `hsla(${star.hue}, 100%, 70%, ${conn.strength})`;\n        const color2 = `hsla(${conn.star.hue}, 100%, 70%, ${conn.strength})`;\n        gradient.addColorStop(0, color1);\n        gradient.addColorStop(1, color2);\n        ctx.strokeStyle = gradient;\n        ctx.lineWidth = 1 + conn.strength * 2;\n        ctx.beginPath();\n        ctx.moveTo(star.x, star.y);\n        ctx.lineTo(conn.star.x, conn.star.y);\n        ctx.stroke();\n      });\n    });\n\n    // Draw stars\n    stars.forEach(star => {\n      // Star color based on frequency\n      const freqValue = dataArray[star.freqBand] / 255.0;\n      const starColor = `hsla(${star.hue}, 100%, 70%, ${star.brightness})`;\n\n      // Draw star glow\n      const glowSize = star.size * (1 + freqValue * reactivity * 3);\n      const glow = ctx.createRadialGradient(star.x, star.y, 0, star.x, star.y, glowSize);\n      glow.addColorStop(0, starColor);\n      glow.addColorStop(1, 'rgba(0, 0, 0, 0)');\n      ctx.fillStyle = glow;\n      ctx.beginPath();\n      ctx.arc(star.x, star.y, glowSize, 0, Math.PI * 2);\n      ctx.fill();\n\n      // Draw star core\n      ctx.fillStyle = 'rgba(255, 255, 255, ' + star.brightness + ')';\n      ctx.beginPath();\n      ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);\n      ctx.fill();\n    });\n\n    // Draw constellation names occasionally\n    if (Math.random() < 0.005) {\n      const constellationNames = ['Audionis', 'Beatoria', 'Rhythmica', 'Melodius', 'Harmonix', 'Synthus', 'Bassus Major', 'Treble Minor'];\n      const name = constellationNames[Math.floor(Math.random() * constellationNames.length)];\n      const x = 100 + Math.random() * (width - 200);\n      const y = 100 + Math.random() * (height - 200);\n      ctx.font = '20px Arial';\n      ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';\n      ctx.fillText(name, x, y);\n    }\n  };\n  const drawMandala = (ctx, dataArray, timeArray, bufferLength, cachedParameters) => {\n    // Safety check - ensure canvas reference exists\n    if (!canvasRef.current) {\n      console.error(\"Canvas reference is null in drawMandala\");\n      return;\n    }\n\n    // Apply parameters\n    const color = cachedParameters.color || '#ff00ff'; // Magenta default\n    const reactivity = (cachedParameters.reactivity || 50) / 50; // 0-1 reactivity\n    const complexity = (cachedParameters.complexity || 50) / 50; // 0-1 complexity\n    const speed = (cachedParameters.speed || 50) / 100; // 0-0.5 speed\n\n    const width = canvasRef.current.width;\n    const height = canvasRef.current.height;\n    const centerX = width / 2;\n    const centerY = height / 2;\n\n    // Create a dark background with subtle gradient\n    const bgGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, Math.max(width, height) / 2);\n    bgGradient.addColorStop(0, 'rgb(10, 0, 20)');\n    bgGradient.addColorStop(1, 'rgb(0, 0, 10)');\n    ctx.fillStyle = bgGradient;\n    ctx.fillRect(0, 0, width, height);\n\n    // Calculate average energy in different frequency bands\n    const bandCount = Math.floor(4 + complexity * 12); // 4-16 bands\n    const energyBands = [];\n    for (let i = 0; i < bandCount; i++) {\n      const startBin = Math.floor(i / bandCount * (bufferLength / 2));\n      const endBin = Math.floor((i + 1) / bandCount * (bufferLength / 2));\n      energyBands.push(getAverageEnergy(dataArray, startBin, endBin) * reactivity);\n    }\n\n    // Calculate overall energy for scaling the mandala\n    const overallEnergy = energyBands.reduce((sum, energy) => sum + energy, 0) / bandCount;\n\n    // Base radius of the mandala\n    const baseRadius = Math.min(width, height) * 0.35;\n    const radius = baseRadius * (0.8 + overallEnergy * 0.4);\n\n    // Number of symmetry axes\n    const symmetryCount = Math.floor(4 + complexity * 12); // 4-16 symmetry axes\n\n    // Draw the mandala layers from outside to inside\n    const layerCount = Math.floor(3 + complexity * 7); // 3-10 layers\n\n    for (let layer = 0; layer < layerCount; layer++) {\n      // Layer properties\n      const layerRadius = radius * (1 - layer / layerCount * 0.8);\n      const layerEnergy = energyBands[layer % bandCount];\n      const layerRotation = timeRef.current * speed * (1 + layer * 0.1) + layer * Math.PI / layerCount;\n\n      // Layer color based on position and energy\n      const hue = layer / layerCount * 300 + timeRef.current * 10;\n      const saturation = 80 + layerEnergy * 20;\n      const lightness = 40 + layerEnergy * 30;\n      const layerColor = `hsl(${hue}, ${saturation}%, ${lightness}%)`;\n\n      // Draw the layer elements\n      ctx.strokeStyle = layerColor;\n      ctx.fillStyle = adjustColor(layerColor, -20);\n\n      // Element complexity increases with layer\n      const elementComplexity = 0.2 + layer / layerCount * 0.8 * complexity;\n\n      // Draw symmetrical elements\n      for (let i = 0; i < symmetryCount; i++) {\n        const angle = i / symmetryCount * Math.PI * 2 + layerRotation;\n\n        // Draw petal/element\n        drawMandalaElement(ctx, centerX, centerY, angle, layerRadius, layerEnergy, elementComplexity, layer, symmetryCount);\n      }\n\n      // Draw connecting circles between layers\n      if (layer > 0 && layer < layerCount - 1) {\n        const circleRadius = layerRadius * (0.1 + layerEnergy * 0.1);\n        ctx.lineWidth = 1 + layerEnergy * 3;\n        ctx.beginPath();\n        ctx.arc(centerX, centerY, layerRadius, 0, Math.PI * 2);\n        ctx.stroke();\n      }\n    }\n\n    // Draw central mandala element\n    const centerSize = radius * 0.2 * (0.8 + overallEnergy * 0.4);\n    const centerGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, centerSize);\n    centerGradient.addColorStop(0, adjustColor(color, 30));\n    centerGradient.addColorStop(0.7, adjustColor(color, 10));\n    centerGradient.addColorStop(1, 'rgba(0, 0, 0, 0)');\n    ctx.fillStyle = centerGradient;\n    ctx.beginPath();\n    ctx.arc(centerX, centerY, centerSize, 0, Math.PI * 2);\n    ctx.fill();\n\n    // Draw sacred geometry in the center\n    ctx.strokeStyle = adjustColor(color, 50);\n    ctx.lineWidth = 1;\n\n    // Draw flower of life pattern\n    const flowerRadius = centerSize * 0.6;\n    const petalCount = Math.floor(6 + overallEnergy * 6);\n    for (let i = 0; i < petalCount; i++) {\n      const angle = i / petalCount * Math.PI * 2 + timeRef.current * speed;\n      const x = centerX + Math.cos(angle) * flowerRadius * 0.5;\n      const y = centerY + Math.sin(angle) * flowerRadius * 0.5;\n      ctx.beginPath();\n      ctx.arc(x, y, flowerRadius * 0.5, 0, Math.PI * 2);\n      ctx.stroke();\n    }\n\n    // Function to draw a single mandala element\n    function drawMandalaElement(ctx, centerX, centerY, angle, radius, energy, complexity, layer, symmetryCount) {\n      // Calculate element position\n      const x = centerX + Math.cos(angle) * radius;\n      const y = centerY + Math.sin(angle) * radius;\n\n      // Element size based on energy\n      const size = radius * 0.2 * (0.5 + energy * 0.8);\n      ctx.save();\n      ctx.translate(x, y);\n      ctx.rotate(angle + Math.PI / 2);\n\n      // Choose element type based on layer\n      const elementType = layer % 4;\n      ctx.lineWidth = 1 + energy * 2;\n      switch (elementType) {\n        case 0:\n          // Petal shape\n          ctx.beginPath();\n          ctx.moveTo(0, -size);\n          ctx.bezierCurveTo(size * complexity, -size * 0.5, size * complexity, size * 0.5, 0, size);\n          ctx.bezierCurveTo(-size * complexity, size * 0.5, -size * complexity, -size * 0.5, 0, -size);\n          ctx.fill();\n          ctx.stroke();\n          break;\n        case 1:\n          // Triangular element\n          ctx.beginPath();\n          ctx.moveTo(0, -size);\n          ctx.lineTo(size * 0.7 * complexity, size * 0.5);\n          ctx.lineTo(-size * 0.7 * complexity, size * 0.5);\n          ctx.closePath();\n          ctx.fill();\n          ctx.stroke();\n          break;\n        case 2:\n          // Circular element\n          ctx.beginPath();\n          ctx.arc(0, 0, size * 0.5, 0, Math.PI * 2);\n          ctx.fill();\n          ctx.stroke();\n\n          // Add inner detail\n          if (complexity > 0.5) {\n            ctx.beginPath();\n            ctx.arc(0, 0, size * 0.25, 0, Math.PI * 2);\n            ctx.stroke();\n          }\n          break;\n        case 3:\n          // Spiral element\n          ctx.beginPath();\n          for (let i = 0; i < Math.PI * 2 * complexity; i += 0.1) {\n            const spiralRadius = i / (Math.PI * 2) * size;\n            const sx = Math.cos(i) * spiralRadius;\n            const sy = Math.sin(i) * spiralRadius;\n            if (i === 0) {\n              ctx.moveTo(sx, sy);\n            } else {\n              ctx.lineTo(sx, sy);\n            }\n          }\n          ctx.stroke();\n          break;\n      }\n      ctx.restore();\n    }\n  };\n  const drawOcean = (ctx, dataArray, timeArray, bufferLength, cachedParameters) => {\n    // Safety check - ensure canvas reference exists\n    if (!canvasRef.current) {\n      console.error(\"Canvas reference is null in drawOcean\");\n      return;\n    }\n\n    // Apply parameters\n    const color = cachedParameters.color || '#0066cc'; // Ocean blue default\n    const reactivity = (cachedParameters.reactivity || 50) / 50; // 0-1 reactivity\n    const detail = (cachedParameters.detail || 50) / 50; // 0-1 detail\n    const speed = (cachedParameters.speed || 50) / 100; // 0-0.5 speed\n\n    const width = canvasRef.current.width;\n    const height = canvasRef.current.height;\n\n    // Initialize wave points if they don't exist\n    if (!window.oceanWaves) {\n      window.oceanWaves = [];\n      const waveCount = 5; // Number of wave layers\n\n      for (let w = 0; w < waveCount; w++) {\n        const pointCount = Math.floor(20 + detail * 60); // 20-80 points per wave\n        const points = [];\n        for (let i = 0; i <= pointCount; i++) {\n          points.push({\n            x: i / pointCount * width,\n            y: height * (0.5 + w * 0.1),\n            // Stagger waves vertically\n            baseY: height * (0.5 + w * 0.1),\n            offset: Math.random() * Math.PI * 2\n          });\n        }\n        window.oceanWaves.push({\n          points,\n          speed: 0.5 + w / waveCount * 0.5,\n          // Different speeds for each wave\n          amplitude: 10 + (waveCount - w) * 5,\n          // Different amplitudes (higher for foreground)\n          color: adjustColor(color, -w * 10) // Darker for background waves\n        });\n      }\n    }\n\n    // Create sky gradient\n    const skyGradient = ctx.createLinearGradient(0, 0, 0, height * 0.5);\n\n    // Get bass and mid frequencies for sky color\n    const bassEnergy = getAverageEnergy(dataArray, 0, Math.floor(bufferLength * 0.1)) * reactivity;\n    const midEnergy = getAverageEnergy(dataArray, Math.floor(bufferLength * 0.1), Math.floor(bufferLength * 0.5)) * reactivity;\n\n    // Sky colors change with audio\n    const skyTopColor = `rgb(${20 + bassEnergy * 50}, ${100 + midEnergy * 50}, ${180 + bassEnergy * 20})`;\n    const skyBottomColor = `rgb(${100 + midEnergy * 30}, ${150 + bassEnergy * 30}, ${200 + midEnergy * 20})`;\n    skyGradient.addColorStop(0, skyTopColor);\n    skyGradient.addColorStop(1, skyBottomColor);\n\n    // Fill sky\n    ctx.fillStyle = skyGradient;\n    ctx.fillRect(0, 0, width, height * 0.5);\n\n    // Draw sun/moon\n    const celestialSize = width * 0.08;\n    const celestialX = width * 0.8;\n    const celestialY = height * 0.2;\n\n    // Sun/moon color based on audio\n    const celestialColor = `rgba(${255 - bassEnergy * 50}, ${255 - bassEnergy * 20}, ${220 - bassEnergy * 20}, 0.8)`;\n\n    // Draw glow\n    const glowGradient = ctx.createRadialGradient(celestialX, celestialY, 0, celestialX, celestialY, celestialSize * 2);\n    glowGradient.addColorStop(0, celestialColor);\n    glowGradient.addColorStop(1, 'rgba(255, 255, 220, 0)');\n    ctx.fillStyle = glowGradient;\n    ctx.beginPath();\n    ctx.arc(celestialX, celestialY, celestialSize * 2, 0, Math.PI * 2);\n    ctx.fill();\n\n    // Draw sun/moon body\n    ctx.fillStyle = celestialColor;\n    ctx.beginPath();\n    ctx.arc(celestialX, celestialY, celestialSize, 0, Math.PI * 2);\n    ctx.fill();\n\n    // Draw clouds if detail is high enough\n    if (detail > 0.4) {\n      const cloudCount = Math.floor(3 + detail * 7); // 3-10 clouds\n\n      for (let i = 0; i < cloudCount; i++) {\n        // Cloud position\n        const cloudX = i / cloudCount * width * 1.5 % (width * 1.2) - width * 0.1 + timeRef.current * speed * 20 % width;\n        const cloudY = height * (0.1 + Math.sin(i) * 0.1);\n        const cloudSize = width * (0.05 + i % 3 * 0.03);\n\n        // Cloud color affected by audio\n        const cloudOpacity = 0.7 + midEnergy * 0.3;\n        ctx.fillStyle = `rgba(255, 255, 255, ${cloudOpacity})`;\n\n        // Draw cloud as a group of circles\n        for (let j = 0; j < 5; j++) {\n          const offsetX = (j - 2) * cloudSize * 0.5;\n          const offsetY = Math.sin(j * 1.5) * cloudSize * 0.2;\n          const size = cloudSize * (0.7 + Math.sin(j) * 0.3);\n          ctx.beginPath();\n          ctx.arc(cloudX + offsetX, cloudY + offsetY, size, 0, Math.PI * 2);\n          ctx.fill();\n        }\n      }\n    }\n\n    // Update and draw waves\n    const waves = window.oceanWaves;\n\n    // Calculate frequency bands for wave modulation\n    const bandCount = waves.length;\n    const energyBands = [];\n    for (let i = 0; i < bandCount; i++) {\n      const startBin = Math.floor(i / bandCount * (bufferLength / 2));\n      const endBin = Math.floor((i + 1) / bandCount * (bufferLength / 2));\n      energyBands.push(getAverageEnergy(dataArray, startBin, endBin) * reactivity);\n    }\n\n    // Create ocean base gradient\n    const oceanGradient = ctx.createLinearGradient(0, height * 0.5, 0, height);\n    oceanGradient.addColorStop(0, adjustColor(color, 20));\n    oceanGradient.addColorStop(1, adjustColor(color, -30));\n\n    // Fill ocean base\n    ctx.fillStyle = oceanGradient;\n    ctx.fillRect(0, height * 0.5, width, height * 0.5);\n\n    // Update and draw each wave\n    for (let w = 0; w < waves.length; w++) {\n      const wave = waves[w];\n      const energy = energyBands[w % energyBands.length];\n\n      // Update wave points\n      for (let i = 0; i < wave.points.length; i++) {\n        const point = wave.points[i];\n\n        // Wave motion: combination of time, position, and audio reactivity\n        const waveTime = timeRef.current * speed * wave.speed;\n        const wavePos = i / wave.points.length * Math.PI * 10 + point.offset;\n\n        // Primary wave motion\n        const baseWave = Math.sin(waveTime + wavePos) * wave.amplitude;\n\n        // Secondary choppiness based on audio\n        const choppiness = Math.sin(waveTime * 2 + wavePos * 2) * wave.amplitude * 0.3 * energy;\n\n        // Update point position\n        point.y = point.baseY + baseWave + choppiness;\n      }\n\n      // Draw the wave\n      ctx.fillStyle = wave.color;\n      ctx.beginPath();\n      ctx.moveTo(0, height);\n      ctx.lineTo(wave.points[0].x, wave.points[0].y);\n\n      // Draw wave using bezier curves for smoothness\n      for (let i = 0; i < wave.points.length - 1; i++) {\n        const current = wave.points[i];\n        const next = wave.points[i + 1];\n\n        // Control points for bezier curve\n        const cpX1 = current.x + (next.x - current.x) / 3;\n        const cpY1 = current.y;\n        const cpX2 = current.x + (next.x - current.x) * 2 / 3;\n        const cpY2 = next.y;\n        ctx.bezierCurveTo(cpX1, cpY1, cpX2, cpY2, next.x, next.y);\n      }\n\n      // Complete the wave shape\n      ctx.lineTo(width, height);\n      ctx.closePath();\n      ctx.fill();\n\n      // Add foam/highlights to wave crests if detail is high enough\n      if (detail > 0.6 && w < 2) {\n        // Only for top waves\n        ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';\n        ctx.lineWidth = 2;\n        for (let i = 0; i < wave.points.length - 1; i++) {\n          const point = wave.points[i];\n          const nextPoint = wave.points[i + 1];\n\n          // Only add foam to wave peaks\n          if (i > 0) {\n            const prevPoint = wave.points[i - 1];\n\n            // Check if this is a peak (higher than neighbors)\n            if (point.y < prevPoint.y && point.y < nextPoint.y) {\n              // Foam intensity based on how sharp the peak is and audio energy\n              const peakSharpness = Math.min(Math.abs(point.y - prevPoint.y), Math.abs(point.y - nextPoint.y));\n              if (peakSharpness > wave.amplitude * 0.3 * energy) {\n                // Draw foam as small arcs\n                ctx.beginPath();\n                ctx.arc(point.x, point.y, peakSharpness * 0.5, 0, Math.PI);\n                ctx.stroke();\n              }\n            }\n          }\n        }\n      }\n    }\n\n    // Add reflections on the water\n    if (detail > 0.3) {\n      // Sun/moon reflection\n      const reflectionGradient = ctx.createLinearGradient(celestialX, height * 0.5, celestialX, height * 0.7);\n      reflectionGradient.addColorStop(0, `rgba(255, 255, 220, ${0.3 + bassEnergy * 0.2})`);\n      reflectionGradient.addColorStop(1, 'rgba(255, 255, 220, 0)');\n      ctx.fillStyle = reflectionGradient;\n      ctx.beginPath();\n      ctx.moveTo(celestialX - celestialSize, height * 0.5);\n      ctx.lineTo(celestialX + celestialSize, height * 0.5);\n      ctx.lineTo(celestialX + celestialSize * 2, height * 0.7);\n      ctx.lineTo(celestialX - celestialSize * 2, height * 0.7);\n      ctx.closePath();\n      ctx.fill();\n    }\n  };\n  const drawDNA = (ctx, dataArray, timeArray, bufferLength, cachedParameters) => {\n    // Safety check - ensure canvas reference exists\n    if (!canvasRef.current) {\n      console.error(\"Canvas reference is null in drawDNA\");\n      return;\n    }\n\n    // Apply parameters\n    const color = cachedParameters.color || '#00ff99'; // Teal default\n    const reactivity = (cachedParameters.reactivity || 50) / 50; // 0-1 reactivity\n    const detail = (cachedParameters.detail || 50) / 50; // 0-1 detail\n    const speed = (cachedParameters.speed || 50) / 50; // 0-1 speed\n\n    const width = canvasRef.current.width;\n    const height = canvasRef.current.height;\n    const centerX = width / 2;\n\n    // Create a dark background with subtle gradient\n    const bgGradient = ctx.createLinearGradient(0, 0, 0, height);\n    bgGradient.addColorStop(0, 'rgb(0, 10, 20)');\n    bgGradient.addColorStop(1, 'rgb(0, 5, 10)');\n    ctx.fillStyle = bgGradient;\n    ctx.fillRect(0, 0, width, height);\n\n    // Calculate frequency bands for DNA modulation\n    const bandCount = Math.floor(10 + detail * 20); // 10-30 bands\n    const energyBands = [];\n    for (let i = 0; i < bandCount; i++) {\n      const startBin = Math.floor(i / bandCount * (bufferLength / 2));\n      const endBin = Math.floor((i + 1) / bandCount * (bufferLength / 2));\n      energyBands.push(getAverageEnergy(dataArray, startBin, endBin) * reactivity);\n    }\n\n    // DNA helix parameters\n    const dnaLength = height * 1.5; // Length of the DNA strand\n    const dnaWidth = width * 0.15; // Width of the DNA helix\n    const dnaSegments = Math.floor(20 + detail * 60); // Number of segments in the DNA\n    const dnaRotation = timeRef.current * speed; // Rotation of the DNA over time\n\n    // Calculate overall energy for DNA animation\n    const overallEnergy = energyBands.reduce((sum, energy) => sum + energy, 0) / bandCount;\n\n    // Vertical offset to center the DNA\n    const verticalOffset = (height - dnaLength) / 2;\n\n    // Draw the DNA strands\n    for (let strand = 0; strand < 2; strand++) {\n      // Each strand has a different color\n      const strandColor = strand === 0 ? color : adjustColor(color, 40);\n\n      // Draw the strand backbone\n      ctx.strokeStyle = adjustColor(strandColor, -20);\n      ctx.lineWidth = 4;\n      ctx.beginPath();\n      for (let i = 0; i <= dnaSegments; i++) {\n        const progress = i / dnaSegments;\n        const y = verticalOffset + progress * dnaLength;\n\n        // Sine wave for the strand, offset by PI for the second strand\n        const phase = strand * Math.PI;\n        const waveAmplitude = dnaWidth * (0.8 + overallEnergy * 0.4);\n        const x = centerX + Math.sin(progress * Math.PI * 10 + dnaRotation + phase) * waveAmplitude;\n        if (i === 0) {\n          ctx.moveTo(x, y);\n        } else {\n          ctx.lineTo(x, y);\n        }\n      }\n      ctx.stroke();\n    }\n\n    // Draw the base pairs (connections between strands)\n    for (let i = 0; i < dnaSegments; i++) {\n      const progress = i / dnaSegments;\n      const y = verticalOffset + progress * dnaLength;\n\n      // Get the energy for this segment\n      const energy = energyBands[i % bandCount];\n\n      // Calculate positions of the two strand points at this segment\n      const phase1 = 0;\n      const phase2 = Math.PI;\n      const waveAmplitude = dnaWidth * (0.8 + overallEnergy * 0.4);\n      const x1 = centerX + Math.sin(progress * Math.PI * 10 + dnaRotation + phase1) * waveAmplitude;\n      const x2 = centerX + Math.sin(progress * Math.PI * 10 + dnaRotation + phase2) * waveAmplitude;\n\n      // Only draw base pairs at certain intervals\n      if (i % 2 === 0) {\n        // Base pair color based on frequency band\n        const hue = i / dnaSegments * 180 + 180; // Cyan to blue range\n        const basePairColor = `hsla(${hue}, 100%, 70%, ${0.5 + energy * 0.5})`;\n\n        // Draw base pair connection\n        ctx.strokeStyle = basePairColor;\n        ctx.lineWidth = 2 + energy * 4;\n        ctx.beginPath();\n        ctx.moveTo(x1, y);\n        ctx.lineTo(x2, y);\n        ctx.stroke();\n\n        // Draw nucleotide bases at the ends of the connection\n        const baseSize = 3 + energy * 5;\n\n        // Base 1\n        ctx.fillStyle = adjustColor(color, 20);\n        ctx.beginPath();\n        ctx.arc(x1, y, baseSize, 0, Math.PI * 2);\n        ctx.fill();\n\n        // Base 2\n        ctx.fillStyle = adjustColor(color, 60);\n        ctx.beginPath();\n        ctx.arc(x2, y, baseSize, 0, Math.PI * 2);\n        ctx.fill();\n      }\n    }\n\n    // Add glow effect to the DNA\n    if (detail > 0.5) {\n      ctx.globalCompositeOperation = 'lighter';\n\n      // Draw glow along the DNA strands\n      for (let i = 0; i < dnaSegments; i += 4) {\n        const progress = i / dnaSegments;\n        const y = verticalOffset + progress * dnaLength;\n\n        // Get the energy for this segment\n        const energy = energyBands[i % bandCount];\n\n        // Only add glow if there's enough energy\n        if (energy > 0.5) {\n          // Calculate position on the DNA\n          const phase = i % 2 * Math.PI; // Alternate between strands\n          const waveAmplitude = dnaWidth * (0.8 + overallEnergy * 0.4);\n          const x = centerX + Math.sin(progress * Math.PI * 10 + dnaRotation + phase) * waveAmplitude;\n\n          // Glow size based on energy\n          const glowSize = 20 + energy * 30;\n\n          // Glow color\n          const hue = i / dnaSegments * 180 + 180;\n          const glowColor = `hsla(${hue}, 100%, 70%, ${energy * 0.3})`;\n\n          // Draw glow\n          const glow = ctx.createRadialGradient(x, y, 0, x, y, glowSize);\n          glow.addColorStop(0, glowColor);\n          glow.addColorStop(1, 'rgba(0, 0, 0, 0)');\n          ctx.fillStyle = glow;\n          ctx.beginPath();\n          ctx.arc(x, y, glowSize, 0, Math.PI * 2);\n          ctx.fill();\n        }\n      }\n      ctx.globalCompositeOperation = 'source-over';\n    }\n\n    // Add floating particles around the DNA if detail is high\n    if (detail > 0.7) {\n      const particleCount = Math.floor(20 + detail * 60);\n      for (let i = 0; i < particleCount; i++) {\n        // Particle position - keep near the DNA\n        const angle = Math.random() * Math.PI * 2;\n        const distance = dnaWidth * 2 + Math.random() * width * 0.2;\n        const x = centerX + Math.cos(angle) * distance;\n        const y = Math.random() * height;\n\n        // Particle size based on audio\n        const particleEnergy = energyBands[i % bandCount];\n        const size = 1 + particleEnergy * 3;\n\n        // Particle color\n        const hue = i / particleCount * 180 + 180;\n        const particleColor = `hsla(${hue}, 100%, 70%, ${0.3 + particleEnergy * 0.7})`;\n\n        // Draw particle\n        ctx.fillStyle = particleColor;\n        ctx.beginPath();\n        ctx.arc(x, y, size, 0, Math.PI * 2);\n        ctx.fill();\n      }\n    }\n  };\n  const drawForest = (ctx, dataArray, timeArray, bufferLength, cachedParameters) => {\n    // Safety check - ensure canvas reference exists\n    if (!canvasRef.current) {\n      console.error(\"Canvas reference is null in drawForest\");\n      return;\n    }\n\n    // Apply parameters\n    const color = cachedParameters.color || '#33cc33'; // Green default\n    const reactivity = (cachedParameters.reactivity || 50) / 50; // 0-1 reactivity\n    const density = (cachedParameters.density || 50) / 50; // 0-1 density\n    const detail = (cachedParameters.detail || 50) / 50; // 0-1 detail\n\n    const width = canvasRef.current.width;\n    const height = canvasRef.current.height;\n\n    // Create a forest background gradient (sky to ground)\n    const bgGradient = ctx.createLinearGradient(0, 0, 0, height);\n\n    // Get bass and mid frequencies for sky color\n    const bassEnergy = getAverageEnergy(dataArray, 0, Math.floor(bufferLength * 0.1)) * reactivity;\n    const midEnergy = getAverageEnergy(dataArray, Math.floor(bufferLength * 0.1), Math.floor(bufferLength * 0.5)) * reactivity;\n\n    // Sky colors change with audio\n    const skyTopColor = `rgb(${50 + bassEnergy * 30}, ${100 + midEnergy * 50}, ${150 + bassEnergy * 50})`;\n    const skyBottomColor = `rgb(${100 + midEnergy * 20}, ${120 + bassEnergy * 20}, ${150 + midEnergy * 20})`;\n    const groundColor = `rgb(${30 + bassEnergy * 10}, ${60 + midEnergy * 10}, ${30 + bassEnergy * 5})`;\n    bgGradient.addColorStop(0, skyTopColor);\n    bgGradient.addColorStop(0.6, skyBottomColor);\n    bgGradient.addColorStop(0.6, groundColor);\n    // Create a darker version of the ground color directly\n    const darkerGroundColor = `rgb(${Math.max(0, 30 + bassEnergy * 10 - 20)}, ${Math.max(0, 60 + midEnergy * 10 - 20)}, ${Math.max(0, 30 + bassEnergy * 5 - 20)})`;\n    bgGradient.addColorStop(1, darkerGroundColor);\n    ctx.fillStyle = bgGradient;\n    ctx.fillRect(0, 0, width, height);\n\n    // Draw sun/moon in the sky\n    const celestialSize = width * 0.05;\n    const celestialX = width * 0.8;\n    const celestialY = height * 0.2;\n\n    // Sun/moon color based on audio\n    const celestialColor = `rgba(${255 - bassEnergy * 50}, ${255 - bassEnergy * 20}, ${220 - bassEnergy * 20}, 0.8)`;\n\n    // Draw glow\n    const glowGradient = ctx.createRadialGradient(celestialX, celestialY, 0, celestialX, celestialY, celestialSize * 2);\n    glowGradient.addColorStop(0, celestialColor);\n    glowGradient.addColorStop(1, 'rgba(255, 255, 220, 0)');\n    ctx.fillStyle = glowGradient;\n    ctx.beginPath();\n    ctx.arc(celestialX, celestialY, celestialSize * 2, 0, Math.PI * 2);\n    ctx.fill();\n    ctx.fillStyle = celestialColor;\n    ctx.beginPath();\n    ctx.arc(celestialX, celestialY, celestialSize, 0, Math.PI * 2);\n    ctx.fill();\n\n    // Calculate frequency bands for trees\n    const bandCount = Math.floor(10 + density * 40); // 10-50 frequency bands\n    const energyBands = [];\n    for (let i = 0; i < bandCount; i++) {\n      const startBin = Math.floor(i / bandCount * (bufferLength / 2));\n      const endBin = Math.floor((i + 1) / bandCount * (bufferLength / 2));\n      energyBands.push(getAverageEnergy(dataArray, startBin, endBin) * reactivity);\n    }\n\n    // Draw distant mountains if detail is high enough\n    if (detail > 0.3) {\n      const mountainCount = Math.floor(3 + detail * 7); // 3-10 mountains\n\n      for (let i = 0; i < mountainCount; i++) {\n        // Mountain properties\n        const mountainWidth = width / (mountainCount - 1);\n        const mountainX = i * mountainWidth - mountainWidth / 2;\n        const mountainHeight = height * 0.2 * (0.5 + Math.sin(i * 2) * 0.5);\n\n        // Mountain color based on distance (further = lighter)\n        const distanceFactor = i / mountainCount;\n        const mountainColor = `rgba(${70 + distanceFactor * 30}, ${90 + distanceFactor * 30}, ${110 + distanceFactor * 30}, ${0.8 - distanceFactor * 0.4})`;\n\n        // Draw mountain\n        ctx.fillStyle = mountainColor;\n        ctx.beginPath();\n        ctx.moveTo(mountainX, height * 0.6);\n        ctx.lineTo(mountainX + mountainWidth / 2, height * 0.6 - mountainHeight);\n        ctx.lineTo(mountainX + mountainWidth, height * 0.6);\n        ctx.closePath();\n        ctx.fill();\n\n        // Add snow caps if high enough\n        if (mountainHeight > height * 0.1) {\n          const snowCapHeight = mountainHeight * 0.2;\n          const snowCapWidth = mountainWidth * 0.3;\n          ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';\n          ctx.beginPath();\n          ctx.moveTo(mountainX + mountainWidth / 2 - snowCapWidth / 2, height * 0.6 - mountainHeight + snowCapHeight);\n          ctx.lineTo(mountainX + mountainWidth / 2, height * 0.6 - mountainHeight);\n          ctx.lineTo(mountainX + mountainWidth / 2 + snowCapWidth / 2, height * 0.6 - mountainHeight + snowCapHeight);\n          ctx.closePath();\n          ctx.fill();\n        }\n      }\n    }\n\n    // Draw trees\n    const treeCount = Math.floor(10 + density * 40); // 10-50 trees\n    const horizonY = height * 0.6; // Horizon line\n\n    // Sort trees by depth (draw back to front)\n    const trees = [];\n    for (let i = 0; i < treeCount; i++) {\n      // Tree position\n      const x = Math.random() * width;\n      const depth = Math.random(); // 0 = far, 1 = close\n      const y = horizonY - depth * height * 0.1; // Trees further away are higher on screen\n\n      // Tree properties based on frequency band\n      const bandIndex = Math.floor(i / treeCount * bandCount);\n      const energy = energyBands[bandIndex];\n\n      // Tree size based on depth and audio\n      const baseHeight = height * 0.2 * depth;\n      const treeHeight = baseHeight * (0.7 + energy * 0.6);\n      const trunkWidth = treeHeight * 0.05 * (0.8 + energy * 0.4);\n      trees.push({\n        x,\n        y,\n        depth,\n        height: treeHeight,\n        width: trunkWidth,\n        energy,\n        bandIndex\n      });\n    }\n\n    // Sort trees by depth (back to front)\n    trees.sort((a, b) => a.depth - b.depth);\n\n    // Draw each tree\n    trees.forEach(tree => {\n      // Tree colors based on depth and energy\n      const depthFactor = tree.depth;\n      const energy = tree.energy;\n\n      // Trunk color\n      const trunkColor = adjustColor('#8B4513', -20 + depthFactor * 40); // Brown with depth variation\n\n      // Foliage color based on tree's frequency band and energy\n      const hue = 80 + tree.bandIndex / bandCount * 40; // Green to yellow-green range\n      const saturation = 70 + energy * 30;\n      const lightness = 20 + depthFactor * 20 + energy * 20;\n      const foliageColor = `hsl(${hue}, ${saturation}%, ${lightness}%)`;\n\n      // Draw trunk\n      ctx.fillStyle = trunkColor;\n      ctx.beginPath();\n      ctx.rect(tree.x - tree.width / 2, tree.y - tree.height, tree.width, tree.height * 0.4);\n      ctx.fill();\n\n      // Draw foliage based on detail level\n      if (detail < 0.5) {\n        // Simple triangle foliage\n        const foliageWidth = tree.height * 0.4 * (0.8 + energy * 0.4);\n        const foliageHeight = tree.height * 0.8 * (0.8 + energy * 0.4);\n        ctx.fillStyle = foliageColor;\n        ctx.beginPath();\n        ctx.moveTo(tree.x - foliageWidth / 2, tree.y - tree.height * 0.3);\n        ctx.lineTo(tree.x, tree.y - tree.height - foliageHeight * 0.2);\n        ctx.lineTo(tree.x + foliageWidth / 2, tree.y - tree.height * 0.3);\n        ctx.closePath();\n        ctx.fill();\n      } else {\n        // Detailed multi-layer foliage\n        const layerCount = Math.floor(2 + detail * 3); // 2-5 layers\n\n        for (let i = 0; i < layerCount; i++) {\n          const layerWidth = tree.height * (0.5 - i * 0.07) * (0.8 + energy * 0.4);\n          const layerY = tree.y - tree.height * (0.3 + i * 0.2);\n\n          // Layer color gets lighter toward the top\n          const layerLightness = lightness + i * 5;\n          const layerColor = `hsl(${hue}, ${saturation}%, ${layerLightness}%)`;\n          ctx.fillStyle = layerColor;\n          ctx.beginPath();\n          ctx.moveTo(tree.x - layerWidth / 2, layerY);\n          ctx.lineTo(tree.x, layerY - layerWidth * 0.8);\n          ctx.lineTo(tree.x + layerWidth / 2, layerY);\n          ctx.closePath();\n          ctx.fill();\n        }\n      }\n\n      // Add tree sway animation based on audio\n      if (energy > 0.3) {\n        // Draw swaying leaves/particles\n        const particleCount = Math.floor(5 + energy * 15);\n        for (let i = 0; i < particleCount; i++) {\n          // Particle position around the foliage\n          const angle = Math.random() * Math.PI * 2;\n          const distance = tree.height * 0.2 * Math.random();\n          const particleX = tree.x + Math.cos(angle) * distance;\n          const particleY = tree.y - tree.height * 0.6 - Math.sin(angle) * distance;\n\n          // Particle size based on energy\n          const size = 1 + energy * 2;\n\n          // Particle color - convert HSL to hex before adjusting\n          // Use a fixed hex color instead of trying to adjust the HSL color\n          const particleColor = energy > 0.5 ? `hsl(${hue}, ${saturation}%, ${Math.min(lightness + 20, 90)}%)` : `hsl(${hue}, ${saturation}%, ${Math.min(lightness + 10, 80)}%)`;\n          ctx.fillStyle = particleColor;\n          ctx.beginPath();\n          ctx.arc(particleX, particleY, size, 0, Math.PI * 2);\n          ctx.fill();\n        }\n      }\n    });\n\n    // Add lighting effects based on audio\n    if (detail > 0.6) {\n      // Sun rays\n      const rayCount = Math.floor(5 + bassEnergy * 10);\n      ctx.strokeStyle = `rgba(255, 255, 200, ${0.1 + bassEnergy * 0.2})`;\n      ctx.lineWidth = 1;\n      for (let i = 0; i < rayCount; i++) {\n        const angle = i / rayCount * Math.PI + Math.PI / 4;\n        const rayLength = width * (0.5 + bassEnergy * 0.5);\n        ctx.beginPath();\n        ctx.moveTo(celestialX, celestialY);\n        ctx.lineTo(celestialX + Math.cos(angle) * rayLength, celestialY + Math.sin(angle) * rayLength);\n        ctx.stroke();\n      }\n\n      // Ground fog\n      const fogOpacity = 0.1 + midEnergy * 0.2;\n      const fogGradient = ctx.createLinearGradient(0, horizonY, 0, height);\n      fogGradient.addColorStop(0, `rgba(255, 255, 255, ${fogOpacity})`);\n      fogGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');\n      ctx.fillStyle = fogGradient;\n      ctx.fillRect(0, horizonY, width, height - horizonY);\n    }\n  };\n  function getAverageEnergy(data, startBin, endBin) {\n    let sum = 0;\n    const binCount = Math.min(endBin - startBin, data.length - startBin);\n    if (binCount <= 0) return 0;\n    for (let i = startBin; i < startBin + binCount; i++) {\n      sum += data[i] / 255.0;\n    }\n    return sum / binCount;\n  }\n\n  // Update parameters when initialParameters change - use a ref to avoid re-renders\n  useEffect(() => {\n    // Only log in development\n    if (process.env.NODE_ENV !== 'production') {\n      console.log(\"Visualizer received updated parameters:\", initialParameters);\n    }\n    if (initialParameters && Object.keys(initialParameters).length > 0) {\n      // Use a simple update without triggering re-renders\n      setParameters(initialParameters);\n    }\n  }, [initialParameters]);\n\n  // Add a function to update parameters\n  const updateParameters = newParameters => {\n    // Only log in development\n    if (process.env.NODE_ENV !== 'production') {\n      console.log(\"Updating visualization parameters:\", newParameters);\n    }\n    setParameters(newParameters);\n  };\n  const drawSnake = (ctx, dataArray, timeArray, bufferLength, cachedParameters) => {\n    // Safety check - ensure canvas reference exists\n    if (!canvasRef.current) {\n      console.error(\"Canvas reference is null in drawSnake\");\n      return;\n    }\n\n    // Apply parameters\n    const color = cachedParameters.color || '#ff0000'; // Base color (will be overridden by rainbow)\n    const reactivity = (cachedParameters.reactivity || 50) / 50; // 0-1 reactivity\n    const speed = (cachedParameters.speed || 50) / 50; // 0-1 speed\n    const size = (cachedParameters.size || 50) / 50; // 0-1 size\n\n    const width = canvasRef.current.width;\n    const height = canvasRef.current.height;\n\n    // Create a cosmic background with slower movement\n    // Use timeRef for slow background movement\n    const bgTime = timeRef.current * 0.05; // Significantly slowed down background movement\n    const bgOffsetX = Math.sin(bgTime * 0.2) * width * 0.05;\n    const bgOffsetY = Math.cos(bgTime * 0.3) * height * 0.05;\n    const bgGradient = ctx.createRadialGradient(width / 2 + bgOffsetX, height / 2 + bgOffsetY, 0, width / 2 + bgOffsetX, height / 2 + bgOffsetY, Math.max(width, height));\n    bgGradient.addColorStop(0, 'rgba(20, 0, 40, 1)');\n    bgGradient.addColorStop(0.5, 'rgba(10, 0, 20, 1)');\n    bgGradient.addColorStop(1, 'rgba(0, 0, 10, 1)');\n    ctx.fillStyle = bgGradient;\n    ctx.fillRect(0, 0, width, height);\n\n    // Draw cosmic stars with slow twinkling\n    if (!window.snakeStars) {\n      // Initialize fixed star positions\n      window.snakeStars = [];\n      const starCount = 150;\n      for (let i = 0; i < starCount; i++) {\n        window.snakeStars.push({\n          x: Math.random() * width,\n          y: Math.random() * height,\n          size: Math.random() * 2 + 0.5,\n          brightness: 0.5 + Math.random() * 0.5,\n          twinkleSpeed: Math.random() * 2 + 1,\n          twinkleOffset: Math.random() * Math.PI * 2\n        });\n      }\n    }\n\n    // Draw stars with slow twinkling\n    window.snakeStars.forEach(star => {\n      // Slow twinkling effect\n      const twinkle = 0.5 + Math.sin(timeRef.current * 0.5 * star.twinkleSpeed + star.twinkleOffset) * 0.3;\n      ctx.fillStyle = `rgba(255, 255, 255, ${star.brightness * twinkle})`;\n      ctx.beginPath();\n      ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);\n      ctx.fill();\n    });\n\n    // Calculate audio energy for different frequency bands\n    const bassEnergy = getAverageEnergy(dataArray, 0, Math.floor(bufferLength * 0.1)) * reactivity;\n    const midEnergy = getAverageEnergy(dataArray, Math.floor(bufferLength * 0.1), Math.floor(bufferLength * 0.5)) * reactivity;\n    const highEnergy = getAverageEnergy(dataArray, Math.floor(bufferLength * 0.5), bufferLength) * reactivity;\n\n    // Calculate overall energy\n    const overallEnergy = (bassEnergy + midEnergy + highEnergy) / 3;\n\n    // Detect beats for movement changes\n    const beatDetected = bassEnergy > 0.7 || midEnergy > 0.8;\n\n    // Initialize snake if it doesn't exist\n    if (!window.snake) {\n      // Grid size based on canvas dimensions\n      const gridSize = Math.floor(20 + size * 20); // 20-40 grid cells\n      const cellSize = Math.min(width, height) / gridSize;\n\n      // Initial snake position (center of screen)\n      const initialX = Math.floor(gridSize / 2);\n      const initialY = Math.floor(gridSize / 2);\n\n      // Create initial snake with just 3 segments (smaller start)\n      const segments = [];\n      for (let i = 0; i < 3; i++) {\n        segments.push({\n          x: initialX - i * 0.5,\n          y: initialY,\n          // Add extra properties for cosmic effect\n          glow: Math.random(),\n          pulseOffset: Math.random() * Math.PI * 2,\n          // Add properties for smooth movement\n          targetX: initialX - i * 0.5,\n          targetY: initialY,\n          prevX: initialX - i * 0.5,\n          prevY: initialY\n        });\n      }\n\n      // Create targets for the snake to move toward\n      const targets = [];\n      for (let i = 0; i < 5; i++) {\n        targets.push({\n          x: Math.random() * gridSize,\n          y: Math.random() * gridSize,\n          energy: 1.0\n        });\n      }\n      window.snake = {\n        segments,\n        direction: {\n          x: 1,\n          y: 0\n        },\n        // Initial direction: right\n        nextDirection: {\n          x: 1,\n          y: 0\n        },\n        // For queuing direction changes\n        gridSize,\n        cellSize,\n        moveCounter: 0,\n        moveThreshold: 15,\n        // Moderate movement speed\n        colorOffset: 0,\n        food: {\n          x: Math.floor(Math.random() * gridSize),\n          y: Math.floor(Math.random() * gridSize),\n          energy: 1.0\n        },\n        lastMoveTime: 0,\n        directionChangeQueued: false,\n        targets: targets,\n        currentTargetIndex: 0,\n        pathfindingCounter: 0,\n        glowIntensity: 0.5,\n        tailEffect: 0,\n        // Track growth for gradual size increase\n        initialSize: 3,\n        // Initial number of segments\n        maxSegments: 15,\n        // Maximum number of segments\n        growthProgress: 0,\n        // Growth progress counter\n        foodEaten: 0,\n        // Track food eaten for growth\n        // Movement interpolation\n        movementProgress: 0,\n        // Progress between positions (0-1)\n        movementSpeed: 0.1,\n        // Speed of interpolation (0.1 = 10% per frame)\n        lastMoveDirection: {\n          x: 1,\n          y: 0\n        } // Last movement direction\n      };\n    }\n    const snake = window.snake;\n\n    // Safety check - ensure snake object is properly initialized\n    if (!snake || !snake.segments || !snake.targets) {\n      console.error(\"Snake object is not properly initialized\");\n      // Reinitialize by clearing the window.snake object\n      window.snake = null;\n      return;\n    }\n\n    // Update cosmic background effects based on audio\n    snake.glowIntensity = 0.5 + overallEnergy * 0.5;\n    snake.tailEffect = Math.max(snake.tailEffect, bassEnergy);\n    snake.tailEffect *= 0.95; // Decay effect\n\n    // Update targets based on audio energy - slower movement\n    if (beatDetected && Math.random() < 0.2) {\n      // Reduced probability from 0.3 to 0.2\n      // Create a new target when a beat is detected\n      const targetIndex = Math.floor(Math.random() * snake.targets.length);\n      snake.targets[targetIndex] = {\n        x: Math.random() * snake.gridSize,\n        y: Math.random() * snake.gridSize,\n        energy: 1.0\n      };\n    }\n\n    // Update target energies - slower fading\n    snake.targets.forEach(target => {\n      target.energy *= 0.995; // Slower fade (was 0.99)\n      if (target.energy < 0.2) {\n        // Regenerate faded targets\n        target.x = Math.random() * snake.gridSize;\n        target.y = Math.random() * snake.gridSize;\n        target.energy = 1.0;\n      }\n    });\n\n    // Find the most energetic target\n    let bestTargetIndex = 0;\n    let bestEnergy = 0;\n    snake.targets.forEach((target, index) => {\n      if (target.energy > bestEnergy) {\n        bestEnergy = target.energy;\n        bestTargetIndex = index;\n      }\n    });\n    snake.currentTargetIndex = bestTargetIndex;\n\n    // Update pathfinding toward current target - slower updates\n    snake.pathfindingCounter++;\n    if (snake.pathfindingCounter >= 15) {\n      // Increased from 10 to 15 for slower direction changes\n      snake.pathfindingCounter = 0;\n      const head = snake.segments[0];\n      const target = snake.targets[snake.currentTargetIndex];\n\n      // Safety check - ensure target exists\n      if (!target) {\n        console.error(\"Target is undefined\");\n        return;\n      }\n\n      // Calculate direction to target\n      const dx = target.x - head.x;\n      const dy = target.y - head.y;\n\n      // Determine best direction to move\n      let newDirection = {\n        x: 0,\n        y: 0\n      };\n\n      // Prioritize the larger distance\n      if (Math.abs(dx) > Math.abs(dy)) {\n        newDirection.x = dx > 0 ? 1 : -1;\n        newDirection.y = 0;\n      } else {\n        newDirection.x = 0;\n        newDirection.y = dy > 0 ? 1 : -1;\n      }\n\n      // Occasionally make random moves for more interesting patterns - reduced frequency\n      if (Math.random() < 0.1 * overallEnergy) {\n        // Reduced from 0.2 to 0.1\n        if (Math.random() < 0.5) {\n          newDirection = {\n            x: Math.random() < 0.5 ? -1 : 1,\n            y: 0\n          };\n        } else {\n          newDirection = {\n            x: 0,\n            y: Math.random() < 0.5 ? -1 : 1\n          };\n        }\n      }\n\n      // Don't allow reversing direction\n      if (!(newDirection.x === -snake.direction.x && newDirection.y === -snake.direction.y)) {\n        snake.nextDirection = newDirection;\n        snake.directionChangeQueued = true;\n      }\n    }\n\n    // Update snake movement counter - sync with music but slower\n    const baseSpeed = 0.5; // Reduced from 0.7 to 0.5\n    const maxSpeedBoost = 0.8; // Reduced from 1.0 to 0.8\n    snake.moveCounter += baseSpeed + speed * maxSpeedBoost * overallEnergy;\n\n    // Smooth movement interpolation\n    snake.movementProgress += snake.movementSpeed;\n\n    // Move snake when counter exceeds threshold\n    if (snake.moveCounter >= snake.moveThreshold) {\n      snake.moveCounter = 0;\n\n      // Apply queued direction change\n      if (snake.directionChangeQueued) {\n        snake.direction = snake.nextDirection;\n        snake.directionChangeQueued = false;\n      }\n\n      // Store last move direction\n      snake.lastMoveDirection = {\n        ...snake.direction\n      };\n\n      // Save previous positions for interpolation\n      snake.segments.forEach(segment => {\n        segment.prevX = segment.x;\n        segment.prevY = segment.y;\n      });\n\n      // Calculate new head position - smoother, slower movement\n      const head = snake.segments[0];\n      const moveAmount = 0.4 + overallEnergy * 0.4; // Reduced from 0.5 to 0.4\n\n      const newHead = {\n        x: head.prevX + snake.direction.x * moveAmount,\n        y: head.prevY + snake.direction.y * moveAmount,\n        targetX: head.prevX + snake.direction.x * moveAmount,\n        targetY: head.prevY + snake.direction.y * moveAmount,\n        prevX: head.prevX,\n        prevY: head.prevY,\n        glow: Math.random(),\n        pulseOffset: Math.random() * Math.PI * 2\n      };\n\n      // Wrap around screen edges with a margin to keep snake visible\n      const margin = 2;\n      if (newHead.x < margin) newHead.x = snake.gridSize - margin;\n      if (newHead.x > snake.gridSize - margin) newHead.x = margin;\n      if (newHead.y < margin) newHead.y = snake.gridSize - margin;\n      if (newHead.y > snake.gridSize - margin) newHead.y = margin;\n\n      // Update target position to match wrapped position\n      newHead.targetX = newHead.x;\n      newHead.targetY = newHead.y;\n\n      // Check if snake ate food\n      const distance = Math.sqrt(Math.pow(newHead.x - snake.food.x, 2) + Math.pow(newHead.y - snake.food.y, 2));\n      const ateFood = distance < 1.5;\n\n      // Add new head to snake\n      snake.segments.unshift(newHead);\n\n      // If didn't eat food, remove tail\n      if (!ateFood) {\n        // Only remove tail if we're at or above the current growth target\n        const targetLength = Math.max(snake.initialSize, Math.ceil(snake.initialSize + (snake.maxSegments - snake.initialSize) * (snake.growthProgress / 100)));\n        if (snake.segments.length > targetLength) {\n          snake.segments.pop();\n        }\n      } else {\n        // Generate new food\n        let newFoodX, newFoodY;\n        let validPosition = false;\n        while (!validPosition) {\n          newFoodX = Math.random() * snake.gridSize;\n          newFoodY = Math.random() * snake.gridSize;\n\n          // Check if position is not too close to snake\n          validPosition = !snake.segments.some(segment => Math.sqrt(Math.pow(segment.x - newFoodX, 2) + Math.pow(segment.y - newFoodY, 2)) < 2);\n        }\n        snake.food = {\n          x: newFoodX,\n          y: newFoodY,\n          energy: 1.0\n        };\n\n        // Add cosmic energy burst effect\n        snake.glowIntensity = 1.0;\n        snake.tailEffect = 1.0;\n\n        // Increment food eaten counter\n        snake.foodEaten++;\n\n        // Increase growth progress - more significant growth\n        snake.growthProgress += 15; // Each food adds 15% toward full growth (was 10%)\n        snake.growthProgress = Math.min(snake.growthProgress, 100); // Cap at 100%\n\n        // Increase max segments as snake grows\n        if (snake.foodEaten % 2 === 0 && snake.maxSegments < 30) {\n          snake.maxSegments += 5; // Grow by 5 segments every 2 food items (was every 3)\n        }\n      }\n\n      // Reset movement progress for smooth interpolation\n      snake.movementProgress = 0;\n    }\n\n    // Update color rotation based on audio energy - slower rotation\n    snake.colorOffset += 0.003 + overallEnergy * 0.02; // Reduced from 0.005 + 0.03\n    if (snake.colorOffset > 1) snake.colorOffset -= 1;\n\n    // Draw cosmic food\n    const foodPulse = 0.8 + Math.sin(timeRef.current * 2) * 0.2; // Slower pulsing (was 3)\n    const foodSize = snake.cellSize * (1.0 + bassEnergy * 0.5) * foodPulse;\n    const foodX = snake.food.x * snake.cellSize;\n    const foodY = snake.food.y * snake.cellSize;\n\n    // Food glow effect\n    const foodGlow = ctx.createRadialGradient(foodX, foodY, 0, foodX, foodY, foodSize * 2);\n    const foodHue = timeRef.current * 20 % 360; // Slower color change (was 30)\n    foodGlow.addColorStop(0, `hsla(${foodHue}, 100%, 70%, 0.8)`);\n    foodGlow.addColorStop(0.5, `hsla(${foodHue}, 100%, 50%, 0.4)`);\n    foodGlow.addColorStop(1, `hsla(${foodHue}, 100%, 40%, 0)`);\n    ctx.fillStyle = foodGlow;\n    ctx.beginPath();\n    ctx.arc(foodX, foodY, foodSize * 2, 0, Math.PI * 2);\n    ctx.fill();\n\n    // Food core\n    ctx.fillStyle = `hsla(${foodHue}, 100%, 70%, 0.9)`;\n    ctx.beginPath();\n    ctx.arc(foodX, foodY, foodSize / 2, 0, Math.PI * 2);\n    ctx.fill();\n\n    // Draw targets as subtle cosmic portals - slower animation\n    snake.targets.forEach(target => {\n      if (target.energy > 0.2) {\n        const targetX = target.x * snake.cellSize;\n        const targetY = target.y * snake.cellSize;\n        const targetSize = snake.cellSize * target.energy;\n\n        // Portal effect with slower pulsing\n        const portalPulse = 0.9 + Math.sin(timeRef.current * 1.5) * 0.1; // Slower pulse\n        const portalGradient = ctx.createRadialGradient(targetX, targetY, 0, targetX, targetY, targetSize * 3 * portalPulse);\n        portalGradient.addColorStop(0, `rgba(100, 100, 255, ${target.energy * 0.1})`);\n        portalGradient.addColorStop(0.5, `rgba(50, 50, 150, ${target.energy * 0.05})`);\n        portalGradient.addColorStop(1, 'rgba(0, 0, 0, 0)');\n        ctx.fillStyle = portalGradient;\n        ctx.beginPath();\n        ctx.arc(targetX, targetY, targetSize * 3 * portalPulse, 0, Math.PI * 2);\n        ctx.fill();\n\n        // Portal rings with slower rotation\n        ctx.strokeStyle = `rgba(100, 100, 255, ${target.energy * 0.3})`;\n        ctx.lineWidth = 1;\n\n        // Inner ring\n        ctx.beginPath();\n        ctx.arc(targetX, targetY, targetSize * portalPulse, 0, Math.PI * 2);\n        ctx.stroke();\n\n        // Outer ring\n        ctx.beginPath();\n        ctx.arc(targetX, targetY, targetSize * 1.5 * portalPulse, 0, Math.PI * 2);\n        ctx.stroke();\n      }\n    });\n\n    // Draw snake segments with cosmic rainbow effect\n    ctx.globalCompositeOperation = 'lighter'; // Make colors blend additively\n\n    // Calculate current target size based on growth progress\n    const targetLength = Math.max(snake.initialSize, Math.ceil(snake.initialSize + (snake.maxSegments - snake.initialSize) * (snake.growthProgress / 100)));\n\n    // Display growth progress for debugging\n    // ctx.fillStyle = 'white';\n    // ctx.font = '12px Arial';\n    // ctx.fillText(`Growth: ${Math.floor(snake.growthProgress)}%, Target: ${targetLength}, Current: ${snake.segments.length}`, 10, 20);\n\n    snake.segments.forEach((segment, index) => {\n      // Calculate segment progress (0 = head, 1 = tail)\n      const progress = index / Math.max(snake.segments.length, 1);\n\n      // Calculate hue based on segment index and offset - slower rotation\n      const hue = (index * 12 + snake.colorOffset * 360) % 360; // Reduced from 15 to 12\n\n      // Interpolate between previous and target positions for smooth movement\n      let interpolatedX, interpolatedY;\n      if (segment.prevX !== undefined && segment.prevY !== undefined) {\n        // Use movement progress for interpolation\n        interpolatedX = segment.prevX + (segment.x - segment.prevX) * Math.min(1, snake.movementProgress);\n        interpolatedY = segment.prevY + (segment.y - segment.prevY) * Math.min(1, snake.movementProgress);\n      } else {\n        // Fallback if no previous position\n        interpolatedX = segment.x;\n        interpolatedY = segment.y;\n      }\n\n      // Calculate segment size (head is larger, tail is smaller)\n      const segmentFactor = 1 - progress * 0.5; // Less taper for a more uniform serpent\n\n      // Scale segment size based on growth progress - more dramatic growth\n      const growthScale = 0.6 + snake.growthProgress / 100 * 0.8; // 0.6 to 1.4 scale as snake grows (was 0.7 to 1.2)\n      let segmentSize = snake.cellSize * segmentFactor * growthScale;\n\n      // Apply audio reactivity to segment size\n      if (index < snake.segments.length / 3) {\n        // Head section reacts to bass\n        segmentSize *= 1 + bassEnergy * 0.3;\n      } else if (index < snake.segments.length * 2 / 3) {\n        // Middle section reacts to mids\n        segmentSize *= 1 + midEnergy * 0.3;\n      } else {\n        // Tail section reacts to highs\n        segmentSize *= 1 + highEnergy * 0.3;\n      }\n\n      // Add tail effect - make tail segments pulse with bass\n      if (index > snake.segments.length * 0.7) {\n        const tailProgress = (index - snake.segments.length * 0.7) / (snake.segments.length * 0.3);\n        segmentSize *= 1 + snake.tailEffect * tailProgress * 0.5;\n      }\n\n      // Draw segment\n      const x = interpolatedX * snake.cellSize;\n      const y = interpolatedY * snake.cellSize;\n\n      // Segment glow effect - larger for head, smaller for tail\n      const glowSize = segmentSize * (2.0 - progress * 0.5) * snake.glowIntensity;\n      const glow = ctx.createRadialGradient(x, y, 0, x, y, glowSize);\n\n      // Glow color based on segment\n      const glowOpacity = 0.7 - progress * 0.5; // Head glows more than tail\n      glow.addColorStop(0, `hsla(${hue}, 100%, 70%, ${glowOpacity})`);\n      glow.addColorStop(0.5, `hsla(${hue}, 100%, 50%, ${glowOpacity * 0.5})`);\n      glow.addColorStop(1, `hsla(${hue}, 100%, 30%, 0)`);\n\n      // Draw segment glow\n      ctx.fillStyle = glow;\n      ctx.beginPath();\n      ctx.arc(x, y, glowSize, 0, Math.PI * 2);\n      ctx.fill();\n\n      // Draw segment core - slower pulsing\n      const pulseFactor = Math.sin(timeRef.current * 1.5 + segment.pulseOffset) * 10; // Slower pulse (was 2)\n      const segmentColor = `hsl(${hue}, 100%, ${60 + pulseFactor}%)`;\n      ctx.fillStyle = segmentColor;\n      ctx.beginPath();\n      ctx.arc(x, y, segmentSize / 2, 0, Math.PI * 2);\n      ctx.fill();\n\n      // Add cosmic details to head\n      if (index === 0) {\n        // Draw eyes\n        const eyeSize = segmentSize * 0.2;\n        const eyeOffset = segmentSize * 0.2;\n\n        // Eye positions based on direction\n        const eyeX1 = x + snake.lastMoveDirection.y * eyeOffset - snake.lastMoveDirection.x * eyeOffset;\n        const eyeY1 = y + snake.lastMoveDirection.x * eyeOffset + snake.lastMoveDirection.y * eyeOffset;\n        const eyeX2 = x + snake.lastMoveDirection.y * eyeOffset + snake.lastMoveDirection.x * eyeOffset;\n        const eyeY2 = y - snake.lastMoveDirection.x * eyeOffset + snake.lastMoveDirection.y * eyeOffset;\n\n        // Draw cosmic eyes\n        const eyeGlow = ctx.createRadialGradient(eyeX1, eyeY1, 0, eyeX1, eyeY1, eyeSize * 2);\n        eyeGlow.addColorStop(0, 'rgba(255, 255, 255, 0.9)');\n        eyeGlow.addColorStop(0.5, 'rgba(200, 200, 255, 0.5)');\n        eyeGlow.addColorStop(1, 'rgba(100, 100, 255, 0)');\n        ctx.fillStyle = eyeGlow;\n        ctx.beginPath();\n        ctx.arc(eyeX1, eyeY1, eyeSize * 2, 0, Math.PI * 2);\n        ctx.arc(eyeX2, eyeY2, eyeSize * 2, 0, Math.PI * 2);\n        ctx.fill();\n\n        // Eye cores\n        ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';\n        ctx.beginPath();\n        ctx.arc(eyeX1, eyeY1, eyeSize, 0, Math.PI * 2);\n        ctx.arc(eyeX2, eyeY2, eyeSize, 0, Math.PI * 2);\n        ctx.fill();\n\n        // Pupils\n        const pupilColor = `hsl(${(hue + 180) % 360}, 100%, 50%)`;\n        ctx.fillStyle = pupilColor;\n        ctx.beginPath();\n        ctx.arc(eyeX1 + snake.lastMoveDirection.x * eyeSize * 0.3, eyeY1 + snake.lastMoveDirection.y * eyeSize * 0.3, eyeSize * 0.5, 0, Math.PI * 2);\n        ctx.arc(eyeX2 + snake.lastMoveDirection.x * eyeSize * 0.3, eyeY2 + snake.lastMoveDirection.y * eyeSize * 0.3, eyeSize * 0.5, 0, Math.PI * 2);\n        ctx.fill();\n      }\n    });\n\n    // Reset composite operation\n    ctx.globalCompositeOperation = 'source-over';\n\n    // Add cosmic particle effects - fewer particles, slower movement\n    const particleCount = Math.floor(30 * overallEnergy); // Reduced from 50 to 30\n    for (let i = 0; i < particleCount; i++) {\n      // Particles follow the snake\n      const segmentIndex = Math.floor(Math.random() * snake.segments.length);\n      const segment = snake.segments[segmentIndex];\n\n      // Smaller particle spread\n      const x = segment.x * snake.cellSize + (Math.random() - 0.5) * snake.cellSize * 3; // Reduced from 4 to 3\n      const y = segment.y * snake.cellSize + (Math.random() - 0.5) * snake.cellSize * 3; // Reduced from 4 to 3\n      const size = Math.random() * 1.5 + 0.5; // Smaller particles\n\n      // Particle color based on segment\n      const hue = (segmentIndex * 12 + snake.colorOffset * 360) % 360;\n      ctx.fillStyle = `hsla(${hue}, 100%, 70%, ${Math.random() * 0.4})`; // Lower opacity\n\n      ctx.beginPath();\n      ctx.arc(x, y, size, 0, Math.PI * 2);\n      ctx.fill();\n    }\n  };\n\n  // Expose methods to parent component through ref\n  useImperativeHandle(ref, () => ({\n    getCanvas: () => canvasRef.current,\n    changeResolution,\n    getCurrentResolution: () => resolution\n  }));\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"visualizer-container\",\n    children: /*#__PURE__*/_jsxDEV(\"div\", {\n      ref: containerRef,\n      className: `visualizer-aspect-container ${RESOLUTIONS[resolution].className}`,\n      children: [use3D ? /*#__PURE__*/_jsxDEV(ThreeVisualizer, {\n        audioData: audioData,\n        template: template.replace('3d', '') // Remove '3d' suffix for the ThreeVisualizer\n        ,\n        isPlaying: isPlaying,\n        parameters: parameters\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 3949,\n        columnNumber: 11\n      }, this) : /*#__PURE__*/_jsxDEV(\"canvas\", {\n        ref: canvasRef,\n        className: \"visualizer-canvas\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 3956,\n        columnNumber: 11\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"visualizer-overlay\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 3958,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"resolution-indicator\",\n        children: [resolution, \" (\", RESOLUTIONS[resolution].width, \"\\xD7\", RESOLUTIONS[resolution].height, \")\"]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 3959,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 3944,\n      columnNumber: 7\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 3943,\n    columnNumber: 5\n  }, this);\n}, \"M2m05wWqiMVSemPiH09b6Uwzrgs=\")), \"M2m05wWqiMVSemPiH09b6Uwzrgs=\");\n_c2 = Visualizer;\nexport default Visualizer;\nvar _c, _c2;\n$RefreshReg$(_c, \"Visualizer$forwardRef\");\n$RefreshReg$(_c2, \"Visualizer\");","map":{"version":3,"names":["React","useEffect","useRef","forwardRef","useState","useImperativeHandle","ThreeVisualizer","jsxDEV","_jsxDEV","RESOLUTIONS","width","height","className","Visualizer","_s","_c","audioFile","template","isPlaying","onAudioElementCreated","parameters","initialParameters","ref","canvasRef","containerRef","audioContextRef","analyserRef","animationFrameRef","sourceRef","audioElementRef","particlesRef","timeRef","resolution","setResolution","audioData","setAudioData","use3D","setUse3D","setParameters","threeDTemplates","includes","isInitialized","initAudio","current","context","window","AudioContext","webkitAudioContext","analyser","createAnalyser","fftSize","smoothingTimeConstant","audioElement","Audio","crossOrigin","preload","timestamp","Date","getTime","src","path","Promise","resolve","reject","loadHandler","console","log","duration","errorHandler","error","addEventListener","once","load","disconnect","mediaSource","createMediaElementSource","connect","destination","onSeeking","currentTime","startVisualization","state","resume","removeEventListener","pause","alert","playAudio","_audioContextRef$curr","play","cancelAnimationFrame","canvas","ctx","getContext","fillStyle","fillRect","style","maxWidth","maxHeight","initParticles","changeResolution","newResolution","getCurrentResolution","updateParameters","count","Math","floor","i","push","x","random","y","size","vx","speed","vy","hue","updateAndDrawParticles","dataArray","bufferLength","cachedParameters","length","color","particleCount","particleSize","reactivity","particle","dataIndex","audioValue","beginPath","arc","PI","adjustColor","fill","hexColor","amount","r","parseInt","substring","g","b","max","min","rHex","round","toString","padStart","gHex","bHex","frequencyBinCount","Uint8Array","timeArray","getByteFrequencyData","getByteTimeDomainData","lastFrameTime","performance","now","targetFrameRate","frameInterval","update3DAudio","requestAnimationFrame","deltaTime","newDataArray","Array","newTimeArray","logIndex","pow","alpha","draw","JSON","stringify","drawWaveform","drawBars","drawCircles","drawKaleidoscope","drawSpiral","drawRipples","drawTerrain","drawStarburst","drawFractal","drawLiquid","drawMesh","drawClock","drawNebula","drawCityscape","drawWaterfall","drawConstellation","drawMandala","drawOcean","drawDNA","drawForest","drawSnake","lineWidth","smoothing","strokeStyle","sliceWidth","step","v","moveTo","prevX","prevY","cpX1","cpX2","cpY1","cpY2","bezierCurveTo","lineTo","stroke","barWidth","spacing","bars","barWidthPx","barSpacing","totalBarWidth","freqRatio","barHeight","baseRadius","radius","circleCount","centerX","centerY","c","freqIndex","circleIndex","segments","translate","rotate","s","setTransform","arms","maxRadius","PI2","PI6","armColors","a","armAngle","pointsPerArm","sampleStep","t","angle","cosAngle","cos","sinAngle","sin","density","sqrt","ripples","bassEnergy","freqBand","freqIntensity","ripple","globalAlpha","filter","detail","points","pointWidth","terrainHeights","terrainHeight","smoothedHeights","sum","j","gradient","createLinearGradient","addColorStop","cpX","cpY","quadraticCurveTo","closePath","terrainY","reflectionHeight","stars","starCount","brightness","star","twinkle","starburstParticles","lastBurstTime","undefined","burstSize","burstColor","life","decay","p","complexity","variation","lowEnergy","getAverageEnergy","midEnergy","highEnergy","overallEnergy","maxTrunkLength","trunkLength","branchAngle","branchRatio","maxDepth","startX","startY","drawBranch","data","startBin","endBin","binCount","depth","time","bounds","newLength","variationScale","timeVariation","leftAngle","rightAngle","leftX","leftY","rightX","rightY","leftInBounds","isInBounds","rightInBounds","branchColor","margin","liquidPoints","pointCount","targetPointCount","newPoints","frequencyBands","energyBands","dampening","tension","timeScale","point","bandIndex","energy","timeOffset","next","lastPoint","liquidBubbles","bubbleX","bubbleSize","opacity","bubble","perspective","gridSize","cellWidth","cellHeight","focalLength","viewDistance","eyeZ","rotationX","rotationY","rotationZ","grid","row","freqX","freqY","xPos","yPos","zPos","rotate3D","scale","z","projX","projY","value","point1","point2","lineValue","depthFactor","lineColor","pointSize","pointColor","rotX","rotY","rotZ","y1","z1","x2","z2","x3","y3","createRadialGradient","markerRadius","bandCount","hands","avgEnergy","baseLength","hand","endX","endY","centerGradient","spectrumRadius","spectrumWidth","innerRadius","outerRadius","x1","y2","spectrumGradient","adjustedColor","slice","bgGradient","coreSize","coreGradient","globalCompositeOperation","wispCount","energyFactor","baseAngle","rotation","ctrlX1","ctrlY1","ctrlX2","ctrlY2","wispColor","lineCap","distance","skyGradient","moonX","moonY","moonSize","moonGlow","buildings","buildingWidth","buildingHeight","buildingColor","forEach","building","windowSize","windowSpacing","windowsPerRow","windowsPerColumn","windowAlpha","windowColor","col","windowX","windowY","antennaX","antennaHeight","beatEnergy","foregroundHeight","waterfallHistory","barCount","skipFactor","rowData","saturation","lightness","surfaceY","rippleCount","splashCount","particleX","particleY","edgeGradient","mistGradient","sampleSize","constellationStars","connections","rotationCenter","rotationSpeed","dx","dy","rotationFactor","newX","newY","freqValue","baseMaxConnections","maxConnections","baseConnectionThreshold","connectionThreshold","connectionCount","beatDetected","star1","star2","freqDiff","abs","rhythmicPattern","effectiveThreshold","freqAvg","strengthMultiplier","strength","energyThreshold","conn","color1","color2","starColor","glowSize","glow","constellationNames","name","font","fillText","reduce","symmetryCount","layerCount","layer","layerRadius","layerEnergy","layerRotation","layerColor","elementComplexity","drawMandalaElement","circleRadius","centerSize","flowerRadius","petalCount","save","elementType","spiralRadius","sx","sy","restore","oceanWaves","waveCount","w","baseY","offset","amplitude","skyTopColor","skyBottomColor","celestialSize","celestialX","celestialY","celestialColor","glowGradient","cloudCount","cloudX","cloudY","cloudSize","cloudOpacity","offsetX","offsetY","waves","oceanGradient","wave","waveTime","wavePos","baseWave","choppiness","nextPoint","prevPoint","peakSharpness","reflectionGradient","dnaLength","dnaWidth","dnaSegments","dnaRotation","verticalOffset","strand","strandColor","progress","phase","waveAmplitude","phase1","phase2","basePairColor","baseSize","glowColor","particleEnergy","particleColor","groundColor","darkerGroundColor","mountainCount","mountainWidth","mountainX","mountainHeight","distanceFactor","mountainColor","snowCapHeight","snowCapWidth","treeCount","horizonY","trees","baseHeight","treeHeight","trunkWidth","sort","tree","trunkColor","foliageColor","rect","foliageWidth","foliageHeight","layerWidth","layerY","layerLightness","rayCount","rayLength","fogOpacity","fogGradient","process","env","NODE_ENV","Object","keys","newParameters","bgTime","bgOffsetX","bgOffsetY","snakeStars","twinkleSpeed","twinkleOffset","snake","cellSize","initialX","initialY","pulseOffset","targetX","targetY","targets","direction","nextDirection","moveCounter","moveThreshold","colorOffset","food","lastMoveTime","directionChangeQueued","currentTargetIndex","pathfindingCounter","glowIntensity","tailEffect","initialSize","maxSegments","growthProgress","foodEaten","movementProgress","movementSpeed","lastMoveDirection","targetIndex","target","bestTargetIndex","bestEnergy","index","head","newDirection","baseSpeed","maxSpeedBoost","segment","moveAmount","newHead","ateFood","unshift","targetLength","ceil","pop","newFoodX","newFoodY","validPosition","some","foodPulse","foodSize","foodX","foodY","foodGlow","foodHue","targetSize","portalPulse","portalGradient","interpolatedX","interpolatedY","segmentFactor","growthScale","segmentSize","tailProgress","glowOpacity","pulseFactor","segmentColor","eyeSize","eyeOffset","eyeX1","eyeY1","eyeX2","eyeY2","eyeGlow","pupilColor","segmentIndex","getCanvas","children","replace","fileName","_jsxFileName","lineNumber","columnNumber","_c2","$RefreshReg$"],"sources":["C:/Users/fkuce/OneDrive/Desktop/Money Projects/Visualizer/frontend/src/components/Visualizer.js"],"sourcesContent":["import React, { useEffect, useRef, forwardRef, useState, useImperativeHandle } from 'react';\nimport ThreeVisualizer from './ThreeVisualizer';\nimport './Visualizer.css';\n\nconst RESOLUTIONS = {\n  '4K': { width: 3840, height: 2160, className: 'aspect-ratio-4k' },\n  '1080p': { width: 1920, height: 1080, className: 'aspect-ratio-1080p' },\n  '720p': { width: 1280, height: 720, className: 'aspect-ratio-720p' },\n  'Square': { width: 720, height: 720, className: 'aspect-ratio-square' },\n  'Vertical': { width: 1080, height: 1920, className: 'aspect-ratio-vertical' }\n};\n\nconst Visualizer = forwardRef(({ audioFile, template, isPlaying, onAudioElementCreated, parameters: initialParameters = {} }, ref) => {\n  const canvasRef = useRef(null);\n  const containerRef = useRef(null);\n  const audioContextRef = useRef(null);\n  const analyserRef = useRef(null);\n  const animationFrameRef = useRef(null);\n  const sourceRef = useRef(null);\n  const audioElementRef = useRef(null);\n  const particlesRef = useRef([]);\n  const timeRef = useRef(0); // Add timeRef to track animation time\n  const [resolution, setResolution] = useState('1080p'); // Default to 1080p\n  const [audioData, setAudioData] = useState(null);\n  const [use3D, setUse3D] = useState(false);\n  const [parameters, setParameters] = useState(initialParameters);\n\n  // Check if template is a 3D visualization\n  useEffect(() => {\n    // Define which templates should use 3D rendering\n    const threeDTemplates = ['particles3d', 'waveform3d', 'spiral3d', 'kaleidoscope3d'];\n    setUse3D(threeDTemplates.includes(template));\n  }, [template]);\n\n  // Audio initialization effect\n  useEffect(() => {\n    if (!audioFile) return;\n\n    let isInitialized = false;\n\n    const initAudio = async () => {\n      try {\n        // Initialize audio context only on first load or if it doesn't exist\n        if (!audioContextRef.current) {\n          // Create context on user interaction\n          const context = new (window.AudioContext || window.webkitAudioContext)();\n          audioContextRef.current = context;\n          \n          // Create analyzer with improved settings for better reactivity\n          const analyser = context.createAnalyser();\n          analyser.fftSize = 2048; // Increased for more detailed frequency data\n          analyser.smoothingTimeConstant = 0.8; // Higher smoothing for more consistent movement\n          analyserRef.current = analyser;\n        }\n\n        // Create and set up audio element\n        const audioElement = new Audio();\n        audioElement.crossOrigin = \"anonymous\";\n        audioElement.preload = \"auto\";\n\n        // Set the audio source\n        const timestamp = new Date().getTime();\n        audioElement.src = `http://localhost:5001${audioFile.path}?t=${timestamp}`;\n\n        // Wait for audio to be loaded enough to play\n        await new Promise((resolve, reject) => {\n          const loadHandler = () => {\n            console.log('Audio loaded, duration:', audioElement.duration);\n            resolve();\n          };\n\n          const errorHandler = (error) => {\n            console.error('Audio load error:', error);\n            reject(error);\n          };\n\n          audioElement.addEventListener('canplaythrough', loadHandler, { once: true });\n          audioElement.addEventListener('error', errorHandler, { once: true });\n          audioElement.load();\n        });\n\n        // Only create new media source if not already connected\n        if (!isInitialized) {\n          // Ensure old source is disconnected\n          if (sourceRef.current) {\n            sourceRef.current.disconnect();\n          }\n\n          // Create and connect new media source\n          const mediaSource = audioContextRef.current.createMediaElementSource(audioElement);\n          sourceRef.current = mediaSource;\n          mediaSource.connect(analyserRef.current);\n          analyserRef.current.connect(audioContextRef.current.destination);\n          isInitialized = true;\n        }\n\n        // Set up event listeners - REMOVE timeupdate listener which causes visualization restarts\n        const onSeeking = () => {\n          console.log('Seeking:', audioElement.currentTime);\n          if (isPlaying) startVisualization();\n        };\n\n        audioElement.addEventListener('seeking', onSeeking);\n        audioElement.addEventListener('seeked', onSeeking);\n        // Removed timeupdate listener which was causing visualization restarts\n\n        // Store reference and notify parent\n        audioElementRef.current = audioElement;\n        onAudioElementCreated(audioElement);\n\n        // Resume audio context if suspended\n        if (audioContextRef.current.state === 'suspended') {\n          await audioContextRef.current.resume();\n        }\n\n        return () => {\n          console.log('Cleaning up audio element');\n          audioElement.removeEventListener('seeking', onSeeking);\n          audioElement.removeEventListener('seeked', onSeeking);\n          // Removed timeupdate listener cleanup\n          audioElement.pause();\n          audioElement.src = '';\n          onAudioElementCreated(null);\n        };\n      } catch (error) {\n        console.error('Audio initialization error:', error);\n        alert('Error loading audio. Please try again.');\n      }\n    };\n\n    initAudio();\n  }, [audioFile]); // Remove isPlaying from dependencies\n\n  // Separate playback control effect\n  useEffect(() => {\n    const audioElement = audioElementRef.current;\n    if (!audioElement) return;\n\n    const playAudio = async () => {\n      try {\n        // Ensure audio context is running\n        if (audioContextRef.current?.state === 'suspended') {\n          await audioContextRef.current.resume();\n        }\n        \n        console.log('Playing audio...');\n        await audioElement.play();\n        startVisualization();\n      } catch (error) {\n        console.error('Playback error:', error);\n        alert('Error playing audio. Please try again.');\n      }\n    };\n\n    if (isPlaying) {\n      playAudio();\n    } else {\n      console.log('Pausing audio...');\n      audioElement.pause();\n      cancelAnimationFrame(animationFrameRef.current);\n    }\n  }, [isPlaying]);\n\n  // Add effect to handle template changes\n  useEffect(() => {\n    if (!canvasRef.current) return;\n    \n    const canvas = canvasRef.current;\n    const ctx = canvas.getContext('2d');\n    \n    // Clear the entire canvas\n    ctx.fillStyle = 'rgb(0, 0, 0)';\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n    // Restart visualization if playing\n    if (isPlaying) {\n      startVisualization();\n    }\n  }, [template]);\n\n  // Update canvas size based on selected resolution\n  useEffect(() => {\n    if (!canvasRef.current) return;\n    \n    const canvas = canvasRef.current;\n    const { width, height } = RESOLUTIONS[resolution];\n    \n    // Set canvas dimensions to match the selected resolution\n    canvas.width = width;\n    canvas.height = height;\n    \n    // Clear canvas with new dimensions\n    const ctx = canvas.getContext('2d');\n    ctx.fillStyle = 'rgb(0, 0, 0)';\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n    \n    // Adjust container styles based on aspect ratio\n    if (containerRef.current) {\n      if (resolution === 'Vertical') {\n        containerRef.current.style.width = 'auto';\n        containerRef.current.style.height = '80vh';\n      } else if (resolution === 'Square') {\n        containerRef.current.style.width = '720px';\n        containerRef.current.style.height = '720px';\n        containerRef.current.style.maxWidth = '720px';\n        containerRef.current.style.maxHeight = '720px';\n      } else {\n        containerRef.current.style.width = '100%';\n        containerRef.current.style.height = 'auto';\n        containerRef.current.style.maxWidth = `${width}px`;\n        containerRef.current.style.maxHeight = `${height}px`;\n      }\n    }\n    \n    // Restart visualization if playing\n    if (isPlaying) {\n      startVisualization();\n    }\n    \n    // Initialize particles for the new canvas size\n    if (template === 'particles') {\n      initParticles(ctx);\n    }\n  }, [resolution, isPlaying, template]);\n\n  // Function to change resolution\n  const changeResolution = (newResolution) => {\n    if (RESOLUTIONS[newResolution]) {\n      setResolution(newResolution);\n    }\n  };\n\n  // Expose changeResolution to parent via ref\n  useImperativeHandle(ref, () => ({\n    changeResolution,\n    getCurrentResolution: () => resolution,\n    updateParameters\n  }));\n\n  const initParticles = (ctx) => {\n    // Safety check - ensure context exists\n    if (!ctx || !ctx.canvas) {\n      console.error(\"Canvas context is null in initParticles\");\n      return;\n    }\n    \n    const count = Math.floor(((parameters.count || 50) / 50) * 200); // 100-400 particles based on count parameter\n    particlesRef.current = [];\n    \n    for (let i = 0; i < count; i++) {\n      particlesRef.current.push({\n        x: Math.random() * ctx.canvas.width,\n        y: Math.random() * ctx.canvas.height,\n        size: Math.random() * ((parameters.size || 50) / 10) + 1, // 1-6 size based on size parameter\n        vx: (Math.random() - 0.5) * ((parameters.speed || 50) / 25), // Speed based on speed parameter\n        vy: (Math.random() - 0.5) * ((parameters.speed || 50) / 25),\n        hue: Math.random() * 360\n      });\n    }\n  };\n\n  const updateAndDrawParticles = (ctx, dataArray, bufferLength, cachedParameters) => {\n    // Safety check - ensure canvas reference exists\n    if (!canvasRef.current) {\n      console.error(\"Canvas reference is null in updateAndDrawParticles\");\n      return;\n    }\n    \n    // Safety check - ensure particles array exists\n    if (!particlesRef.current || particlesRef.current.length === 0) {\n      console.log(\"Initializing particles in updateAndDrawParticles\");\n      initParticles(ctx);\n      \n      // Double-check initialization worked\n      if (!particlesRef.current || particlesRef.current.length === 0) {\n        console.error(\"Failed to initialize particles\");\n        return;\n      }\n    }\n    \n    // Apply parameters\n    const color = cachedParameters.color || '#ffffff';\n    const particleCount = Math.floor(((cachedParameters.count || 50) / 100) * particlesRef.current.length);\n    const particleSize = (cachedParameters.size || 50) / 10; // Convert to 0-10 scale\n    const speed = (cachedParameters.speed || 50) / 50; // Convert to 0-2 scale\n    const reactivity = (cachedParameters.reactivity || 50) / 50; // Convert to 0-2 scale\n    \n    // Clear canvas with fade effect\n    ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';\n    ctx.fillRect(0, 0, canvasRef.current.width, canvasRef.current.height);\n    \n    // Update and draw particles\n    for (let i = 0; i < particleCount; i++) {\n      const particle = particlesRef.current[i];\n      \n      // Apply audio reactivity\n      const dataIndex = Math.floor((i / particleCount) * bufferLength);\n      const audioValue = dataArray[dataIndex] / 255.0 * reactivity;\n      \n      // Update position\n      particle.x += particle.vx * speed;\n      particle.y += particle.vy * speed;\n      \n      // Bounce off edges\n      if (particle.x < 0 || particle.x > canvasRef.current.width) {\n        particle.vx = -particle.vx;\n      }\n      \n      if (particle.y < 0 || particle.y > canvasRef.current.height) {\n        particle.vy = -particle.vy;\n      }\n      \n      // Draw particle\n      const size = particleSize * (1 + audioValue);\n      ctx.beginPath();\n      ctx.arc(particle.x, particle.y, size, 0, Math.PI * 2);\n      ctx.fillStyle = adjustColor(color, audioValue * 50);\n      ctx.fill();\n    }\n  };\n\n  // Helper function to adjust colors\n  const adjustColor = (hexColor, amount) => {\n    // Convert hex to RGB\n    let r = parseInt(hexColor.substring(1, 3), 16);\n    let g = parseInt(hexColor.substring(3, 5), 16);\n    let b = parseInt(hexColor.substring(5, 7), 16);\n    \n    // Adjust RGB values\n    r = Math.max(0, Math.min(255, r + amount));\n    g = Math.max(0, Math.min(255, g + amount));\n    b = Math.max(0, Math.min(255, b + amount));\n    \n    // Convert back to hex with proper padding\n    const rHex = Math.round(r).toString(16).padStart(2, '0');\n    const gHex = Math.round(g).toString(16).padStart(2, '0');\n    const bHex = Math.round(b).toString(16).padStart(2, '0');\n    \n    return `#${rHex}${gHex}${bHex}`;\n  };\n\n  // Start visualization\n  const startVisualization = () => {\n    if (!analyserRef.current) {\n      console.error(\"Analyzer reference is null in startVisualization\");\n      return;\n    }\n    \n    const analyser = analyserRef.current;\n    \n    // Create data arrays for audio analysis\n    const bufferLength = analyser.frequencyBinCount;\n    const dataArray = new Uint8Array(bufferLength);\n    const timeArray = new Uint8Array(bufferLength);\n    \n    // Get initial data\n    analyser.getByteFrequencyData(dataArray);\n    analyser.getByteTimeDomainData(timeArray);\n    \n    // Cancel any existing animation frame\n    if (animationFrameRef.current) {\n      cancelAnimationFrame(animationFrameRef.current);\n    }\n    \n    // Reset animation time to ensure consistent animation speed\n    timeRef.current = 0;\n    \n    // Track frame timing for consistent animation speed\n    let lastFrameTime = performance.now();\n    const targetFrameRate = 30; // Reduced to 30 FPS for smoother, slower animations\n    const frameInterval = 1000 / targetFrameRate;\n    \n    // Handle 3D visualization\n    if (use3D) {\n      // For 3D, we need to continuously update the audio data\n      const update3DAudio = (currentTime) => {\n        animationFrameRef.current = requestAnimationFrame(update3DAudio);\n        \n        // Calculate delta time for smooth animation regardless of frame rate\n        const deltaTime = (currentTime - lastFrameTime) / frameInterval;\n        lastFrameTime = currentTime;\n        \n        // Increment time for animations with consistent speed\n        timeRef.current += 0.005 * Math.min(deltaTime, 2);\n        \n        // Get frequency and time domain data\n        analyser.getByteFrequencyData(dataArray);\n        analyser.getByteTimeDomainData(timeArray);\n        \n        // Update audio data for 3D visualizer with more efficient approach\n        const newDataArray = new Array(bufferLength);\n        const newTimeArray = new Array(bufferLength);\n        \n        // Use logarithmic sampling to focus more on lower frequencies\n        for (let i = 0; i < bufferLength; i++) {\n          // Logarithmic mapping to emphasize lower frequencies\n          const logIndex = Math.min(bufferLength - 1, Math.floor(Math.pow(i / bufferLength, 0.5) * bufferLength));\n          newDataArray[i] = dataArray[logIndex];\n          newTimeArray[i] = timeArray[logIndex];\n        }\n        \n        setAudioData({ \n          dataArray: newDataArray, \n          timeArray: newTimeArray, \n          bufferLength \n        });\n      };\n      \n      update3DAudio(performance.now());\n      return;\n    }\n    \n    // For 2D visualizations, ensure canvas exists\n    if (!canvasRef.current) {\n      console.error(\"Canvas reference is null in startVisualization for 2D visualization\");\n      return;\n    }\n    \n    const canvas = canvasRef.current;\n    const ctx = canvas.getContext('2d', { alpha: false }); // Optimize by disabling alpha\n    \n    // Cache parameter values outside the animation loop for better performance\n    let cachedParameters = { ...parameters };\n    \n    // Animation function for 2D visualizations\n    const draw = (currentTime) => {\n      animationFrameRef.current = requestAnimationFrame(draw);\n      \n      // Calculate delta time for smooth animation regardless of frame rate\n      const deltaTime = (currentTime - lastFrameTime) / frameInterval;\n      lastFrameTime = currentTime;\n      \n      // Increment time for animations with consistent speed\n      timeRef.current += 0.005 * Math.min(deltaTime, 2);\n      \n      // Get frequency and time domain data\n      analyser.getByteFrequencyData(dataArray);\n      analyser.getByteTimeDomainData(timeArray);\n      \n      // Clear canvas\n      ctx.fillStyle = 'rgb(0, 0, 0)';\n      ctx.fillRect(0, 0, canvas.width, canvas.height);\n      \n      // Check if parameters have changed\n      if (JSON.stringify(cachedParameters) !== JSON.stringify(parameters)) {\n        cachedParameters = { ...parameters };\n      }\n      \n      // Draw visualization based on template\n      switch (template) {\n        case 'waveform':\n          drawWaveform(ctx, dataArray, bufferLength, cachedParameters);\n          break;\n        case 'bars':\n          drawBars(ctx, dataArray, bufferLength, cachedParameters);\n          break;\n        case 'circles':\n          drawCircles(ctx, dataArray, bufferLength, cachedParameters);\n          break;\n        case 'kaleidoscope':\n          drawKaleidoscope(ctx, dataArray, timeArray, bufferLength, cachedParameters);\n          break;\n        case 'spiral':\n          drawSpiral(ctx, dataArray, timeArray, bufferLength, cachedParameters);\n          break;\n        case 'particles':\n          updateAndDrawParticles(ctx, dataArray, bufferLength, cachedParameters);\n          break;\n        case 'ripple':\n          drawRipples(ctx, dataArray, timeArray, bufferLength, cachedParameters);\n          break;\n        case 'terrain':\n          drawTerrain(ctx, dataArray, timeArray, bufferLength, cachedParameters);\n          break;\n        case 'starburst':\n          drawStarburst(ctx, dataArray, timeArray, bufferLength, cachedParameters);\n          break;\n        case 'fractal':\n          drawFractal(ctx, dataArray, timeArray, bufferLength, cachedParameters);\n          break;\n        case 'liquid':\n          drawLiquid(ctx, dataArray, timeArray, bufferLength, cachedParameters);\n          break;\n        case 'mesh':\n          drawMesh(ctx, dataArray, timeArray, bufferLength, cachedParameters);\n          break;\n        case 'clock':\n          drawClock(ctx, dataArray, timeArray, bufferLength, cachedParameters);\n          break;\n        case 'nebula':\n          drawNebula(ctx, dataArray, timeArray, bufferLength, cachedParameters);\n          break;\n        case 'cityscape':\n          drawCityscape(ctx, dataArray, timeArray, bufferLength, cachedParameters);\n          break;\n        case 'waterfall':\n          drawWaterfall(ctx, dataArray, timeArray, bufferLength, cachedParameters);\n          break;\n        case 'constellation':\n          drawConstellation(ctx, dataArray, timeArray, bufferLength, cachedParameters);\n          break;\n        case 'mandala':\n          drawMandala(ctx, dataArray, timeArray, bufferLength, cachedParameters);\n          break;\n        case 'ocean':\n          drawOcean(ctx, dataArray, timeArray, bufferLength, cachedParameters);\n          break;\n        case 'dna':\n          drawDNA(ctx, dataArray, timeArray, bufferLength, cachedParameters);\n          break;\n        case 'forest':\n          drawForest(ctx, dataArray, timeArray, bufferLength, cachedParameters);\n          break;\n        case 'snake':\n          drawSnake(ctx, dataArray, timeArray, bufferLength, cachedParameters);\n          break;\n        default:\n          drawWaveform(ctx, dataArray, bufferLength, cachedParameters);\n      }\n    };\n    \n    draw(performance.now());\n  };\n\n  const drawWaveform = (ctx, dataArray, bufferLength, cachedParameters) => {\n    // Safety check - ensure canvas reference exists\n    if (!canvasRef.current) {\n      console.error(\"Canvas reference is null in drawWaveform\");\n      return;\n    }\n    \n    // Apply parameters\n    const lineWidth = cachedParameters.lineWidth || 3;\n    const color = cachedParameters.color || '#00aaff';\n    const reactivity = (cachedParameters.reactivity || 50) / 40; // Adjusted for better responsiveness\n    const smoothing = (cachedParameters.smoothing || 50) / 100; // Convert to 0-1 scale\n    \n    ctx.lineWidth = lineWidth;\n    ctx.strokeStyle = color;\n    ctx.beginPath();\n    \n    const sliceWidth = (canvasRef.current.width * 1.0) / bufferLength;\n    let x = 0;\n    \n    // Use fewer points for better performance\n    const step = Math.max(1, Math.floor(bufferLength / 256));\n    \n    for (let i = 0; i < bufferLength; i += step) {\n      const v = dataArray[i] / 128.0 * reactivity;\n      const y = v * canvasRef.current.height / 2;\n      \n      if (i === 0) {\n        ctx.moveTo(x, y);\n      } else {\n        // Apply smoothing if enabled\n        if (smoothing > 0) {\n          const prevX = x - sliceWidth * step;\n          const prevY = dataArray[i - step] / 128.0 * reactivity * canvasRef.current.height / 2;\n          const cpX1 = prevX + sliceWidth * step / 3;\n          const cpX2 = x - sliceWidth * step / 3;\n          const cpY1 = prevY;\n          const cpY2 = y;\n          \n          // Use bezier curve for smoothing\n          ctx.bezierCurveTo(cpX1, cpY1, cpX2, cpY2, x, y);\n        } else {\n          ctx.lineTo(x, y);\n        }\n      }\n      \n      x += sliceWidth * step;\n    }\n    \n    ctx.lineTo(canvasRef.current.width, canvasRef.current.height / 2);\n    ctx.stroke();\n  };\n\n  const drawBars = (ctx, dataArray, bufferLength, cachedParameters) => {\n    // Safety check - ensure canvas reference exists\n    if (!canvasRef.current) {\n      console.error(\"Canvas reference is null in drawBars\");\n      return;\n    }\n    \n    // Apply parameters\n    const color = cachedParameters.color || '#ff5500';\n    const barWidth = (cachedParameters.barWidth || 50) / 100; // Convert to 0-1 scale\n    const spacing = (cachedParameters.spacing || 30) / 100; // Convert to 0-1 scale\n    const reactivity = (cachedParameters.reactivity || 50) / 20; // Adjusted for better responsiveness\n    \n    const bars = Math.min(bufferLength, 128); // Reduced number of bars for better performance\n    const width = canvasRef.current.width;\n    const height = canvasRef.current.height;\n    \n    const barWidthPx = (width / bars) * barWidth;\n    const barSpacing = (width / bars) * spacing;\n    const totalBarWidth = barWidthPx + barSpacing;\n    \n    for (let i = 0; i < bars; i++) {\n      // Use logarithmic mapping to emphasize lower frequencies\n      // Focus more on the lower half of the frequency spectrum\n      const freqRatio = i / bars;\n      const dataIndex = Math.min(bufferLength - 1, Math.floor(Math.pow(freqRatio, 0.8) * (bufferLength / 2)));\n      \n      const barHeight = dataArray[dataIndex] * reactivity;\n      \n      const x = i * totalBarWidth;\n      const y = height - barHeight;\n      \n      ctx.fillStyle = adjustColor(color, (i / bars) * 30);\n      ctx.fillRect(x, y, barWidthPx, barHeight);\n    }\n  };\n\n  const drawCircles = (ctx, dataArray, bufferLength, cachedParameters) => {\n    // Safety check - ensure canvas reference exists\n    if (!canvasRef.current) {\n      console.error(\"Canvas reference is null in drawCircles\");\n      return;\n    }\n    \n    // Apply parameters\n    const color = cachedParameters.color || '#ff00ff';\n    const baseRadius = (cachedParameters.radius || 50) / 100 * Math.min(canvasRef.current.width, canvasRef.current.height) / 2;\n    const circleCount = Math.max(1, Math.min(20, Math.floor((cachedParameters.count || 50) / 5))); // 1-20 circles\n    const reactivity = (cachedParameters.reactivity || 50) / 40; // Adjusted for better responsiveness\n    \n    const centerX = canvasRef.current.width / 2;\n    const centerY = canvasRef.current.height / 2;\n    \n    // Draw circles\n    for (let c = 0; c < circleCount; c++) {\n      // Focus on lower frequencies for outer circles, higher frequencies for inner circles\n      const freqRatio = c / circleCount;\n      const freqIndex = Math.floor(Math.pow(freqRatio, 0.7) * (bufferLength / 2));\n      const circleIndex = Math.min(bufferLength - 1, freqIndex);\n      \n      const audioValue = dataArray[circleIndex] / 128.0 * reactivity;\n      \n      const radius = baseRadius * (c + 1) / circleCount * audioValue;\n      \n      ctx.beginPath();\n      ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);\n      ctx.strokeStyle = adjustColor(color, (c / circleCount) * 50);\n      ctx.stroke();\n    }\n  };\n\n  const drawKaleidoscope = (ctx, dataArray, timeArray, bufferLength, cachedParameters) => {\n    // Safety check - ensure canvas reference exists\n    if (!canvasRef.current) {\n      console.error(\"Canvas reference is null in drawKaleidoscope\");\n      return;\n    }\n    \n    // Apply parameters\n    const color = cachedParameters.color || '#ffaa00';\n    const segments = cachedParameters.segments || 8;\n    const speed = (cachedParameters.speed || 50) / 2000; // Reduced speed for slower rotation\n    const reactivity = (cachedParameters.reactivity || 50) / 40; // Adjusted for better responsiveness\n    \n    const centerX = canvasRef.current.width / 2;\n    const centerY = canvasRef.current.height / 2;\n    const radius = Math.min(centerX, centerY) * 0.8;\n    \n    // Rotate based on time and speed\n    ctx.translate(centerX, centerY);\n    ctx.rotate(timeRef.current * speed);\n    \n    // Draw kaleidoscope segments\n    for (let s = 0; s < segments; s++) {\n      ctx.rotate(Math.PI * 2 / segments);\n      \n      ctx.beginPath();\n      ctx.strokeStyle = adjustColor(color, s * 5);\n      \n      // Draw audio-reactive pattern\n      // Use fewer points for better performance\n      const step = Math.max(8, Math.floor(bufferLength / 64));\n      \n      for (let i = 0; i < bufferLength; i += step) {\n        // Focus on lower frequencies which typically contain more rhythm information\n        const dataIndex = Math.min(bufferLength - 1, Math.floor(Math.pow(i / bufferLength, 0.7) * bufferLength));\n        \n        const x = (dataArray[dataIndex] / 256.0) * radius * reactivity;\n        const y = (timeArray[dataIndex] / 256.0) * radius * reactivity;\n        \n        if (i === 0) {\n          ctx.moveTo(x, y);\n        } else {\n          ctx.lineTo(x, y);\n        }\n      }\n      \n      ctx.stroke();\n    }\n    \n    // Reset transformation\n    ctx.setTransform(1, 0, 0, 1, 0, 0);\n  };\n\n  const drawSpiral = (ctx, dataArray, timeArray, bufferLength, cachedParameters) => {\n    // Safety check - ensure canvas reference exists\n    if (!canvasRef.current) {\n      console.error(\"Canvas reference is null in drawSpiral\");\n      return;\n    }\n    \n    // Apply parameters\n    const color = cachedParameters.color || '#00ff99';\n    const arms = cachedParameters.arms || 5;\n    const speed = (cachedParameters.speed || 50) / 2000; // Reduced speed for slower rotation\n    const reactivity = (cachedParameters.reactivity || 50) / 40; // Adjusted for better responsiveness\n    \n    const centerX = canvasRef.current.width / 2;\n    const centerY = canvasRef.current.height / 2;\n    const maxRadius = Math.min(centerX, centerY) * 0.9;\n    \n    // Rotate based on time and speed\n    ctx.translate(centerX, centerY);\n    ctx.rotate(timeRef.current * speed);\n    \n    // Pre-calculate common values\n    const PI2 = Math.PI * 2;\n    const PI6 = Math.PI * 6;\n    \n    // Pre-calculate arm colors to avoid recalculating in the loop\n    const armColors = [];\n    for (let a = 0; a < arms; a++) {\n      armColors[a] = adjustColor(color, a * 10);\n    }\n    \n    // Draw spiral arms\n    for (let a = 0; a < arms; a++) {\n      const armAngle = (a / arms) * PI2;\n      \n      ctx.beginPath();\n      ctx.strokeStyle = armColors[a];\n      \n      // Use a more efficient approach for drawing the spiral\n      // but maintain the original visual appearance with 100 points\n      const pointsPerArm = 100;\n      \n      // Sample audio data less frequently for performance\n      const sampleStep = Math.max(1, Math.floor(bufferLength / 128));\n      \n      for (let i = 0; i < pointsPerArm; i++) {\n        const t = i / pointsPerArm;\n        const angle = armAngle + t * PI6;\n        const radius = t * maxRadius;\n        \n        // Apply audio reactivity - use a more efficient data sampling approach\n        // Focus on lower frequencies which typically contain more rhythm information\n        const freqIndex = Math.min(bufferLength - 1, Math.floor(t * bufferLength / 4));\n        const dataIndex = Math.min(bufferLength - 1, freqIndex);\n        const audioValue = dataArray[dataIndex] / 128.0 * reactivity;\n        \n        // Pre-calculate trig functions for performance\n        const cosAngle = Math.cos(angle);\n        const sinAngle = Math.sin(angle);\n        \n        const x = cosAngle * radius * audioValue;\n        const y = sinAngle * radius * audioValue;\n        \n        if (i === 0) {\n          ctx.moveTo(x, y);\n        } else {\n          ctx.lineTo(x, y);\n        }\n      }\n      \n      ctx.stroke();\n    }\n    \n    // Reset transformation\n    ctx.setTransform(1, 0, 0, 1, 0, 0);\n  };\n\n  // Add a new ripple visualization\n  const drawRipples = (ctx, dataArray, timeArray, bufferLength, cachedParameters) => {\n    // Safety check - ensure canvas reference exists\n    if (!canvasRef.current) {\n      console.error(\"Canvas reference is null in drawRipples\");\n      return;\n    }\n    \n    // Apply parameters\n    const color = cachedParameters.color || '#00ffff';\n    const reactivity = (cachedParameters.reactivity || 50) / 40;\n    const speed = (cachedParameters.speed || 50) / 50;\n    const density = (cachedParameters.density || 50) / 50;\n    \n    const width = canvasRef.current.width;\n    const height = canvasRef.current.height;\n    const centerX = width / 2;\n    const centerY = height / 2;\n    const maxRadius = Math.sqrt(width * width + height * height) / 2;\n    \n    // Initialize ripples array if it doesn't exist\n    if (!window.ripples) {\n      window.ripples = [];\n    }\n    \n    // Detect beats for creating new ripples\n    let bassEnergy = 0;\n    for (let i = 0; i < 8; i++) {\n      bassEnergy += dataArray[i];\n    }\n    bassEnergy = bassEnergy / (8 * 255);\n    \n    // Create new ripple on strong beats\n    if (bassEnergy > 0.6 && Math.random() < 0.3 * density) {\n      // Get a frequency band for this ripple's color\n      const freqBand = Math.floor(Math.random() * (bufferLength / 4));\n      const freqIntensity = dataArray[freqBand] / 255;\n      \n      // Create a new ripple\n      window.ripples.push({\n        radius: 0,\n        maxRadius: maxRadius * (0.3 + Math.random() * 0.7),\n        lineWidth: 1 + Math.random() * 4,\n        alpha: 0.7 + Math.random() * 0.3,\n        speed: (0.5 + Math.random() * 1.5) * speed,\n        color: adjustColor(color, freqIntensity * 50 - 25)\n      });\n    }\n    \n    // Draw and update ripples\n    for (let i = 0; i < window.ripples.length; i++) {\n      const ripple = window.ripples[i];\n      \n      // Update radius\n      ripple.radius += ripple.speed;\n      \n      // Decrease alpha as the ripple expands\n      ripple.alpha *= 0.98;\n      \n      // Draw ripple\n      ctx.beginPath();\n      ctx.arc(centerX, centerY, ripple.radius, 0, Math.PI * 2);\n      ctx.strokeStyle = ripple.color;\n      ctx.globalAlpha = ripple.alpha;\n      ctx.lineWidth = ripple.lineWidth;\n      ctx.stroke();\n      ctx.globalAlpha = 1.0;\n    }\n    \n    // Remove ripples that have expanded beyond their max radius or faded out\n    window.ripples = window.ripples.filter(ripple => \n      ripple.radius < ripple.maxRadius && ripple.alpha > 0.01\n    );\n  };\n\n  // Add a new terrain visualization\n  const drawTerrain = (ctx, dataArray, timeArray, bufferLength, cachedParameters) => {\n    // Safety check - ensure canvas reference exists\n    if (!canvasRef.current) {\n      console.error(\"Canvas reference is null in drawTerrain\");\n      return;\n    }\n    \n    // Apply parameters\n    const color = cachedParameters.color || '#33cc33';\n    const reactivity = (cachedParameters.reactivity || 50) / 40;\n    const detail = (cachedParameters.detail || 50) / 50;\n    const speed = (cachedParameters.speed || 50) / 100;\n    \n    const width = canvasRef.current.width;\n    const height = canvasRef.current.height;\n    \n    // Calculate number of terrain points based on detail parameter\n    const points = Math.max(20, Math.floor(width / (10 / detail)));\n    const pointWidth = width / points;\n    \n    // Create terrain heights based on audio data\n    const terrainHeights = [];\n    \n    // Sample audio data for terrain heights\n    for (let i = 0; i < points; i++) {\n      // Map point index to frequency data index\n      const dataIndex = Math.floor((i / points) * (bufferLength / 2));\n      \n      // Get audio value and apply reactivity\n      const audioValue = dataArray[dataIndex] / 255.0 * reactivity;\n      \n      // Calculate terrain height\n      const terrainHeight = height * 0.1 + audioValue * height * 0.6;\n      terrainHeights.push(terrainHeight);\n    }\n    \n    // Smooth terrain heights\n    const smoothedHeights = [];\n    for (let i = 0; i < points; i++) {\n      let sum = 0;\n      let count = 0;\n      \n      // Apply smoothing by averaging neighboring points\n      for (let j = Math.max(0, i - 2); j <= Math.min(points - 1, i + 2); j++) {\n        sum += terrainHeights[j];\n        count++;\n      }\n      \n      smoothedHeights.push(sum / count);\n    }\n    \n    // Create a gradient for the terrain\n    const gradient = ctx.createLinearGradient(0, height, 0, height / 2);\n    gradient.addColorStop(0, color);\n    gradient.addColorStop(1, adjustColor(color, 30));\n    \n    // Draw terrain\n    ctx.fillStyle = gradient;\n    ctx.beginPath();\n    ctx.moveTo(0, height);\n    \n    // Draw terrain path\n    for (let i = 0; i < points; i++) {\n      const x = i * pointWidth;\n      const y = height - smoothedHeights[i];\n      \n      if (i === 0) {\n        ctx.lineTo(x, y);\n      } else {\n        // Use quadratic curves for smoother terrain\n        const prevX = (i - 1) * pointWidth;\n        const prevY = height - smoothedHeights[i - 1];\n        const cpX = (prevX + x) / 2;\n        const cpY = (prevY + y) / 2;\n        \n        ctx.quadraticCurveTo(cpX, cpY, x, y);\n      }\n    }\n    \n    // Complete the path\n    ctx.lineTo(width, height);\n    ctx.closePath();\n    ctx.fill();\n    \n    // Draw a reflection effect\n    ctx.globalAlpha = 0.3;\n    ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';\n    \n    // Draw reflection path (inverted terrain)\n    ctx.beginPath();\n    ctx.moveTo(0, height);\n    \n    for (let i = 0; i < points; i++) {\n      const x = i * pointWidth;\n      const terrainY = height - smoothedHeights[i];\n      const reflectionHeight = smoothedHeights[i] * 0.3; // Smaller reflection\n      const y = height + reflectionHeight;\n      \n      if (i === 0) {\n        ctx.lineTo(x, y);\n      } else {\n        // Use quadratic curves for smoother terrain\n        const prevX = (i - 1) * pointWidth;\n        const prevY = height + smoothedHeights[i - 1] * 0.3;\n        const cpX = (prevX + x) / 2;\n        const cpY = (prevY + y) / 2;\n        \n        ctx.quadraticCurveTo(cpX, cpY, x, y);\n      }\n    }\n    \n    // Complete the reflection path\n    ctx.lineTo(width, height);\n    ctx.closePath();\n    ctx.fill();\n    \n    // Reset alpha\n    ctx.globalAlpha = 1.0;\n    \n    // Draw stars in the sky\n    if (!window.stars) {\n      // Initialize stars\n      window.stars = [];\n      const starCount = 50;\n      \n      for (let i = 0; i < starCount; i++) {\n        window.stars.push({\n          x: Math.random() * width,\n          y: Math.random() * height * 0.5,\n          size: 0.5 + Math.random() * 1.5,\n          brightness: 0.3 + Math.random() * 0.7\n        });\n      }\n    }\n    \n    // Draw stars with audio reactivity\n    for (let i = 0; i < window.stars.length; i++) {\n      const star = window.stars[i];\n      \n      // Make stars twinkle based on audio\n      const dataIndex = Math.floor(Math.random() * (bufferLength / 4));\n      const twinkle = 0.5 + (dataArray[dataIndex] / 255.0) * 0.5;\n      \n      ctx.fillStyle = `rgba(255, 255, 255, ${star.brightness * twinkle})`;\n      ctx.beginPath();\n      ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);\n      ctx.fill();\n    }\n  };\n\n  // Add a new starburst visualization\n  const drawStarburst = (ctx, dataArray, timeArray, bufferLength, cachedParameters) => {\n    // Safety check - ensure canvas reference exists\n    if (!canvasRef.current) {\n      console.error(\"Canvas reference is null in drawStarburst\");\n      return;\n    }\n    \n    // Apply parameters\n    const color = cachedParameters.color || '#ff9900';\n    const reactivity = (cachedParameters.reactivity || 50) / 40;\n    const particleCount = (cachedParameters.count || 50) / 50 * 100; // 0-100 particles\n    const particleSize = (cachedParameters.size || 50) / 50 * 5; // 0-5 size\n    \n    const width = canvasRef.current.width;\n    const height = canvasRef.current.height;\n    const centerX = width / 2;\n    const centerY = height / 2;\n    \n    // Initialize particles array if it doesn't exist\n    if (!window.starburstParticles) {\n      window.starburstParticles = [];\n    }\n    \n    // Detect beats for creating new bursts\n    let bassEnergy = 0;\n    for (let i = 0; i < 8; i++) {\n      bassEnergy += dataArray[i];\n    }\n    bassEnergy = bassEnergy / (8 * 255);\n    \n    // Create new burst on strong beats\n    if (bassEnergy > 0.6 && (window.lastBurstTime === undefined || timeRef.current - window.lastBurstTime > 0.5)) {\n      window.lastBurstTime = timeRef.current;\n      \n      // Create a burst of particles\n      const burstSize = Math.floor(particleCount * (0.5 + bassEnergy * 0.5));\n      const burstColor = adjustColor(color, (Math.random() * 40) - 20);\n      \n      for (let i = 0; i < burstSize; i++) {\n        const angle = Math.random() * Math.PI * 2;\n        const speed = (1 + Math.random() * 3) * reactivity;\n        const size = (0.5 + Math.random() * 1.5) * particleSize;\n        const life = 1.0; // Full life\n        \n        window.starburstParticles.push({\n          x: centerX,\n          y: centerY,\n          vx: Math.cos(angle) * speed,\n          vy: Math.sin(angle) * speed,\n          size: size,\n          color: burstColor,\n          life: life,\n          decay: 0.01 + Math.random() * 0.02 // Random decay rate\n        });\n      }\n    }\n    \n    // Clear canvas with fade effect for trails\n    ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';\n    ctx.fillRect(0, 0, width, height);\n    \n    // Update and draw particles\n    for (let i = 0; i < window.starburstParticles.length; i++) {\n      const particle = window.starburstParticles[i];\n      \n      // Update position\n      particle.x += particle.vx;\n      particle.y += particle.vy;\n      \n      // Apply gravity\n      particle.vy += 0.05;\n      \n      // Update life\n      particle.life -= particle.decay;\n      \n      // Draw particle\n      if (particle.life > 0) {\n        ctx.globalAlpha = particle.life;\n        ctx.fillStyle = particle.color;\n        ctx.beginPath();\n        ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);\n        ctx.fill();\n      }\n    }\n    \n    // Reset alpha\n    ctx.globalAlpha = 1.0;\n    \n    // Remove dead particles\n    window.starburstParticles = window.starburstParticles.filter(p => p.life > 0);\n  };\n\n  // Add a new fractal tree visualization\n  const drawFractal = (ctx, dataArray, timeArray, bufferLength, cachedParameters) => {\n    // Safety check - ensure canvas reference exists\n    if (!canvasRef.current) {\n      console.error(\"Canvas reference is null in drawFractal\");\n      return;\n    }\n    \n    // Apply parameters\n    const color = cachedParameters.color || '#66ff66';\n    const reactivity = (cachedParameters.reactivity || 50) / 40;\n    const complexity = (cachedParameters.complexity || 50) / 50; // 0-1 complexity\n    const variation = (cachedParameters.variation || 50) / 50; // 0-1 variation\n    \n    const width = canvasRef.current.width;\n    const height = canvasRef.current.height;\n    \n    // Clear canvas\n    ctx.fillStyle = 'rgb(0, 0, 0)';\n    ctx.fillRect(0, 0, width, height);\n    \n    // Calculate audio energy for different frequency bands\n    const lowEnergy = getAverageEnergy(dataArray, 0, 10) * reactivity;\n    const midEnergy = getAverageEnergy(dataArray, 10, 100) * reactivity;\n    const highEnergy = getAverageEnergy(dataArray, 100, 200) * reactivity;\n    \n    // Calculate overall energy to scale the tree appropriately\n    const overallEnergy = (lowEnergy + midEnergy + highEnergy) / 3;\n    \n    // Calculate tree parameters based on audio\n    // Limit trunk length to prevent excessive growth\n    const maxTrunkLength = height * 0.3; // Maximum 30% of screen height\n    const trunkLength = Math.min(maxTrunkLength, height * 0.25 * (0.8 + lowEnergy * 0.3));\n    \n    // Limit branch angle to prevent excessive spreading\n    const branchAngle = Math.PI / 6 + midEnergy * Math.PI / 15;\n    \n    // Limit branch ratio to prevent excessive growth\n    const branchRatio = Math.min(0.67 + highEnergy * 0.08, 0.75);\n    \n    // Calculate max depth based on complexity but cap it to prevent excessive recursion\n    const maxDepth = Math.floor(4 + complexity * 3);\n    \n    // Draw tree\n    ctx.strokeStyle = color;\n    ctx.lineWidth = 2;\n    \n    // Start tree from bottom center\n    const startX = width / 2;\n    const startY = height * 0.9;\n    \n    // Draw trunk\n    ctx.beginPath();\n    ctx.moveTo(startX, startY);\n    ctx.lineTo(startX, startY - trunkLength);\n    ctx.stroke();\n    \n    // Draw branches recursively with boundary information\n    drawBranch(\n      ctx, \n      startX, \n      startY - trunkLength, \n      trunkLength, \n      -Math.PI / 2, \n      maxDepth, \n      branchAngle, \n      branchRatio, \n      color,\n      variation,\n      timeRef.current,\n      { width, height, startX, startY } // Pass boundary information\n    );\n    \n    // Helper function to calculate average energy in a frequency range\n    function getAverageEnergy(data, startBin, endBin) {\n      let sum = 0;\n      const binCount = Math.min(endBin - startBin, data.length - startBin);\n      \n      if (binCount <= 0) return 0;\n      \n      for (let i = startBin; i < startBin + binCount; i++) {\n        sum += data[i] / 255.0;\n      }\n      \n      return sum / binCount;\n    }\n    \n    // Recursive function to draw branches\n    function drawBranch(ctx, x, y, length, angle, depth, branchAngle, branchRatio, color, variation, time, bounds) {\n      if (depth === 0) return;\n      \n      // Calculate new branch length\n      const newLength = length * branchRatio;\n      \n      // Add some variation based on time, but limit the variation as depth increases\n      const variationScale = Math.max(0, 1 - (depth / maxDepth)); // Reduce variation for deeper branches\n      const timeVariation = Math.sin(time * 2 + depth) * variation * 0.1 * variationScale;\n      \n      // Calculate endpoints for left and right branches\n      const leftAngle = angle - branchAngle + timeVariation;\n      const rightAngle = angle + branchAngle + timeVariation;\n      \n      const leftX = x + Math.cos(leftAngle) * newLength;\n      const leftY = y + Math.sin(leftAngle) * newLength;\n      \n      const rightX = x + Math.cos(rightAngle) * newLength;\n      const rightY = y + Math.sin(rightAngle) * newLength;\n      \n      // Check if branches are within screen bounds\n      const leftInBounds = isInBounds(leftX, leftY, bounds);\n      const rightInBounds = isInBounds(rightX, rightY, bounds);\n      \n      // Adjust color based on depth\n      const branchColor = adjustColor(color, depth * 10);\n      ctx.strokeStyle = branchColor;\n      \n      // Adjust line width based on depth\n      ctx.lineWidth = Math.max(1, 3 - depth * 0.5);\n      \n      // Draw left branch if in bounds\n      if (leftInBounds) {\n        ctx.beginPath();\n        ctx.moveTo(x, y);\n        ctx.lineTo(leftX, leftY);\n        ctx.stroke();\n        \n        // Recursively draw sub-branches\n        drawBranch(ctx, leftX, leftY, newLength, leftAngle, depth - 1, branchAngle, branchRatio, color, variation, time, bounds);\n      }\n      \n      // Draw right branch if in bounds\n      if (rightInBounds) {\n        ctx.beginPath();\n        ctx.moveTo(x, y);\n        ctx.lineTo(rightX, rightY);\n        ctx.stroke();\n        \n        // Recursively draw sub-branches\n        drawBranch(ctx, rightX, rightY, newLength, rightAngle, depth - 1, branchAngle, branchRatio, color, variation, time, bounds);\n      }\n    }\n    \n    // Helper function to check if a point is within screen bounds with some margin\n    function isInBounds(x, y, bounds) {\n      const margin = 10; // Small margin to prevent drawing right at the edge\n      return x >= margin && \n             x <= bounds.width - margin && \n             y >= margin && \n             y <= bounds.height - margin;\n    }\n  };\n\n  // Add a new liquid wave visualization\n  const drawLiquid = (ctx, dataArray, timeArray, bufferLength, cachedParameters) => {\n    // Safety check - ensure canvas reference exists\n    if (!canvasRef.current) {\n      console.error(\"Canvas reference is null in drawLiquid\");\n      return;\n    }\n    \n    // Apply parameters\n    const color = cachedParameters.color || '#0099ff';\n    const reactivity = (cachedParameters.reactivity || 50) / 40;\n    const complexity = (cachedParameters.complexity || 50) / 50; // 0-1 complexity\n    const speed = (cachedParameters.speed || 50) / 50; // 0-1 speed\n    \n    const width = canvasRef.current.width;\n    const height = canvasRef.current.height;\n    \n    // Initialize wave points if they don't exist\n    if (!window.liquidPoints) {\n      window.liquidPoints = [];\n      const pointCount = Math.floor(20 + complexity * 30); // 20-50 points based on complexity\n      \n      for (let i = 0; i < pointCount; i++) {\n        window.liquidPoints.push({\n          x: width * (i / (pointCount - 1)),\n          y: height / 2,\n          vy: 0\n        });\n      }\n    }\n    \n    // Ensure we have the right number of points if complexity changes\n    const targetPointCount = Math.floor(20 + complexity * 30);\n    if (window.liquidPoints.length !== targetPointCount) {\n      const newPoints = [];\n      for (let i = 0; i < targetPointCount; i++) {\n        if (i < window.liquidPoints.length) {\n          newPoints.push(window.liquidPoints[i]);\n        } else {\n          newPoints.push({\n            x: width * (i / (targetPointCount - 1)),\n            y: height / 2,\n            vy: 0\n          });\n        }\n      }\n      window.liquidPoints = newPoints;\n    }\n    \n    // Clear canvas with gradient background\n    const gradient = ctx.createLinearGradient(0, 0, 0, height);\n    gradient.addColorStop(0, 'rgb(0, 10, 30)');\n    gradient.addColorStop(1, 'rgb(0, 0, 10)');\n    ctx.fillStyle = gradient;\n    ctx.fillRect(0, 0, width, height);\n    \n    // Calculate audio energy for different frequency bands\n    const frequencyBands = 8;\n    const energyBands = [];\n    \n    for (let i = 0; i < frequencyBands; i++) {\n      const startBin = Math.floor((i / frequencyBands) * (bufferLength / 2));\n      const endBin = Math.floor(((i + 1) / frequencyBands) * (bufferLength / 2));\n      energyBands.push(getAverageEnergy(dataArray, startBin, endBin) * reactivity);\n    }\n    \n    // Update wave points based on audio\n    const pointCount = window.liquidPoints.length;\n    const dampening = 0.95;\n    const tension = 0.025;\n    const timeScale = speed * 0.5;\n    \n    // Apply forces to points\n    for (let i = 0; i < pointCount; i++) {\n      const point = window.liquidPoints[i];\n      \n      // Determine which frequency band affects this point\n      const bandIndex = Math.floor((i / pointCount) * frequencyBands);\n      const energy = energyBands[bandIndex];\n      \n      // Apply force based on audio energy\n      point.vy += (Math.random() * 2 - 1) * energy * 2;\n      \n      // Apply time-based oscillation\n      const timeOffset = (i / pointCount) * Math.PI * 2;\n      point.vy += Math.sin(timeRef.current * timeScale + timeOffset) * 0.2;\n      \n      // Apply physics\n      point.y += point.vy;\n      point.vy *= dampening;\n      \n      // Apply tension to return to center\n      point.vy += (height / 2 - point.y) * tension;\n    }\n    \n    // Draw the liquid\n    ctx.fillStyle = color;\n    ctx.beginPath();\n    ctx.moveTo(0, height);\n    \n    // Draw first point\n    ctx.lineTo(window.liquidPoints[0].x, window.liquidPoints[0].y);\n    \n    // Draw curve through points\n    for (let i = 0; i < pointCount - 1; i++) {\n      const current = window.liquidPoints[i];\n      const next = window.liquidPoints[i + 1];\n      \n      // Use quadratic curves for smoother liquid\n      const cpX = (current.x + next.x) / 2;\n      const cpY = (current.y + next.y) / 2;\n      \n      ctx.quadraticCurveTo(current.x, current.y, cpX, cpY);\n    }\n    \n    // Draw last point\n    const lastPoint = window.liquidPoints[pointCount - 1];\n    ctx.lineTo(lastPoint.x, lastPoint.y);\n    \n    // Complete the path\n    ctx.lineTo(width, height);\n    ctx.closePath();\n    ctx.fill();\n    \n    // Add highlights\n    ctx.strokeStyle = adjustColor(color, 30);\n    ctx.lineWidth = 2;\n    ctx.beginPath();\n    \n    // Draw curve through points for highlight\n    ctx.moveTo(window.liquidPoints[0].x, window.liquidPoints[0].y);\n    \n    for (let i = 0; i < pointCount - 1; i++) {\n      const current = window.liquidPoints[i];\n      const next = window.liquidPoints[i + 1];\n      \n      // Use quadratic curves for smoother liquid\n      const cpX = (current.x + next.x) / 2;\n      const cpY = (current.y + next.y) / 2;\n      \n      ctx.quadraticCurveTo(current.x, current.y, cpX, cpY);\n    }\n    \n    // Draw last point for highlight\n    ctx.lineTo(lastPoint.x, lastPoint.y);\n    ctx.stroke();\n    \n    // Add bubbles for extra effect\n    if (!window.liquidBubbles) {\n      window.liquidBubbles = [];\n    }\n    \n    // Create new bubbles based on audio energy\n    const bassEnergy = energyBands[0];\n    if (Math.random() < bassEnergy * 0.3) {\n      const bubbleX = Math.random() * width;\n      const bubbleSize = 2 + Math.random() * 8;\n      \n      window.liquidBubbles.push({\n        x: bubbleX,\n        y: height,\n        size: bubbleSize,\n        speed: 0.5 + Math.random() * 2,\n        opacity: 0.1 + Math.random() * 0.4\n      });\n    }\n    \n    // Update and draw bubbles\n    ctx.fillStyle = adjustColor(color, 50);\n    \n    for (let i = 0; i < window.liquidBubbles.length; i++) {\n      const bubble = window.liquidBubbles[i];\n      \n      // Update position\n      bubble.y -= bubble.speed;\n      \n      // Draw bubble\n      ctx.globalAlpha = bubble.opacity;\n      ctx.beginPath();\n      ctx.arc(bubble.x, bubble.y, bubble.size, 0, Math.PI * 2);\n      ctx.fill();\n    }\n    \n    // Reset alpha\n    ctx.globalAlpha = 1.0;\n    \n    // Remove bubbles that have risen to the top\n    window.liquidBubbles = window.liquidBubbles.filter(b => b.y > -b.size);\n    \n    // Helper function to calculate average energy in a frequency range\n    function getAverageEnergy(data, startBin, endBin) {\n      let sum = 0;\n      const binCount = Math.min(endBin - startBin, data.length - startBin);\n      \n      if (binCount <= 0) return 0;\n      \n      for (let i = startBin; i < startBin + binCount; i++) {\n        sum += data[i] / 255.0;\n      }\n      \n      return sum / binCount;\n    }\n  };\n\n  // Add a new audio mesh visualization\n  const drawMesh = (ctx, dataArray, timeArray, bufferLength, cachedParameters) => {\n    // Safety check - ensure canvas reference exists\n    if (!canvasRef.current) {\n      console.error(\"Canvas reference is null in drawMesh\");\n      return;\n    }\n    \n    // Apply parameters\n    const color = cachedParameters.color || '#ff00cc';\n    const reactivity = (cachedParameters.reactivity || 50) / 40;\n    const density = (cachedParameters.density || 50) / 50; // 0-1 density\n    const perspective = (cachedParameters.perspective || 50) / 50; // 0-1 perspective\n    \n    const width = canvasRef.current.width;\n    const height = canvasRef.current.height;\n    \n    // Clear canvas with gradient background\n    const gradient = ctx.createLinearGradient(0, 0, 0, height);\n    gradient.addColorStop(0, 'rgb(0, 0, 0)');\n    gradient.addColorStop(1, 'rgb(20, 0, 20)');\n    ctx.fillStyle = gradient;\n    ctx.fillRect(0, 0, width, height);\n    \n    // Calculate grid dimensions based on density\n    const gridSize = Math.max(8, Math.floor(8 + density * 16)); // 8-24 grid size\n    const cellWidth = width / gridSize;\n    const cellHeight = height / gridSize;\n    \n    // Create perspective projection\n    const focalLength = 400 * perspective;\n    const viewDistance = 200 + 300 * perspective;\n    const eyeZ = -viewDistance;\n    \n    // Calculate time-based rotation\n    const rotationX = timeRef.current * 0.1;\n    const rotationY = timeRef.current * 0.15;\n    const rotationZ = timeRef.current * 0.05;\n    \n    // Create 3D grid points\n    const grid = [];\n    \n    for (let y = 0; y < gridSize; y++) {\n      const row = [];\n      for (let x = 0; x < gridSize; x++) {\n        // Map grid position to frequency data\n        const freqX = Math.floor((x / gridSize) * (bufferLength / 4));\n        const freqY = Math.floor((y / gridSize) * (bufferLength / 4));\n        const freqIndex = (freqX + freqY) % (bufferLength / 2);\n        \n        // Get audio value and apply reactivity\n        const audioValue = dataArray[freqIndex] / 255.0 * reactivity;\n        \n        // Calculate 3D coordinates\n        const xPos = (x - gridSize / 2) * cellWidth * 1.5;\n        const yPos = (y - gridSize / 2) * cellHeight * 1.5;\n        const zPos = audioValue * 100; // Z-axis deformation based on audio\n        \n        // Apply 3D rotation\n        const point = rotate3D(xPos, yPos, zPos, rotationX, rotationY, rotationZ);\n        \n        // Apply perspective projection\n        const scale = focalLength / (focalLength + point.z - eyeZ);\n        const projX = width / 2 + point.x * scale;\n        const projY = height / 2 + point.y * scale;\n        \n        // Store projected point\n        row.push({\n          x: projX,\n          y: projY,\n          z: point.z,\n          scale: scale,\n          value: audioValue\n        });\n      }\n      grid.push(row);\n    }\n    \n    // Draw mesh lines\n    ctx.lineWidth = 1;\n    \n    // Draw horizontal lines\n    for (let y = 0; y < gridSize; y++) {\n      for (let x = 0; x < gridSize - 1; x++) {\n        const point1 = grid[y][x];\n        const point2 = grid[y][x + 1];\n        \n        // Skip lines that would be behind the viewer\n        if (point1.z < eyeZ || point2.z < eyeZ) continue;\n        \n        // Calculate line color based on audio value and depth\n        const lineValue = (point1.value + point2.value) / 2;\n        const depthFactor = Math.min(1, Math.max(0, (point1.z + point2.z) / 400 + 0.5));\n        const lineColor = adjustColor(color, depthFactor * 50 - 25);\n        \n        // Draw line with opacity based on depth\n        ctx.strokeStyle = lineColor;\n        ctx.globalAlpha = depthFactor * 0.8 + 0.2;\n        \n        ctx.beginPath();\n        ctx.moveTo(point1.x, point1.y);\n        ctx.lineTo(point2.x, point2.y);\n        ctx.stroke();\n      }\n    }\n    \n    // Draw vertical lines\n    for (let x = 0; x < gridSize; x++) {\n      for (let y = 0; y < gridSize - 1; y++) {\n        const point1 = grid[y][x];\n        const point2 = grid[y + 1][x];\n        \n        // Skip lines that would be behind the viewer\n        if (point1.z < eyeZ || point2.z < eyeZ) continue;\n        \n        // Calculate line color based on audio value and depth\n        const lineValue = (point1.value + point2.value) / 2;\n        const depthFactor = Math.min(1, Math.max(0, (point1.z + point2.z) / 400 + 0.5));\n        const lineColor = adjustColor(color, depthFactor * 50 - 25);\n        \n        // Draw line with opacity based on depth\n        ctx.strokeStyle = lineColor;\n        ctx.globalAlpha = depthFactor * 0.8 + 0.2;\n        \n        ctx.beginPath();\n        ctx.moveTo(point1.x, point1.y);\n        ctx.lineTo(point2.x, point2.y);\n        ctx.stroke();\n      }\n    }\n    \n    // Draw grid points\n    for (let y = 0; y < gridSize; y++) {\n      for (let x = 0; x < gridSize; x++) {\n        const point = grid[y][x];\n        \n        // Skip points that would be behind the viewer\n        if (point.z < eyeZ) continue;\n        \n        // Calculate point size and color based on audio value and depth\n        const pointSize = 1 + point.value * 3 * point.scale;\n        const depthFactor = Math.min(1, Math.max(0, point.z / 200 + 0.5));\n        const pointColor = adjustColor(color, depthFactor * 60);\n        \n        // Draw point with opacity based on depth\n        ctx.fillStyle = pointColor;\n        ctx.globalAlpha = depthFactor * 0.8 + 0.2;\n        \n        ctx.beginPath();\n        ctx.arc(point.x, point.y, pointSize, 0, Math.PI * 2);\n        ctx.fill();\n      }\n    }\n    \n    // Reset alpha\n    ctx.globalAlpha = 1.0;\n    \n    // Helper function for 3D rotation\n    function rotate3D(x, y, z, rotX, rotY, rotZ) {\n      // Rotate around X axis\n      let y1 = y * Math.cos(rotX) - z * Math.sin(rotX);\n      let z1 = y * Math.sin(rotX) + z * Math.cos(rotX);\n      \n      // Rotate around Y axis\n      let x2 = x * Math.cos(rotY) + z1 * Math.sin(rotY);\n      let z2 = -x * Math.sin(rotY) + z1 * Math.cos(rotY);\n      \n      // Rotate around Z axis\n      let x3 = x2 * Math.cos(rotZ) - y1 * Math.sin(rotZ);\n      let y3 = x2 * Math.sin(rotZ) + y1 * Math.cos(rotZ);\n      \n      return { x: x3, y: y3, z: z2 };\n    }\n  };\n\n  // Add a new spectrum clock visualization\n  const drawClock = (ctx, dataArray, timeArray, bufferLength, cachedParameters) => {\n    // Safety check - ensure canvas reference exists\n    if (!canvasRef.current) {\n      console.error(\"Canvas reference is null in drawClock\");\n      return;\n    }\n    \n    // Apply parameters\n    const color = cachedParameters.color || '#ffcc00';\n    const reactivity = (cachedParameters.reactivity || 50) / 40;\n    const detail = (cachedParameters.detail || 50) / 50; // 0-1 detail\n    const speed = (cachedParameters.speed || 50) / 50; // 0-1 speed\n    \n    const width = canvasRef.current.width;\n    const height = canvasRef.current.height;\n    const centerX = width / 2;\n    const centerY = height / 2;\n    const radius = Math.min(centerX, centerY) * 0.85;\n    \n    // Clear canvas with radial gradient background\n    const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, radius * 1.5);\n    gradient.addColorStop(0, 'rgb(10, 10, 10)');\n    gradient.addColorStop(1, 'rgb(0, 0, 0)');\n    ctx.fillStyle = gradient;\n    ctx.fillRect(0, 0, width, height);\n    \n    // Draw clock face\n    ctx.strokeStyle = adjustColor(color, -20);\n    ctx.lineWidth = 2;\n    ctx.beginPath();\n    ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);\n    ctx.stroke();\n    \n    // Draw hour markers\n    ctx.fillStyle = color;\n    for (let i = 0; i < 12; i++) {\n      const angle = (i / 12) * Math.PI * 2 - Math.PI / 2;\n      const markerRadius = radius * 0.9;\n      const x = centerX + Math.cos(angle) * markerRadius;\n      const y = centerY + Math.sin(angle) * markerRadius;\n      \n      ctx.beginPath();\n      ctx.arc(x, y, 3, 0, Math.PI * 2);\n      ctx.fill();\n    }\n    \n    // Calculate frequency bands for clock hands\n    const bandCount = Math.floor(8 + detail * 16); // 8-24 bands\n    const hands = [];\n    \n    // Calculate average energy for each frequency band\n    for (let i = 0; i < bandCount; i++) {\n      const startBin = Math.floor((i / bandCount) * (bufferLength / 2));\n      const endBin = Math.floor(((i + 1) / bandCount) * (bufferLength / 2));\n      \n      let sum = 0;\n      for (let j = startBin; j < endBin; j++) {\n        sum += dataArray[j] / 255.0;\n      }\n      \n      const avgEnergy = sum / (endBin - startBin) * reactivity;\n      \n      // Calculate hand properties\n      const baseLength = radius * (0.3 + (i / bandCount) * 0.6); // Shorter to longer\n      const length = baseLength * (0.5 + avgEnergy * 0.5); // Extend based on energy\n      const width = 1 + (bandCount - i) / bandCount * 4; // Thicker to thinner\n      const speed = 0.2 + (i / bandCount) * 0.8; // Slower to faster\n      const angle = (i / bandCount) * Math.PI * 2 + timeRef.current * speed * speed;\n      \n      hands.push({\n        angle: angle,\n        length: length,\n        width: width,\n        energy: avgEnergy,\n        hue: (i / bandCount) * 360\n      });\n    }\n    \n    // Draw clock hands\n    for (let i = 0; i < hands.length; i++) {\n      const hand = hands[i];\n      \n      // Calculate hand position\n      const endX = centerX + Math.cos(hand.angle) * hand.length;\n      const endY = centerY + Math.sin(hand.angle) * hand.length;\n      \n      // Create gradient for hand\n      const gradient = ctx.createLinearGradient(centerX, centerY, endX, endY);\n      gradient.addColorStop(0, adjustColor(color, -30));\n      gradient.addColorStop(1, adjustColor(color, hand.energy * 50));\n      \n      // Draw hand\n      ctx.strokeStyle = gradient;\n      ctx.lineWidth = hand.width;\n      ctx.beginPath();\n      ctx.moveTo(centerX, centerY);\n      ctx.lineTo(endX, endY);\n      ctx.stroke();\n      \n      // Draw hand endpoint\n      ctx.fillStyle = adjustColor(color, hand.energy * 70);\n      ctx.beginPath();\n      ctx.arc(endX, endY, hand.width * 0.8, 0, Math.PI * 2);\n      ctx.fill();\n    }\n    \n    // Draw center circle\n    const centerGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, 10);\n    centerGradient.addColorStop(0, color);\n    centerGradient.addColorStop(1, adjustColor(color, -20));\n    \n    ctx.fillStyle = centerGradient;\n    ctx.beginPath();\n    ctx.arc(centerX, centerY, 8, 0, Math.PI * 2);\n    ctx.fill();\n    \n    // Draw frequency spectrum around the clock\n    ctx.lineWidth = 1;\n    ctx.strokeStyle = adjustColor(color, 10);\n    ctx.beginPath();\n    \n    const spectrumRadius = radius * 1.1;\n    const spectrumWidth = radius * 0.1;\n    \n    for (let i = 0; i < bufferLength / 4; i++) {\n      const angle = (i / (bufferLength / 4)) * Math.PI * 2 - Math.PI / 2;\n      const value = dataArray[i] / 255.0 * reactivity;\n      \n      const innerRadius = spectrumRadius;\n      const outerRadius = spectrumRadius + value * spectrumWidth;\n      \n      const x1 = centerX + Math.cos(angle) * innerRadius;\n      const y1 = centerY + Math.sin(angle) * innerRadius;\n      const x2 = centerX + Math.cos(angle) * outerRadius;\n      const y2 = centerY + Math.sin(angle) * outerRadius;\n      \n      if (i === 0) {\n        ctx.moveTo(x2, y2);\n      } else {\n        ctx.lineTo(x2, y2);\n      }\n    }\n    \n    // Close the spectrum path\n    ctx.closePath();\n    ctx.stroke();\n    \n    // Fill the spectrum with a gradient\n    const spectrumGradient = ctx.createRadialGradient(centerX, centerY, spectrumRadius, centerX, centerY, spectrumRadius + spectrumWidth);\n    spectrumGradient.addColorStop(0, 'rgba(0, 0, 0, 0)');\n    const adjustedColor = adjustColor(color, 20);\n    spectrumGradient.addColorStop(1, adjustedColor.slice(0, 7) + '33'); // 20% opacity\n    \n    ctx.fillStyle = spectrumGradient;\n    ctx.fill();\n  };\n\n  const drawNebula = (ctx, dataArray, timeArray, bufferLength, cachedParameters) => {\n    // Safety check - ensure canvas reference exists\n    if (!canvasRef.current) {\n      console.error(\"Canvas reference is null in drawNebula\");\n      return;\n    }\n    \n    // Apply parameters\n    const color = cachedParameters.color || '#4b0082'; // Deep purple default\n    const reactivity = (cachedParameters.reactivity || 50) / 50; // 0-1 reactivity\n    const complexity = (cachedParameters.complexity || 50) / 50; // 0-1 complexity\n    const speed = (cachedParameters.speed || 50) / 100; // 0-0.5 speed\n    \n    const width = canvasRef.current.width;\n    const height = canvasRef.current.height;\n    const centerX = width / 2;\n    const centerY = height / 2;\n    \n    // Create a dark background with subtle gradient\n    const bgGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, Math.max(width, height));\n    bgGradient.addColorStop(0, 'rgba(5, 0, 10, 1)');\n    bgGradient.addColorStop(1, 'rgba(0, 0, 5, 1)');\n    ctx.fillStyle = bgGradient;\n    ctx.fillRect(0, 0, width, height);\n    \n    // Calculate average energy in different frequency bands\n    const bassEnergy = getAverageEnergy(dataArray, 0, Math.floor(bufferLength * 0.1)) * reactivity;\n    const midEnergy = getAverageEnergy(dataArray, Math.floor(bufferLength * 0.1), Math.floor(bufferLength * 0.5)) * reactivity;\n    const highEnergy = getAverageEnergy(dataArray, Math.floor(bufferLength * 0.5), bufferLength) * reactivity;\n    \n    // Core size based on bass energy\n    const coreSize = 50 + bassEnergy * 100;\n    \n    // Draw nebula core\n    const coreGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, coreSize);\n    coreGradient.addColorStop(0, adjustColor(color, 50));\n    coreGradient.addColorStop(0.6, adjustColor(color, 20));\n    coreGradient.addColorStop(1, 'rgba(0, 0, 0, 0)');\n    \n    ctx.globalCompositeOperation = 'lighter';\n    ctx.fillStyle = coreGradient;\n    ctx.beginPath();\n    ctx.arc(centerX, centerY, coreSize, 0, Math.PI * 2);\n    ctx.fill();\n    \n    // Number of wisps based on complexity\n    const wispCount = Math.floor(10 + complexity * 30);\n    \n    // Draw nebula wisps\n    for (let i = 0; i < wispCount; i++) {\n      // Use different frequency bands to affect different wisps\n      const energyFactor = i < wispCount / 3 ? bassEnergy : \n                          (i < wispCount * 2 / 3 ? midEnergy : highEnergy);\n      \n      // Base angle for this wisp\n      const baseAngle = (i / wispCount) * Math.PI * 2;\n      // Rotation based on time\n      const rotation = timeRef.current * speed * (1 + (i % 3) * 0.2);\n      const angle = baseAngle + rotation;\n      \n      // Wisp length based on energy\n      const length = 100 + energyFactor * 200 + (Math.sin(timeRef.current + i) * 50);\n      \n      // Wisp width varies\n      const width = 20 + (i % 5) * 10 + energyFactor * 30;\n      \n      // Wisp starting point (from core edge)\n      const startX = centerX + Math.cos(angle) * coreSize * 0.8;\n      const startY = centerY + Math.sin(angle) * coreSize * 0.8;\n      \n      // Wisp end point\n      const endX = centerX + Math.cos(angle) * (coreSize + length);\n      const endY = centerY + Math.sin(angle) * (coreSize + length);\n      \n      // Control points for curved wisp\n      const ctrlX1 = centerX + Math.cos(angle + 0.2) * (coreSize + length * 0.3);\n      const ctrlY1 = centerY + Math.sin(angle + 0.2) * (coreSize + length * 0.3);\n      const ctrlX2 = centerX + Math.cos(angle - 0.2) * (coreSize + length * 0.6);\n      const ctrlY2 = centerY + Math.sin(angle - 0.2) * (coreSize + length * 0.6);\n      \n      // Wisp color based on position in spectrum\n      const hue = (i / wispCount) * 60 + 240; // Blue to purple range\n      const wispColor = `hsla(${hue}, 100%, ${50 + energyFactor * 30}%, ${0.2 + energyFactor * 0.3})`;\n      \n      // Draw the wisp as a gradient along a bezier curve\n      const gradient = ctx.createLinearGradient(startX, startY, endX, endY);\n      gradient.addColorStop(0, adjustColor(color, 20) + '80'); // Semi-transparent\n      gradient.addColorStop(0.5, wispColor);\n      gradient.addColorStop(1, 'rgba(0, 0, 0, 0)'); // Fade out\n      \n      ctx.strokeStyle = gradient;\n      ctx.lineWidth = width;\n      ctx.lineCap = 'round';\n      \n      // Draw curved wisp\n      ctx.beginPath();\n      ctx.moveTo(startX, startY);\n      ctx.bezierCurveTo(ctrlX1, ctrlY1, ctrlX2, ctrlY2, endX, endY);\n      ctx.stroke();\n    }\n    \n    // Add some stars in the background\n    const starCount = 100;\n    ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';\n    \n    for (let i = 0; i < starCount; i++) {\n      // Star position based on index but with some variation over time\n      const angle = (i / starCount) * Math.PI * 2 + timeRef.current * 0.01;\n      const distance = 100 + (i % 10) * 50 + Math.sin(timeRef.current * 0.2 + i) * 20;\n      \n      const x = centerX + Math.cos(angle) * distance;\n      const y = centerY + Math.sin(angle) * distance;\n      \n      // Star size pulsates with high frequencies\n      const size = 1 + (dataArray[Math.floor(i / starCount * bufferLength)] / 255) * 2;\n      \n      ctx.beginPath();\n      ctx.arc(x, y, size, 0, Math.PI * 2);\n      ctx.fill();\n    }\n    \n    // Reset composite operation\n    ctx.globalCompositeOperation = 'source-over';\n  };\n\n  const drawCityscape = (ctx, dataArray, timeArray, bufferLength, cachedParameters) => {\n    // Safety check - ensure canvas reference exists\n    if (!canvasRef.current) {\n      console.error(\"Canvas reference is null in drawCityscape\");\n      return;\n    }\n    \n    // Apply parameters\n    const color = cachedParameters.color || '#ff9900'; // Orange default\n    const reactivity = (cachedParameters.reactivity || 50) / 50; // 0-1 reactivity\n    const density = (cachedParameters.density || 50) / 50; // 0-1 density\n    const detail = (cachedParameters.detail || 50) / 50; // 0-1 detail\n    \n    const width = canvasRef.current.width;\n    const height = canvasRef.current.height;\n    \n    // Define maxHeight at the top level of the function\n    const maxHeight = height * 0.7; // Max 70% of screen height\n    \n    // Create night sky gradient background\n    const skyGradient = ctx.createLinearGradient(0, 0, 0, height);\n    skyGradient.addColorStop(0, 'rgb(0, 5, 20)');\n    skyGradient.addColorStop(1, 'rgb(20, 10, 40)');\n    ctx.fillStyle = skyGradient;\n    ctx.fillRect(0, 0, width, height);\n    \n    // Add stars to the sky\n    const starCount = Math.floor(100 * detail);\n    ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';\n    \n    for (let i = 0; i < starCount; i++) {\n      const x = Math.random() * width;\n      const y = Math.random() * height * 0.6; // Stars only in top 60% (sky)\n      const size = Math.random() * 2 + 0.5;\n      \n      // Make stars twinkle based on high frequencies\n      const twinkle = 0.5 + (dataArray[Math.floor(bufferLength * 0.8 + (i % 20))] / 255) * 0.5;\n      \n      ctx.globalAlpha = twinkle;\n      ctx.beginPath();\n      ctx.arc(x, y, size, 0, Math.PI * 2);\n      ctx.fill();\n    }\n    \n    ctx.globalAlpha = 1.0;\n    \n    // Add a moon\n    const moonX = width * 0.8;\n    const moonY = height * 0.2;\n    const moonSize = width * 0.05;\n    const moonGlow = ctx.createRadialGradient(moonX, moonY, 0, moonX, moonY, moonSize * 2);\n    moonGlow.addColorStop(0, 'rgba(255, 255, 230, 1)');\n    moonGlow.addColorStop(0.5, 'rgba(255, 255, 230, 0.3)');\n    moonGlow.addColorStop(1, 'rgba(255, 255, 230, 0)');\n    \n    ctx.fillStyle = moonGlow;\n    ctx.beginPath();\n    ctx.arc(moonX, moonY, moonSize * 2, 0, Math.PI * 2);\n    ctx.fill();\n    \n    ctx.fillStyle = 'rgba(255, 255, 230, 1)';\n    ctx.beginPath();\n    ctx.arc(moonX, moonY, moonSize, 0, Math.PI * 2);\n    ctx.fill();\n    \n    // Calculate frequency bands for buildings\n    const bandCount = Math.floor(20 + density * 60); // 20-80 buildings\n    const buildings = [];\n    \n    // Calculate average energy for each frequency band\n    for (let i = 0; i < bandCount; i++) {\n      const startBin = Math.floor((i / bandCount) * (bufferLength / 2));\n      const endBin = Math.floor(((i + 1) / bandCount) * (bufferLength / 2));\n      \n      const energy = getAverageEnergy(dataArray, startBin, endBin) * reactivity;\n      \n      // Building properties\n      const buildingWidth = width / bandCount;\n      // maxHeight is now defined at the top level\n      const buildingHeight = (0.1 + energy * 0.9) * maxHeight; // Min 10% height\n      \n      // Building position\n      const x = i * buildingWidth;\n      const y = height - buildingHeight;\n      \n      // Building color based on height (taller = brighter)\n      const brightness = 20 + (buildingHeight / maxHeight) * 60;\n      const buildingColor = adjustColor(color, brightness - 40);\n      \n      buildings.push({\n        x,\n        y,\n        width: buildingWidth,\n        height: buildingHeight,\n        color: buildingColor,\n        energy\n      });\n    }\n    \n    // Draw buildings from back to front\n    buildings.forEach((building, i) => {\n      // Draw main building shape\n      ctx.fillStyle = building.color;\n      ctx.fillRect(building.x, building.y, building.width, building.height);\n      \n      // Add building details based on detail parameter\n      if (detail > 0.3) {\n        // Add windows\n        const windowSize = Math.max(3, building.width * 0.15);\n        const windowSpacing = windowSize * 1.5;\n        const windowsPerRow = Math.floor(building.width / windowSpacing);\n        const windowsPerColumn = Math.floor(building.height / windowSpacing);\n        \n        // Window color based on energy (more energy = more lit windows)\n        const windowAlpha = 0.3 + building.energy * 0.7;\n        const windowColor = `rgba(255, 255, 200, ${windowAlpha})`;\n        \n        ctx.fillStyle = windowColor;\n        \n        for (let row = 0; row < windowsPerColumn; row++) {\n          for (let col = 0; col < windowsPerRow; col++) {\n            // Randomly light up windows based on energy\n            if (Math.random() < (0.2 + building.energy * 0.8)) {\n              const windowX = building.x + col * windowSpacing + (windowSpacing - windowSize) / 2;\n              const windowY = building.y + row * windowSpacing + (windowSpacing - windowSize) / 2;\n              \n              ctx.fillRect(windowX, windowY, windowSize, windowSize);\n            }\n          }\n        }\n        \n        // Add building top details for taller buildings\n        if (building.height > maxHeight * 0.4 && detail > 0.6) {\n          // Antenna or spire\n          ctx.strokeStyle = 'rgba(100, 100, 100, 0.7)';\n          ctx.lineWidth = 2;\n          ctx.beginPath();\n          const antennaX = building.x + building.width / 2;\n          const antennaHeight = building.height * 0.2;\n          ctx.moveTo(antennaX, building.y);\n          ctx.lineTo(antennaX, building.y - antennaHeight);\n          ctx.stroke();\n          \n          // Blinking light on top that pulses with beat\n          const beatEnergy = getAverageEnergy(dataArray, 0, 10) * reactivity;\n          if (beatEnergy > 0.7 || Math.sin(timeRef.current * 2) > 0.7) {\n            ctx.fillStyle = 'rgba(255, 0, 0, 0.8)';\n            ctx.beginPath();\n            ctx.arc(antennaX, building.y - antennaHeight, 3, 0, Math.PI * 2);\n            ctx.fill();\n          }\n        }\n      }\n    });\n    \n    // Add foreground silhouette\n    const foregroundHeight = height * 0.05;\n    ctx.fillStyle = 'rgb(0, 0, 0)';\n    ctx.fillRect(0, height - foregroundHeight, width, foregroundHeight);\n  };\n\n  const drawWaterfall = (ctx, dataArray, timeArray, bufferLength, cachedParameters) => {\n    // Safety check - ensure canvas reference exists\n    if (!canvasRef.current) {\n      console.error(\"Canvas reference is null in drawWaterfall\");\n      return;\n    }\n    \n    // Apply parameters\n    const color = cachedParameters.color || '#00ccff'; // Cyan default\n    const reactivity = (cachedParameters.reactivity || 50) / 50; // 0-1 reactivity\n    const speed = (cachedParameters.speed || 50) / 50; // 0-1 speed\n    const detail = (cachedParameters.detail || 50) / 50; // 0-1 detail\n    \n    const width = canvasRef.current.width;\n    const height = canvasRef.current.height;\n    \n    // Initialize waterfall history if it doesn't exist\n    if (!window.waterfallHistory) {\n      window.waterfallHistory = [];\n      for (let i = 0; i < height; i++) {\n        window.waterfallHistory.push(new Uint8Array(bufferLength));\n      }\n    }\n    \n    // Update waterfall history - shift all rows down\n    if (Math.random() < speed * 0.2 + 0.1) { // Control speed of waterfall\n      for (let i = window.waterfallHistory.length - 1; i > 0; i--) {\n        window.waterfallHistory[i] = window.waterfallHistory[i - 1];\n      }\n      \n      // Add new data at the top\n      window.waterfallHistory[0] = new Uint8Array(dataArray);\n    }\n    \n    // Create a dark blue background\n    const bgGradient = ctx.createLinearGradient(0, 0, 0, height);\n    bgGradient.addColorStop(0, 'rgb(0, 10, 30)');\n    bgGradient.addColorStop(1, 'rgb(0, 5, 15)');\n    ctx.fillStyle = bgGradient;\n    ctx.fillRect(0, 0, width, height);\n    \n    // Draw the waterfall\n    const barWidth = width / bufferLength;\n    const barCount = Math.min(bufferLength, Math.floor(width / 2)); // Limit for performance\n    const skipFactor = Math.floor(bufferLength / barCount);\n    \n    // Draw each row of the waterfall\n    for (let row = 0; row < window.waterfallHistory.length; row++) {\n      const rowData = window.waterfallHistory[row];\n      \n      for (let i = 0; i < barCount; i++) {\n        const dataIndex = i * skipFactor;\n        const value = rowData[dataIndex] / 255.0 * reactivity;\n        \n        if (value < 0.05) continue; // Skip very low values for performance\n        \n        // Calculate position\n        const x = i * barWidth * skipFactor;\n        const y = row;\n        \n        // Color based on frequency and intensity\n        const hue = (i / barCount) * 180 + 180; // Blue to cyan range\n        const saturation = 80 + value * 20;\n        const lightness = value * 60;\n        const alpha = 0.3 + value * 0.7;\n        \n        ctx.fillStyle = `hsla(${hue}, ${saturation}%, ${lightness}%, ${alpha})`;\n        ctx.fillRect(x, y, barWidth * skipFactor, 1);\n      }\n    }\n    \n    // Draw water surface at the top with reflection\n    const surfaceY = 50;\n    ctx.fillStyle = 'rgba(0, 150, 255, 0.2)';\n    ctx.fillRect(0, 0, width, surfaceY);\n    \n    // Draw ripples on the surface based on bass frequencies\n    const rippleCount = Math.floor(5 + detail * 15);\n    const bassEnergy = getAverageEnergy(dataArray, 0, Math.floor(bufferLength * 0.1)) * reactivity;\n    \n    ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';\n    ctx.lineWidth = 1;\n    \n    for (let i = 0; i < rippleCount; i++) {\n      if (Math.random() > bassEnergy * 0.5) continue;\n      \n      const x = Math.random() * width;\n      const y = Math.random() * surfaceY;\n      const size = 5 + Math.random() * 20 * bassEnergy;\n      \n      ctx.beginPath();\n      ctx.arc(x, y, size, 0, Math.PI * 2);\n      ctx.stroke();\n      \n      // Smaller inner ripple\n      ctx.beginPath();\n      ctx.arc(x, y, size * 0.7, 0, Math.PI * 2);\n      ctx.stroke();\n    }\n    \n    // Draw splashes when bass hits are detected\n    if (bassEnergy > 0.7) {\n      const splashCount = Math.floor(bassEnergy * 10);\n      \n      for (let i = 0; i < splashCount; i++) {\n        // Create splash particles\n        const x = Math.random() * width;\n        const particleCount = Math.floor(5 + Math.random() * 10);\n        \n        ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';\n        \n        for (let j = 0; j < particleCount; j++) {\n          const particleX = x + (Math.random() - 0.5) * 40;\n          const particleY = Math.random() * 30;\n          const size = 1 + Math.random() * 3;\n          \n          ctx.beginPath();\n          ctx.arc(particleX, particleY, size, 0, Math.PI * 2);\n          ctx.fill();\n        }\n      }\n    }\n    \n    // Draw waterfall edge highlights\n    const edgeGradient = ctx.createLinearGradient(0, surfaceY, 0, height);\n    edgeGradient.addColorStop(0, 'rgba(255, 255, 255, 0.4)');\n    edgeGradient.addColorStop(0.1, 'rgba(255, 255, 255, 0.1)');\n    edgeGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');\n    \n    ctx.fillStyle = edgeGradient;\n    ctx.fillRect(0, surfaceY, 10, height - surfaceY); // Left edge\n    ctx.fillRect(width - 10, surfaceY, 10, height - surfaceY); // Right edge\n    \n    // Draw mist at the bottom\n    const mistGradient = ctx.createLinearGradient(0, height - 100, 0, height);\n    mistGradient.addColorStop(0, 'rgba(255, 255, 255, 0)');\n    mistGradient.addColorStop(1, 'rgba(255, 255, 255, 0.2)');\n    \n    ctx.fillStyle = mistGradient;\n    ctx.fillRect(0, height - 100, width, 100);\n  };\n\n  const drawConstellation = (ctx, dataArray, timeArray, bufferLength, cachedParameters) => {\n    // Safety check - ensure canvas reference exists\n    if (!canvasRef.current) {\n      console.error(\"Canvas reference is null in drawConstellation\");\n      return;\n    }\n    \n    // Apply parameters\n    const color = cachedParameters.color || '#ffffff'; // White default\n    const reactivity = (cachedParameters.reactivity || 50) / 50; // 0-1 reactivity\n    const density = (cachedParameters.density || 50) / 50; // 0-1 density\n    const speed = (cachedParameters.speed || 50) / 100; // 0-0.5 speed\n    \n    const width = canvasRef.current.width;\n    const height = canvasRef.current.height;\n    \n    // Create a dark space background\n    const bgGradient = ctx.createRadialGradient(width/2, height/2, 0, width/2, height/2, Math.max(width, height));\n    bgGradient.addColorStop(0, 'rgb(10, 10, 30)');\n    bgGradient.addColorStop(1, 'rgb(0, 0, 10)');\n    ctx.fillStyle = bgGradient;\n    ctx.fillRect(0, 0, width, height);\n    \n    // Calculate overall audio energy for dynamic connection behavior\n    let overallEnergy = 0;\n    const sampleSize = Math.min(bufferLength, 100); // Sample a portion of the frequency data\n    for (let i = 0; i < sampleSize; i++) {\n      overallEnergy += dataArray[i] / 255.0;\n    }\n    overallEnergy = (overallEnergy / sampleSize) * reactivity;\n    \n    // Initialize stars if they don't exist\n    if (!window.constellationStars) {\n      window.constellationStars = [];\n      const starCount = Math.floor(50 + density * 150); // 50-200 stars\n      \n      for (let i = 0; i < starCount; i++) {\n        // Assign each star to a frequency band\n        const freqBand = Math.floor(Math.random() * bufferLength);\n        \n        window.constellationStars.push({\n          x: Math.random() * width,\n          y: Math.random() * height,\n          size: 1 + Math.random() * 3,\n          brightness: 0.3 + Math.random() * 0.7,\n          freqBand: freqBand,\n          hue: Math.random() * 60 + 180, // Blue to cyan range\n          connections: []\n        });\n      }\n    }\n    \n    // Update star positions slightly based on time\n    const stars = window.constellationStars;\n    const rotationCenter = { x: width / 2, y: height / 2 };\n    // Reduce rotation speed significantly (5x slower)\n    const rotationSpeed = speed * 0.002; // Changed from 0.01 to 0.002\n    \n    for (let i = 0; i < stars.length; i++) {\n      const star = stars[i];\n      \n      // Calculate distance from center\n      const dx = star.x - rotationCenter.x;\n      const dy = star.y - rotationCenter.y;\n      const distance = Math.sqrt(dx * dx + dy * dy);\n      \n      // Calculate rotation angle (further stars rotate slower)\n      const rotationFactor = 1 - (distance / Math.max(width, height));\n      const angle = rotationSpeed * rotationFactor;\n      \n      // Apply rotation\n      const cos = Math.cos(angle);\n      const sin = Math.sin(angle);\n      \n      const newX = rotationCenter.x + (dx * cos - dy * sin);\n      const newY = rotationCenter.y + (dx * sin + dy * cos);\n      \n      // Keep stars within bounds\n      star.x = Math.max(0, Math.min(width, newX));\n      star.y = Math.max(0, Math.min(height, newY));\n      \n      // Update star brightness based on its frequency band\n      const freqValue = dataArray[star.freqBand] / 255.0;\n      star.brightness = 0.3 + freqValue * reactivity * 0.7;\n    }\n    \n    // Find connections between stars based on audio patterns\n    // Adjust max connections based on overall energy - more connections when music is louder\n    const baseMaxConnections = Math.floor(density * 100);\n    const maxConnections = Math.floor(baseMaxConnections * (1 + overallEnergy));\n    \n    // Adjust connection threshold based on energy - allow longer connections when music is louder\n    const baseConnectionThreshold = 150 * (1 - density * 0.5);\n    const connectionThreshold = baseConnectionThreshold * (1 + overallEnergy * 0.5);\n    \n    // Clear previous connections\n    stars.forEach(star => star.connections = []);\n    \n    // Find new connections\n    let connectionCount = 0;\n    \n    // Detect beats for connection triggers\n    const bassEnergy = getAverageEnergy(dataArray, 0, Math.floor(bufferLength * 0.1)) * reactivity;\n    const midEnergy = getAverageEnergy(dataArray, Math.floor(bufferLength * 0.1), Math.floor(bufferLength * 0.5)) * reactivity;\n    const beatDetected = bassEnergy > 0.6 || midEnergy > 0.7;\n    \n    for (let i = 0; i < stars.length && connectionCount < maxConnections; i++) {\n      const star1 = stars[i];\n      \n      for (let j = i + 1; j < stars.length && connectionCount < maxConnections; j++) {\n        const star2 = stars[j];\n        \n        // Calculate distance between stars\n        const dx = star1.x - star2.x;\n        const dy = star1.y - star2.y;\n        const distance = Math.sqrt(dx * dx + dy * dy);\n        \n        // Connect stars if they're close enough and their frequencies are related\n        const freqDiff = Math.abs(star1.freqBand - star2.freqBand);\n        \n        // More sophisticated rhythm pattern detection\n        const rhythmicPattern = beatDetected || \n                               (timeRef.current * 2) % 1 < (0.3 + overallEnergy * 0.4);\n        \n        // Lower connection threshold when beat is detected\n        const effectiveThreshold = beatDetected ? connectionThreshold * 1.3 : connectionThreshold;\n        \n        if (distance < effectiveThreshold && \n            (freqDiff < 10 || freqDiff > bufferLength - 10 || rhythmicPattern)) {\n          \n          // Calculate connection strength based on audio energy\n          const freqAvg = (dataArray[star1.freqBand] + dataArray[star2.freqBand]) / (2 * 255);\n          \n          // Increase strength during beats\n          const strengthMultiplier = beatDetected ? 1.5 : 1.0;\n          const strength = (0.1 + freqAvg * reactivity * 0.9) * strengthMultiplier;\n          \n          // Lower threshold during high energy moments\n          const energyThreshold = 0.2 - (overallEnergy * 0.1);\n          \n          if (strength > energyThreshold) { // Only connect if there's enough energy\n            star1.connections.push({ star: star2, strength });\n            connectionCount++;\n          }\n        }\n      }\n    }\n    \n    // Draw connections first (behind stars)\n    ctx.lineCap = 'round';\n    \n    stars.forEach(star => {\n      star.connections.forEach(conn => {\n        const gradient = ctx.createLinearGradient(star.x, star.y, conn.star.x, conn.star.y);\n        \n        // Create gradient based on star colors\n        const color1 = `hsla(${star.hue}, 100%, 70%, ${conn.strength})`;\n        const color2 = `hsla(${conn.star.hue}, 100%, 70%, ${conn.strength})`;\n        \n        gradient.addColorStop(0, color1);\n        gradient.addColorStop(1, color2);\n        \n        ctx.strokeStyle = gradient;\n        ctx.lineWidth = 1 + conn.strength * 2;\n        \n        ctx.beginPath();\n        ctx.moveTo(star.x, star.y);\n        ctx.lineTo(conn.star.x, conn.star.y);\n        ctx.stroke();\n      });\n    });\n    \n    // Draw stars\n    stars.forEach(star => {\n      // Star color based on frequency\n      const freqValue = dataArray[star.freqBand] / 255.0;\n      const starColor = `hsla(${star.hue}, 100%, 70%, ${star.brightness})`;\n      \n      // Draw star glow\n      const glowSize = star.size * (1 + freqValue * reactivity * 3);\n      const glow = ctx.createRadialGradient(star.x, star.y, 0, star.x, star.y, glowSize);\n      glow.addColorStop(0, starColor);\n      glow.addColorStop(1, 'rgba(0, 0, 0, 0)');\n      \n      ctx.fillStyle = glow;\n      ctx.beginPath();\n      ctx.arc(star.x, star.y, glowSize, 0, Math.PI * 2);\n      ctx.fill();\n      \n      // Draw star core\n      ctx.fillStyle = 'rgba(255, 255, 255, ' + star.brightness + ')';\n      ctx.beginPath();\n      ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);\n      ctx.fill();\n    });\n    \n    // Draw constellation names occasionally\n    if (Math.random() < 0.005) {\n      const constellationNames = [\n        'Audionis', 'Beatoria', 'Rhythmica', 'Melodius', \n        'Harmonix', 'Synthus', 'Bassus Major', 'Treble Minor'\n      ];\n      \n      const name = constellationNames[Math.floor(Math.random() * constellationNames.length)];\n      const x = 100 + Math.random() * (width - 200);\n      const y = 100 + Math.random() * (height - 200);\n      \n      ctx.font = '20px Arial';\n      ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';\n      ctx.fillText(name, x, y);\n    }\n  };\n\n  const drawMandala = (ctx, dataArray, timeArray, bufferLength, cachedParameters) => {\n    // Safety check - ensure canvas reference exists\n    if (!canvasRef.current) {\n      console.error(\"Canvas reference is null in drawMandala\");\n      return;\n    }\n    \n    // Apply parameters\n    const color = cachedParameters.color || '#ff00ff'; // Magenta default\n    const reactivity = (cachedParameters.reactivity || 50) / 50; // 0-1 reactivity\n    const complexity = (cachedParameters.complexity || 50) / 50; // 0-1 complexity\n    const speed = (cachedParameters.speed || 50) / 100; // 0-0.5 speed\n    \n    const width = canvasRef.current.width;\n    const height = canvasRef.current.height;\n    const centerX = width / 2;\n    const centerY = height / 2;\n    \n    // Create a dark background with subtle gradient\n    const bgGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, Math.max(width, height) / 2);\n    bgGradient.addColorStop(0, 'rgb(10, 0, 20)');\n    bgGradient.addColorStop(1, 'rgb(0, 0, 10)');\n    ctx.fillStyle = bgGradient;\n    ctx.fillRect(0, 0, width, height);\n    \n    // Calculate average energy in different frequency bands\n    const bandCount = Math.floor(4 + complexity * 12); // 4-16 bands\n    const energyBands = [];\n    \n    for (let i = 0; i < bandCount; i++) {\n      const startBin = Math.floor((i / bandCount) * (bufferLength / 2));\n      const endBin = Math.floor(((i + 1) / bandCount) * (bufferLength / 2));\n      energyBands.push(getAverageEnergy(dataArray, startBin, endBin) * reactivity);\n    }\n    \n    // Calculate overall energy for scaling the mandala\n    const overallEnergy = energyBands.reduce((sum, energy) => sum + energy, 0) / bandCount;\n    \n    // Base radius of the mandala\n    const baseRadius = Math.min(width, height) * 0.35;\n    const radius = baseRadius * (0.8 + overallEnergy * 0.4);\n    \n    // Number of symmetry axes\n    const symmetryCount = Math.floor(4 + complexity * 12); // 4-16 symmetry axes\n    \n    // Draw the mandala layers from outside to inside\n    const layerCount = Math.floor(3 + complexity * 7); // 3-10 layers\n    \n    for (let layer = 0; layer < layerCount; layer++) {\n      // Layer properties\n      const layerRadius = radius * (1 - layer / layerCount * 0.8);\n      const layerEnergy = energyBands[layer % bandCount];\n      const layerRotation = timeRef.current * speed * (1 + layer * 0.1) + layer * Math.PI / layerCount;\n      \n      // Layer color based on position and energy\n      const hue = (layer / layerCount) * 300 + timeRef.current * 10;\n      const saturation = 80 + layerEnergy * 20;\n      const lightness = 40 + layerEnergy * 30;\n      const layerColor = `hsl(${hue}, ${saturation}%, ${lightness}%)`;\n      \n      // Draw the layer elements\n      ctx.strokeStyle = layerColor;\n      ctx.fillStyle = adjustColor(layerColor, -20);\n      \n      // Element complexity increases with layer\n      const elementComplexity = 0.2 + (layer / layerCount) * 0.8 * complexity;\n      \n      // Draw symmetrical elements\n      for (let i = 0; i < symmetryCount; i++) {\n        const angle = (i / symmetryCount) * Math.PI * 2 + layerRotation;\n        \n        // Draw petal/element\n        drawMandalaElement(\n          ctx, \n          centerX, \n          centerY, \n          angle, \n          layerRadius, \n          layerEnergy, \n          elementComplexity,\n          layer,\n          symmetryCount\n        );\n      }\n      \n      // Draw connecting circles between layers\n      if (layer > 0 && layer < layerCount - 1) {\n        const circleRadius = layerRadius * (0.1 + layerEnergy * 0.1);\n        ctx.lineWidth = 1 + layerEnergy * 3;\n        ctx.beginPath();\n        ctx.arc(centerX, centerY, layerRadius, 0, Math.PI * 2);\n        ctx.stroke();\n      }\n    }\n    \n    // Draw central mandala element\n    const centerSize = radius * 0.2 * (0.8 + overallEnergy * 0.4);\n    const centerGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, centerSize);\n    centerGradient.addColorStop(0, adjustColor(color, 30));\n    centerGradient.addColorStop(0.7, adjustColor(color, 10));\n    centerGradient.addColorStop(1, 'rgba(0, 0, 0, 0)');\n    \n    ctx.fillStyle = centerGradient;\n    ctx.beginPath();\n    ctx.arc(centerX, centerY, centerSize, 0, Math.PI * 2);\n    ctx.fill();\n    \n    // Draw sacred geometry in the center\n    ctx.strokeStyle = adjustColor(color, 50);\n    ctx.lineWidth = 1;\n    \n    // Draw flower of life pattern\n    const flowerRadius = centerSize * 0.6;\n    const petalCount = Math.floor(6 + overallEnergy * 6);\n    \n    for (let i = 0; i < petalCount; i++) {\n      const angle = (i / petalCount) * Math.PI * 2 + timeRef.current * speed;\n      const x = centerX + Math.cos(angle) * flowerRadius * 0.5;\n      const y = centerY + Math.sin(angle) * flowerRadius * 0.5;\n      \n      ctx.beginPath();\n      ctx.arc(x, y, flowerRadius * 0.5, 0, Math.PI * 2);\n      ctx.stroke();\n    }\n    \n    // Function to draw a single mandala element\n    function drawMandalaElement(ctx, centerX, centerY, angle, radius, energy, complexity, layer, symmetryCount) {\n      // Calculate element position\n      const x = centerX + Math.cos(angle) * radius;\n      const y = centerY + Math.sin(angle) * radius;\n      \n      // Element size based on energy\n      const size = radius * 0.2 * (0.5 + energy * 0.8);\n      \n      ctx.save();\n      ctx.translate(x, y);\n      ctx.rotate(angle + Math.PI / 2);\n      \n      // Choose element type based on layer\n      const elementType = layer % 4;\n      \n      ctx.lineWidth = 1 + energy * 2;\n      \n      switch (elementType) {\n        case 0: // Petal shape\n          ctx.beginPath();\n          ctx.moveTo(0, -size);\n          ctx.bezierCurveTo(\n            size * complexity, -size * 0.5, \n            size * complexity, size * 0.5, \n            0, size\n          );\n          ctx.bezierCurveTo(\n            -size * complexity, size * 0.5, \n            -size * complexity, -size * 0.5, \n            0, -size\n          );\n          ctx.fill();\n          ctx.stroke();\n          break;\n          \n        case 1: // Triangular element\n          ctx.beginPath();\n          ctx.moveTo(0, -size);\n          ctx.lineTo(size * 0.7 * complexity, size * 0.5);\n          ctx.lineTo(-size * 0.7 * complexity, size * 0.5);\n          ctx.closePath();\n          ctx.fill();\n          ctx.stroke();\n          break;\n          \n        case 2: // Circular element\n          ctx.beginPath();\n          ctx.arc(0, 0, size * 0.5, 0, Math.PI * 2);\n          ctx.fill();\n          ctx.stroke();\n          \n          // Add inner detail\n          if (complexity > 0.5) {\n            ctx.beginPath();\n            ctx.arc(0, 0, size * 0.25, 0, Math.PI * 2);\n            ctx.stroke();\n          }\n          break;\n          \n        case 3: // Spiral element\n          ctx.beginPath();\n          for (let i = 0; i < Math.PI * 2 * complexity; i += 0.1) {\n            const spiralRadius = (i / (Math.PI * 2)) * size;\n            const sx = Math.cos(i) * spiralRadius;\n            const sy = Math.sin(i) * spiralRadius;\n            \n            if (i === 0) {\n              ctx.moveTo(sx, sy);\n            } else {\n              ctx.lineTo(sx, sy);\n            }\n          }\n          ctx.stroke();\n          break;\n      }\n      \n      ctx.restore();\n    }\n  };\n\n  const drawOcean = (ctx, dataArray, timeArray, bufferLength, cachedParameters) => {\n    // Safety check - ensure canvas reference exists\n    if (!canvasRef.current) {\n      console.error(\"Canvas reference is null in drawOcean\");\n      return;\n    }\n    \n    // Apply parameters\n    const color = cachedParameters.color || '#0066cc'; // Ocean blue default\n    const reactivity = (cachedParameters.reactivity || 50) / 50; // 0-1 reactivity\n    const detail = (cachedParameters.detail || 50) / 50; // 0-1 detail\n    const speed = (cachedParameters.speed || 50) / 100; // 0-0.5 speed\n    \n    const width = canvasRef.current.width;\n    const height = canvasRef.current.height;\n    \n    // Initialize wave points if they don't exist\n    if (!window.oceanWaves) {\n      window.oceanWaves = [];\n      const waveCount = 5; // Number of wave layers\n      \n      for (let w = 0; w < waveCount; w++) {\n        const pointCount = Math.floor(20 + detail * 60); // 20-80 points per wave\n        const points = [];\n        \n        for (let i = 0; i <= pointCount; i++) {\n          points.push({\n            x: (i / pointCount) * width,\n            y: height * (0.5 + (w * 0.1)), // Stagger waves vertically\n            baseY: height * (0.5 + (w * 0.1)),\n            offset: Math.random() * Math.PI * 2\n          });\n        }\n        \n        window.oceanWaves.push({\n          points,\n          speed: 0.5 + (w / waveCount) * 0.5, // Different speeds for each wave\n          amplitude: 10 + (waveCount - w) * 5, // Different amplitudes (higher for foreground)\n          color: adjustColor(color, -w * 10) // Darker for background waves\n        });\n      }\n    }\n    \n    // Create sky gradient\n    const skyGradient = ctx.createLinearGradient(0, 0, 0, height * 0.5);\n    \n    // Get bass and mid frequencies for sky color\n    const bassEnergy = getAverageEnergy(dataArray, 0, Math.floor(bufferLength * 0.1)) * reactivity;\n    const midEnergy = getAverageEnergy(dataArray, Math.floor(bufferLength * 0.1), Math.floor(bufferLength * 0.5)) * reactivity;\n    \n    // Sky colors change with audio\n    const skyTopColor = `rgb(${20 + bassEnergy * 50}, ${100 + midEnergy * 50}, ${180 + bassEnergy * 20})`;\n    const skyBottomColor = `rgb(${100 + midEnergy * 30}, ${150 + bassEnergy * 30}, ${200 + midEnergy * 20})`;\n    \n    skyGradient.addColorStop(0, skyTopColor);\n    skyGradient.addColorStop(1, skyBottomColor);\n    \n    // Fill sky\n    ctx.fillStyle = skyGradient;\n    ctx.fillRect(0, 0, width, height * 0.5);\n    \n    // Draw sun/moon\n    const celestialSize = width * 0.08;\n    const celestialX = width * 0.8;\n    const celestialY = height * 0.2;\n    \n    // Sun/moon color based on audio\n    const celestialColor = `rgba(${255 - bassEnergy * 50}, ${255 - bassEnergy * 20}, ${220 - bassEnergy * 20}, 0.8)`;\n    \n    // Draw glow\n    const glowGradient = ctx.createRadialGradient(celestialX, celestialY, 0, celestialX, celestialY, celestialSize * 2);\n    glowGradient.addColorStop(0, celestialColor);\n    glowGradient.addColorStop(1, 'rgba(255, 255, 220, 0)');\n    \n    ctx.fillStyle = glowGradient;\n    ctx.beginPath();\n    ctx.arc(celestialX, celestialY, celestialSize * 2, 0, Math.PI * 2);\n    ctx.fill();\n    \n    // Draw sun/moon body\n    ctx.fillStyle = celestialColor;\n    ctx.beginPath();\n    ctx.arc(celestialX, celestialY, celestialSize, 0, Math.PI * 2);\n    ctx.fill();\n    \n    // Draw clouds if detail is high enough\n    if (detail > 0.4) {\n      const cloudCount = Math.floor(3 + detail * 7); // 3-10 clouds\n      \n      for (let i = 0; i < cloudCount; i++) {\n        // Cloud position\n        const cloudX = ((i / cloudCount) * width * 1.5) % (width * 1.2) - width * 0.1 + timeRef.current * speed * 20 % width;\n        const cloudY = height * (0.1 + Math.sin(i) * 0.1);\n        const cloudSize = width * (0.05 + (i % 3) * 0.03);\n        \n        // Cloud color affected by audio\n        const cloudOpacity = 0.7 + midEnergy * 0.3;\n        ctx.fillStyle = `rgba(255, 255, 255, ${cloudOpacity})`;\n        \n        // Draw cloud as a group of circles\n        for (let j = 0; j < 5; j++) {\n          const offsetX = (j - 2) * cloudSize * 0.5;\n          const offsetY = Math.sin(j * 1.5) * cloudSize * 0.2;\n          const size = cloudSize * (0.7 + Math.sin(j) * 0.3);\n          \n          ctx.beginPath();\n          ctx.arc(cloudX + offsetX, cloudY + offsetY, size, 0, Math.PI * 2);\n          ctx.fill();\n        }\n      }\n    }\n    \n    // Update and draw waves\n    const waves = window.oceanWaves;\n    \n    // Calculate frequency bands for wave modulation\n    const bandCount = waves.length;\n    const energyBands = [];\n    \n    for (let i = 0; i < bandCount; i++) {\n      const startBin = Math.floor((i / bandCount) * (bufferLength / 2));\n      const endBin = Math.floor(((i + 1) / bandCount) * (bufferLength / 2));\n      energyBands.push(getAverageEnergy(dataArray, startBin, endBin) * reactivity);\n    }\n    \n    // Create ocean base gradient\n    const oceanGradient = ctx.createLinearGradient(0, height * 0.5, 0, height);\n    oceanGradient.addColorStop(0, adjustColor(color, 20));\n    oceanGradient.addColorStop(1, adjustColor(color, -30));\n    \n    // Fill ocean base\n    ctx.fillStyle = oceanGradient;\n    ctx.fillRect(0, height * 0.5, width, height * 0.5);\n    \n    // Update and draw each wave\n    for (let w = 0; w < waves.length; w++) {\n      const wave = waves[w];\n      const energy = energyBands[w % energyBands.length];\n      \n      // Update wave points\n      for (let i = 0; i < wave.points.length; i++) {\n        const point = wave.points[i];\n        \n        // Wave motion: combination of time, position, and audio reactivity\n        const waveTime = timeRef.current * speed * wave.speed;\n        const wavePos = (i / wave.points.length) * Math.PI * 10 + point.offset;\n        \n        // Primary wave motion\n        const baseWave = Math.sin(waveTime + wavePos) * wave.amplitude;\n        \n        // Secondary choppiness based on audio\n        const choppiness = Math.sin(waveTime * 2 + wavePos * 2) * wave.amplitude * 0.3 * energy;\n        \n        // Update point position\n        point.y = point.baseY + baseWave + choppiness;\n      }\n      \n      // Draw the wave\n      ctx.fillStyle = wave.color;\n      ctx.beginPath();\n      ctx.moveTo(0, height);\n      ctx.lineTo(wave.points[0].x, wave.points[0].y);\n      \n      // Draw wave using bezier curves for smoothness\n      for (let i = 0; i < wave.points.length - 1; i++) {\n        const current = wave.points[i];\n        const next = wave.points[i + 1];\n        \n        // Control points for bezier curve\n        const cpX1 = current.x + (next.x - current.x) / 3;\n        const cpY1 = current.y;\n        const cpX2 = current.x + (next.x - current.x) * 2 / 3;\n        const cpY2 = next.y;\n        \n        ctx.bezierCurveTo(cpX1, cpY1, cpX2, cpY2, next.x, next.y);\n      }\n      \n      // Complete the wave shape\n      ctx.lineTo(width, height);\n      ctx.closePath();\n      ctx.fill();\n      \n      // Add foam/highlights to wave crests if detail is high enough\n      if (detail > 0.6 && w < 2) { // Only for top waves\n        ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';\n        ctx.lineWidth = 2;\n        \n        for (let i = 0; i < wave.points.length - 1; i++) {\n          const point = wave.points[i];\n          const nextPoint = wave.points[i + 1];\n          \n          // Only add foam to wave peaks\n          if (i > 0) {\n            const prevPoint = wave.points[i - 1];\n            \n            // Check if this is a peak (higher than neighbors)\n            if (point.y < prevPoint.y && point.y < nextPoint.y) {\n              // Foam intensity based on how sharp the peak is and audio energy\n              const peakSharpness = Math.min(\n                Math.abs(point.y - prevPoint.y),\n                Math.abs(point.y - nextPoint.y)\n              );\n              \n              if (peakSharpness > wave.amplitude * 0.3 * energy) {\n                // Draw foam as small arcs\n                ctx.beginPath();\n                ctx.arc(point.x, point.y, peakSharpness * 0.5, 0, Math.PI);\n                ctx.stroke();\n              }\n            }\n          }\n        }\n      }\n    }\n    \n    // Add reflections on the water\n    if (detail > 0.3) {\n      // Sun/moon reflection\n      const reflectionGradient = ctx.createLinearGradient(\n        celestialX, height * 0.5,\n        celestialX, height * 0.7\n      );\n      reflectionGradient.addColorStop(0, `rgba(255, 255, 220, ${0.3 + bassEnergy * 0.2})`);\n      reflectionGradient.addColorStop(1, 'rgba(255, 255, 220, 0)');\n      \n      ctx.fillStyle = reflectionGradient;\n      ctx.beginPath();\n      ctx.moveTo(celestialX - celestialSize, height * 0.5);\n      ctx.lineTo(celestialX + celestialSize, height * 0.5);\n      ctx.lineTo(celestialX + celestialSize * 2, height * 0.7);\n      ctx.lineTo(celestialX - celestialSize * 2, height * 0.7);\n      ctx.closePath();\n      ctx.fill();\n    }\n  };\n\n  const drawDNA = (ctx, dataArray, timeArray, bufferLength, cachedParameters) => {\n    // Safety check - ensure canvas reference exists\n    if (!canvasRef.current) {\n      console.error(\"Canvas reference is null in drawDNA\");\n      return;\n    }\n    \n    // Apply parameters\n    const color = cachedParameters.color || '#00ff99'; // Teal default\n    const reactivity = (cachedParameters.reactivity || 50) / 50; // 0-1 reactivity\n    const detail = (cachedParameters.detail || 50) / 50; // 0-1 detail\n    const speed = (cachedParameters.speed || 50) / 50; // 0-1 speed\n    \n    const width = canvasRef.current.width;\n    const height = canvasRef.current.height;\n    const centerX = width / 2;\n    \n    // Create a dark background with subtle gradient\n    const bgGradient = ctx.createLinearGradient(0, 0, 0, height);\n    bgGradient.addColorStop(0, 'rgb(0, 10, 20)');\n    bgGradient.addColorStop(1, 'rgb(0, 5, 10)');\n    ctx.fillStyle = bgGradient;\n    ctx.fillRect(0, 0, width, height);\n    \n    // Calculate frequency bands for DNA modulation\n    const bandCount = Math.floor(10 + detail * 20); // 10-30 bands\n    const energyBands = [];\n    \n    for (let i = 0; i < bandCount; i++) {\n      const startBin = Math.floor((i / bandCount) * (bufferLength / 2));\n      const endBin = Math.floor(((i + 1) / bandCount) * (bufferLength / 2));\n      energyBands.push(getAverageEnergy(dataArray, startBin, endBin) * reactivity);\n    }\n    \n    // DNA helix parameters\n    const dnaLength = height * 1.5; // Length of the DNA strand\n    const dnaWidth = width * 0.15; // Width of the DNA helix\n    const dnaSegments = Math.floor(20 + detail * 60); // Number of segments in the DNA\n    const dnaRotation = timeRef.current * speed; // Rotation of the DNA over time\n    \n    // Calculate overall energy for DNA animation\n    const overallEnergy = energyBands.reduce((sum, energy) => sum + energy, 0) / bandCount;\n    \n    // Vertical offset to center the DNA\n    const verticalOffset = (height - dnaLength) / 2;\n    \n    // Draw the DNA strands\n    for (let strand = 0; strand < 2; strand++) {\n      // Each strand has a different color\n      const strandColor = strand === 0 ? color : adjustColor(color, 40);\n      \n      // Draw the strand backbone\n      ctx.strokeStyle = adjustColor(strandColor, -20);\n      ctx.lineWidth = 4;\n      ctx.beginPath();\n      \n      for (let i = 0; i <= dnaSegments; i++) {\n        const progress = i / dnaSegments;\n        const y = verticalOffset + progress * dnaLength;\n        \n        // Sine wave for the strand, offset by PI for the second strand\n        const phase = strand * Math.PI;\n        const waveAmplitude = dnaWidth * (0.8 + overallEnergy * 0.4);\n        const x = centerX + Math.sin(progress * Math.PI * 10 + dnaRotation + phase) * waveAmplitude;\n        \n        if (i === 0) {\n          ctx.moveTo(x, y);\n        } else {\n          ctx.lineTo(x, y);\n        }\n      }\n      \n      ctx.stroke();\n    }\n    \n    // Draw the base pairs (connections between strands)\n    for (let i = 0; i < dnaSegments; i++) {\n      const progress = i / dnaSegments;\n      const y = verticalOffset + progress * dnaLength;\n      \n      // Get the energy for this segment\n      const energy = energyBands[i % bandCount];\n      \n      // Calculate positions of the two strand points at this segment\n      const phase1 = 0;\n      const phase2 = Math.PI;\n      const waveAmplitude = dnaWidth * (0.8 + overallEnergy * 0.4);\n      \n      const x1 = centerX + Math.sin(progress * Math.PI * 10 + dnaRotation + phase1) * waveAmplitude;\n      const x2 = centerX + Math.sin(progress * Math.PI * 10 + dnaRotation + phase2) * waveAmplitude;\n      \n      // Only draw base pairs at certain intervals\n      if (i % 2 === 0) {\n        // Base pair color based on frequency band\n        const hue = (i / dnaSegments) * 180 + 180; // Cyan to blue range\n        const basePairColor = `hsla(${hue}, 100%, 70%, ${0.5 + energy * 0.5})`;\n        \n        // Draw base pair connection\n        ctx.strokeStyle = basePairColor;\n        ctx.lineWidth = 2 + energy * 4;\n        \n        ctx.beginPath();\n        ctx.moveTo(x1, y);\n        ctx.lineTo(x2, y);\n        ctx.stroke();\n        \n        // Draw nucleotide bases at the ends of the connection\n        const baseSize = 3 + energy * 5;\n        \n        // Base 1\n        ctx.fillStyle = adjustColor(color, 20);\n        ctx.beginPath();\n        ctx.arc(x1, y, baseSize, 0, Math.PI * 2);\n        ctx.fill();\n        \n        // Base 2\n        ctx.fillStyle = adjustColor(color, 60);\n        ctx.beginPath();\n        ctx.arc(x2, y, baseSize, 0, Math.PI * 2);\n        ctx.fill();\n      }\n    }\n    \n    // Add glow effect to the DNA\n    if (detail > 0.5) {\n      ctx.globalCompositeOperation = 'lighter';\n      \n      // Draw glow along the DNA strands\n      for (let i = 0; i < dnaSegments; i += 4) {\n        const progress = i / dnaSegments;\n        const y = verticalOffset + progress * dnaLength;\n        \n        // Get the energy for this segment\n        const energy = energyBands[i % bandCount];\n        \n        // Only add glow if there's enough energy\n        if (energy > 0.5) {\n          // Calculate position on the DNA\n          const phase = (i % 2) * Math.PI; // Alternate between strands\n          const waveAmplitude = dnaWidth * (0.8 + overallEnergy * 0.4);\n          const x = centerX + Math.sin(progress * Math.PI * 10 + dnaRotation + phase) * waveAmplitude;\n          \n          // Glow size based on energy\n          const glowSize = 20 + energy * 30;\n          \n          // Glow color\n          const hue = (i / dnaSegments) * 180 + 180;\n          const glowColor = `hsla(${hue}, 100%, 70%, ${energy * 0.3})`;\n          \n          // Draw glow\n          const glow = ctx.createRadialGradient(x, y, 0, x, y, glowSize);\n          glow.addColorStop(0, glowColor);\n          glow.addColorStop(1, 'rgba(0, 0, 0, 0)');\n          \n          ctx.fillStyle = glow;\n          ctx.beginPath();\n          ctx.arc(x, y, glowSize, 0, Math.PI * 2);\n          ctx.fill();\n        }\n      }\n      \n      ctx.globalCompositeOperation = 'source-over';\n    }\n    \n    // Add floating particles around the DNA if detail is high\n    if (detail > 0.7) {\n      const particleCount = Math.floor(20 + detail * 60);\n      \n      for (let i = 0; i < particleCount; i++) {\n        // Particle position - keep near the DNA\n        const angle = Math.random() * Math.PI * 2;\n        const distance = dnaWidth * 2 + Math.random() * width * 0.2;\n        const x = centerX + Math.cos(angle) * distance;\n        const y = Math.random() * height;\n        \n        // Particle size based on audio\n        const particleEnergy = energyBands[i % bandCount];\n        const size = 1 + particleEnergy * 3;\n        \n        // Particle color\n        const hue = (i / particleCount) * 180 + 180;\n        const particleColor = `hsla(${hue}, 100%, 70%, ${0.3 + particleEnergy * 0.7})`;\n        \n        // Draw particle\n        ctx.fillStyle = particleColor;\n        ctx.beginPath();\n        ctx.arc(x, y, size, 0, Math.PI * 2);\n        ctx.fill();\n      }\n    }\n  };\n\n  const drawForest = (ctx, dataArray, timeArray, bufferLength, cachedParameters) => {\n    // Safety check - ensure canvas reference exists\n    if (!canvasRef.current) {\n      console.error(\"Canvas reference is null in drawForest\");\n      return;\n    }\n    \n    // Apply parameters\n    const color = cachedParameters.color || '#33cc33'; // Green default\n    const reactivity = (cachedParameters.reactivity || 50) / 50; // 0-1 reactivity\n    const density = (cachedParameters.density || 50) / 50; // 0-1 density\n    const detail = (cachedParameters.detail || 50) / 50; // 0-1 detail\n    \n    const width = canvasRef.current.width;\n    const height = canvasRef.current.height;\n    \n    // Create a forest background gradient (sky to ground)\n    const bgGradient = ctx.createLinearGradient(0, 0, 0, height);\n    \n    // Get bass and mid frequencies for sky color\n    const bassEnergy = getAverageEnergy(dataArray, 0, Math.floor(bufferLength * 0.1)) * reactivity;\n    const midEnergy = getAverageEnergy(dataArray, Math.floor(bufferLength * 0.1), Math.floor(bufferLength * 0.5)) * reactivity;\n    \n    // Sky colors change with audio\n    const skyTopColor = `rgb(${50 + bassEnergy * 30}, ${100 + midEnergy * 50}, ${150 + bassEnergy * 50})`;\n    const skyBottomColor = `rgb(${100 + midEnergy * 20}, ${120 + bassEnergy * 20}, ${150 + midEnergy * 20})`;\n    const groundColor = `rgb(${30 + bassEnergy * 10}, ${60 + midEnergy * 10}, ${30 + bassEnergy * 5})`;\n    \n    bgGradient.addColorStop(0, skyTopColor);\n    bgGradient.addColorStop(0.6, skyBottomColor);\n    bgGradient.addColorStop(0.6, groundColor);\n    // Create a darker version of the ground color directly\n    const darkerGroundColor = `rgb(${Math.max(0, 30 + bassEnergy * 10 - 20)}, ${Math.max(0, 60 + midEnergy * 10 - 20)}, ${Math.max(0, 30 + bassEnergy * 5 - 20)})`;\n    bgGradient.addColorStop(1, darkerGroundColor);\n    \n    ctx.fillStyle = bgGradient;\n    ctx.fillRect(0, 0, width, height);\n    \n    // Draw sun/moon in the sky\n    const celestialSize = width * 0.05;\n    const celestialX = width * 0.8;\n    const celestialY = height * 0.2;\n    \n    // Sun/moon color based on audio\n    const celestialColor = `rgba(${255 - bassEnergy * 50}, ${255 - bassEnergy * 20}, ${220 - bassEnergy * 20}, 0.8)`;\n    \n    // Draw glow\n    const glowGradient = ctx.createRadialGradient(celestialX, celestialY, 0, celestialX, celestialY, celestialSize * 2);\n    glowGradient.addColorStop(0, celestialColor);\n    glowGradient.addColorStop(1, 'rgba(255, 255, 220, 0)');\n    \n    ctx.fillStyle = glowGradient;\n    ctx.beginPath();\n    ctx.arc(celestialX, celestialY, celestialSize * 2, 0, Math.PI * 2);\n    ctx.fill();\n    \n    ctx.fillStyle = celestialColor;\n    ctx.beginPath();\n    ctx.arc(celestialX, celestialY, celestialSize, 0, Math.PI * 2);\n    ctx.fill();\n    \n    // Calculate frequency bands for trees\n    const bandCount = Math.floor(10 + density * 40); // 10-50 frequency bands\n    const energyBands = [];\n    \n    for (let i = 0; i < bandCount; i++) {\n      const startBin = Math.floor((i / bandCount) * (bufferLength / 2));\n      const endBin = Math.floor(((i + 1) / bandCount) * (bufferLength / 2));\n      energyBands.push(getAverageEnergy(dataArray, startBin, endBin) * reactivity);\n    }\n    \n    // Draw distant mountains if detail is high enough\n    if (detail > 0.3) {\n      const mountainCount = Math.floor(3 + detail * 7); // 3-10 mountains\n      \n      for (let i = 0; i < mountainCount; i++) {\n        // Mountain properties\n        const mountainWidth = width / (mountainCount - 1);\n        const mountainX = i * mountainWidth - mountainWidth / 2;\n        const mountainHeight = height * 0.2 * (0.5 + Math.sin(i * 2) * 0.5);\n        \n        // Mountain color based on distance (further = lighter)\n        const distanceFactor = i / mountainCount;\n        const mountainColor = `rgba(${70 + distanceFactor * 30}, ${90 + distanceFactor * 30}, ${110 + distanceFactor * 30}, ${0.8 - distanceFactor * 0.4})`;\n        \n        // Draw mountain\n        ctx.fillStyle = mountainColor;\n        ctx.beginPath();\n        ctx.moveTo(mountainX, height * 0.6);\n        ctx.lineTo(mountainX + mountainWidth / 2, height * 0.6 - mountainHeight);\n        ctx.lineTo(mountainX + mountainWidth, height * 0.6);\n        ctx.closePath();\n        ctx.fill();\n        \n        // Add snow caps if high enough\n        if (mountainHeight > height * 0.1) {\n          const snowCapHeight = mountainHeight * 0.2;\n          const snowCapWidth = mountainWidth * 0.3;\n          \n          ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';\n          ctx.beginPath();\n          ctx.moveTo(mountainX + mountainWidth / 2 - snowCapWidth / 2, height * 0.6 - mountainHeight + snowCapHeight);\n          ctx.lineTo(mountainX + mountainWidth / 2, height * 0.6 - mountainHeight);\n          ctx.lineTo(mountainX + mountainWidth / 2 + snowCapWidth / 2, height * 0.6 - mountainHeight + snowCapHeight);\n          ctx.closePath();\n          ctx.fill();\n        }\n      }\n    }\n    \n    // Draw trees\n    const treeCount = Math.floor(10 + density * 40); // 10-50 trees\n    const horizonY = height * 0.6; // Horizon line\n    \n    // Sort trees by depth (draw back to front)\n    const trees = [];\n    \n    for (let i = 0; i < treeCount; i++) {\n      // Tree position\n      const x = Math.random() * width;\n      const depth = Math.random(); // 0 = far, 1 = close\n      const y = horizonY - depth * height * 0.1; // Trees further away are higher on screen\n      \n      // Tree properties based on frequency band\n      const bandIndex = Math.floor(i / treeCount * bandCount);\n      const energy = energyBands[bandIndex];\n      \n      // Tree size based on depth and audio\n      const baseHeight = height * 0.2 * depth;\n      const treeHeight = baseHeight * (0.7 + energy * 0.6);\n      const trunkWidth = treeHeight * 0.05 * (0.8 + energy * 0.4);\n      \n      trees.push({\n        x,\n        y,\n        depth,\n        height: treeHeight,\n        width: trunkWidth,\n        energy,\n        bandIndex\n      });\n    }\n    \n    // Sort trees by depth (back to front)\n    trees.sort((a, b) => a.depth - b.depth);\n    \n    // Draw each tree\n    trees.forEach(tree => {\n      // Tree colors based on depth and energy\n      const depthFactor = tree.depth;\n      const energy = tree.energy;\n      \n      // Trunk color\n      const trunkColor = adjustColor('#8B4513', -20 + depthFactor * 40); // Brown with depth variation\n      \n      // Foliage color based on tree's frequency band and energy\n      const hue = 80 + (tree.bandIndex / bandCount) * 40; // Green to yellow-green range\n      const saturation = 70 + energy * 30;\n      const lightness = 20 + depthFactor * 20 + energy * 20;\n      const foliageColor = `hsl(${hue}, ${saturation}%, ${lightness}%)`;\n      \n      // Draw trunk\n      ctx.fillStyle = trunkColor;\n      ctx.beginPath();\n      ctx.rect(\n        tree.x - tree.width / 2,\n        tree.y - tree.height,\n        tree.width,\n        tree.height * 0.4\n      );\n      ctx.fill();\n      \n      // Draw foliage based on detail level\n      if (detail < 0.5) {\n        // Simple triangle foliage\n        const foliageWidth = tree.height * 0.4 * (0.8 + energy * 0.4);\n        const foliageHeight = tree.height * 0.8 * (0.8 + energy * 0.4);\n        \n        ctx.fillStyle = foliageColor;\n        ctx.beginPath();\n        ctx.moveTo(tree.x - foliageWidth / 2, tree.y - tree.height * 0.3);\n        ctx.lineTo(tree.x, tree.y - tree.height - foliageHeight * 0.2);\n        ctx.lineTo(tree.x + foliageWidth / 2, tree.y - tree.height * 0.3);\n        ctx.closePath();\n        ctx.fill();\n      } else {\n        // Detailed multi-layer foliage\n        const layerCount = Math.floor(2 + detail * 3); // 2-5 layers\n        \n        for (let i = 0; i < layerCount; i++) {\n          const layerWidth = tree.height * (0.5 - i * 0.07) * (0.8 + energy * 0.4);\n          const layerY = tree.y - tree.height * (0.3 + i * 0.2);\n          \n          // Layer color gets lighter toward the top\n          const layerLightness = lightness + i * 5;\n          const layerColor = `hsl(${hue}, ${saturation}%, ${layerLightness}%)`;\n          \n          ctx.fillStyle = layerColor;\n          ctx.beginPath();\n          ctx.moveTo(tree.x - layerWidth / 2, layerY);\n          ctx.lineTo(tree.x, layerY - layerWidth * 0.8);\n          ctx.lineTo(tree.x + layerWidth / 2, layerY);\n          ctx.closePath();\n          ctx.fill();\n        }\n      }\n      \n      // Add tree sway animation based on audio\n      if (energy > 0.3) {\n        // Draw swaying leaves/particles\n        const particleCount = Math.floor(5 + energy * 15);\n        \n        for (let i = 0; i < particleCount; i++) {\n          // Particle position around the foliage\n          const angle = Math.random() * Math.PI * 2;\n          const distance = tree.height * 0.2 * Math.random();\n          const particleX = tree.x + Math.cos(angle) * distance;\n          const particleY = tree.y - tree.height * 0.6 - Math.sin(angle) * distance;\n          \n          // Particle size based on energy\n          const size = 1 + energy * 2;\n          \n          // Particle color - convert HSL to hex before adjusting\n          // Use a fixed hex color instead of trying to adjust the HSL color\n          const particleColor = energy > 0.5 ? \n            `hsl(${hue}, ${saturation}%, ${Math.min(lightness + 20, 90)}%)` : \n            `hsl(${hue}, ${saturation}%, ${Math.min(lightness + 10, 80)}%)`;\n          \n          ctx.fillStyle = particleColor;\n          ctx.beginPath();\n          ctx.arc(particleX, particleY, size, 0, Math.PI * 2);\n          ctx.fill();\n        }\n      }\n    });\n    \n    // Add lighting effects based on audio\n    if (detail > 0.6) {\n      // Sun rays\n      const rayCount = Math.floor(5 + bassEnergy * 10);\n      \n      ctx.strokeStyle = `rgba(255, 255, 200, ${0.1 + bassEnergy * 0.2})`;\n      ctx.lineWidth = 1;\n      \n      for (let i = 0; i < rayCount; i++) {\n        const angle = (i / rayCount) * Math.PI + Math.PI / 4;\n        const rayLength = width * (0.5 + bassEnergy * 0.5);\n        \n        ctx.beginPath();\n        ctx.moveTo(celestialX, celestialY);\n        ctx.lineTo(\n          celestialX + Math.cos(angle) * rayLength,\n          celestialY + Math.sin(angle) * rayLength\n        );\n        ctx.stroke();\n      }\n      \n      // Ground fog\n      const fogOpacity = 0.1 + midEnergy * 0.2;\n      const fogGradient = ctx.createLinearGradient(0, horizonY, 0, height);\n      fogGradient.addColorStop(0, `rgba(255, 255, 255, ${fogOpacity})`);\n      fogGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');\n      \n      ctx.fillStyle = fogGradient;\n      ctx.fillRect(0, horizonY, width, height - horizonY);\n    }\n  };\n\n  function getAverageEnergy(data, startBin, endBin) {\n    let sum = 0;\n    const binCount = Math.min(endBin - startBin, data.length - startBin);\n    \n    if (binCount <= 0) return 0;\n    \n    for (let i = startBin; i < startBin + binCount; i++) {\n      sum += data[i] / 255.0;\n    }\n    \n    return sum / binCount;\n  }\n\n  // Update parameters when initialParameters change - use a ref to avoid re-renders\n  useEffect(() => {\n    // Only log in development\n    if (process.env.NODE_ENV !== 'production') {\n      console.log(\"Visualizer received updated parameters:\", initialParameters);\n    }\n    \n    if (initialParameters && Object.keys(initialParameters).length > 0) {\n      // Use a simple update without triggering re-renders\n      setParameters(initialParameters);\n    }\n  }, [initialParameters]);\n\n  // Add a function to update parameters\n  const updateParameters = (newParameters) => {\n    // Only log in development\n    if (process.env.NODE_ENV !== 'production') {\n      console.log(\"Updating visualization parameters:\", newParameters);\n    }\n    \n    setParameters(newParameters);\n  };\n\n  const drawSnake = (ctx, dataArray, timeArray, bufferLength, cachedParameters) => {\n    // Safety check - ensure canvas reference exists\n    if (!canvasRef.current) {\n      console.error(\"Canvas reference is null in drawSnake\");\n      return;\n    }\n    \n    // Apply parameters\n    const color = cachedParameters.color || '#ff0000'; // Base color (will be overridden by rainbow)\n    const reactivity = (cachedParameters.reactivity || 50) / 50; // 0-1 reactivity\n    const speed = (cachedParameters.speed || 50) / 50; // 0-1 speed\n    const size = (cachedParameters.size || 50) / 50; // 0-1 size\n    \n    const width = canvasRef.current.width;\n    const height = canvasRef.current.height;\n    \n    // Create a cosmic background with slower movement\n    // Use timeRef for slow background movement\n    const bgTime = timeRef.current * 0.05; // Significantly slowed down background movement\n    const bgOffsetX = Math.sin(bgTime * 0.2) * width * 0.05;\n    const bgOffsetY = Math.cos(bgTime * 0.3) * height * 0.05;\n    \n    const bgGradient = ctx.createRadialGradient(\n      width/2 + bgOffsetX, height/2 + bgOffsetY, 0, \n      width/2 + bgOffsetX, height/2 + bgOffsetY, Math.max(width, height)\n    );\n    bgGradient.addColorStop(0, 'rgba(20, 0, 40, 1)');\n    bgGradient.addColorStop(0.5, 'rgba(10, 0, 20, 1)');\n    bgGradient.addColorStop(1, 'rgba(0, 0, 10, 1)');\n    ctx.fillStyle = bgGradient;\n    ctx.fillRect(0, 0, width, height);\n    \n    // Draw cosmic stars with slow twinkling\n    if (!window.snakeStars) {\n      // Initialize fixed star positions\n      window.snakeStars = [];\n      const starCount = 150;\n      for (let i = 0; i < starCount; i++) {\n        window.snakeStars.push({\n          x: Math.random() * width,\n          y: Math.random() * height,\n          size: Math.random() * 2 + 0.5,\n          brightness: 0.5 + Math.random() * 0.5,\n          twinkleSpeed: Math.random() * 2 + 1,\n          twinkleOffset: Math.random() * Math.PI * 2\n        });\n      }\n    }\n    \n    // Draw stars with slow twinkling\n    window.snakeStars.forEach(star => {\n      // Slow twinkling effect\n      const twinkle = 0.5 + Math.sin(timeRef.current * 0.5 * star.twinkleSpeed + star.twinkleOffset) * 0.3;\n      ctx.fillStyle = `rgba(255, 255, 255, ${star.brightness * twinkle})`;\n      ctx.beginPath();\n      ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);\n      ctx.fill();\n    });\n    \n    // Calculate audio energy for different frequency bands\n    const bassEnergy = getAverageEnergy(dataArray, 0, Math.floor(bufferLength * 0.1)) * reactivity;\n    const midEnergy = getAverageEnergy(dataArray, Math.floor(bufferLength * 0.1), Math.floor(bufferLength * 0.5)) * reactivity;\n    const highEnergy = getAverageEnergy(dataArray, Math.floor(bufferLength * 0.5), bufferLength) * reactivity;\n    \n    // Calculate overall energy\n    const overallEnergy = (bassEnergy + midEnergy + highEnergy) / 3;\n    \n    // Detect beats for movement changes\n    const beatDetected = bassEnergy > 0.7 || midEnergy > 0.8;\n    \n    // Initialize snake if it doesn't exist\n    if (!window.snake) {\n      // Grid size based on canvas dimensions\n      const gridSize = Math.floor(20 + size * 20); // 20-40 grid cells\n      const cellSize = Math.min(width, height) / gridSize;\n      \n      // Initial snake position (center of screen)\n      const initialX = Math.floor(gridSize / 2);\n      const initialY = Math.floor(gridSize / 2);\n      \n      // Create initial snake with just 3 segments (smaller start)\n      const segments = [];\n      for (let i = 0; i < 3; i++) {\n        segments.push({ \n          x: initialX - i * 0.5, \n          y: initialY,\n          // Add extra properties for cosmic effect\n          glow: Math.random(),\n          pulseOffset: Math.random() * Math.PI * 2,\n          // Add properties for smooth movement\n          targetX: initialX - i * 0.5,\n          targetY: initialY,\n          prevX: initialX - i * 0.5,\n          prevY: initialY\n        });\n      }\n      \n      // Create targets for the snake to move toward\n      const targets = [];\n      for (let i = 0; i < 5; i++) {\n        targets.push({\n          x: Math.random() * gridSize,\n          y: Math.random() * gridSize,\n          energy: 1.0\n        });\n      }\n      \n      window.snake = {\n        segments,\n        direction: { x: 1, y: 0 }, // Initial direction: right\n        nextDirection: { x: 1, y: 0 }, // For queuing direction changes\n        gridSize,\n        cellSize,\n        moveCounter: 0,\n        moveThreshold: 15, // Moderate movement speed\n        colorOffset: 0,\n        food: {\n          x: Math.floor(Math.random() * gridSize),\n          y: Math.floor(Math.random() * gridSize),\n          energy: 1.0\n        },\n        lastMoveTime: 0,\n        directionChangeQueued: false,\n        targets: targets,\n        currentTargetIndex: 0,\n        pathfindingCounter: 0,\n        glowIntensity: 0.5,\n        tailEffect: 0,\n        // Track growth for gradual size increase\n        initialSize: 3, // Initial number of segments\n        maxSegments: 15, // Maximum number of segments\n        growthProgress: 0, // Growth progress counter\n        foodEaten: 0, // Track food eaten for growth\n        // Movement interpolation\n        movementProgress: 0, // Progress between positions (0-1)\n        movementSpeed: 0.1, // Speed of interpolation (0.1 = 10% per frame)\n        lastMoveDirection: { x: 1, y: 0 } // Last movement direction\n      };\n    }\n    \n    const snake = window.snake;\n    \n    // Safety check - ensure snake object is properly initialized\n    if (!snake || !snake.segments || !snake.targets) {\n      console.error(\"Snake object is not properly initialized\");\n      // Reinitialize by clearing the window.snake object\n      window.snake = null;\n      return;\n    }\n    \n    // Update cosmic background effects based on audio\n    snake.glowIntensity = 0.5 + overallEnergy * 0.5;\n    snake.tailEffect = Math.max(snake.tailEffect, bassEnergy);\n    snake.tailEffect *= 0.95; // Decay effect\n    \n    // Update targets based on audio energy - slower movement\n    if (beatDetected && Math.random() < 0.2) { // Reduced probability from 0.3 to 0.2\n      // Create a new target when a beat is detected\n      const targetIndex = Math.floor(Math.random() * snake.targets.length);\n      snake.targets[targetIndex] = {\n        x: Math.random() * snake.gridSize,\n        y: Math.random() * snake.gridSize,\n        energy: 1.0\n      };\n    }\n    \n    // Update target energies - slower fading\n    snake.targets.forEach(target => {\n      target.energy *= 0.995; // Slower fade (was 0.99)\n      if (target.energy < 0.2) {\n        // Regenerate faded targets\n        target.x = Math.random() * snake.gridSize;\n        target.y = Math.random() * snake.gridSize;\n        target.energy = 1.0;\n      }\n    });\n    \n    // Find the most energetic target\n    let bestTargetIndex = 0;\n    let bestEnergy = 0;\n    snake.targets.forEach((target, index) => {\n      if (target.energy > bestEnergy) {\n        bestEnergy = target.energy;\n        bestTargetIndex = index;\n      }\n    });\n    snake.currentTargetIndex = bestTargetIndex;\n    \n    // Update pathfinding toward current target - slower updates\n    snake.pathfindingCounter++;\n    if (snake.pathfindingCounter >= 15) { // Increased from 10 to 15 for slower direction changes\n      snake.pathfindingCounter = 0;\n      \n      const head = snake.segments[0];\n      const target = snake.targets[snake.currentTargetIndex];\n      \n      // Safety check - ensure target exists\n      if (!target) {\n        console.error(\"Target is undefined\");\n        return;\n      }\n      \n      // Calculate direction to target\n      const dx = target.x - head.x;\n      const dy = target.y - head.y;\n      \n      // Determine best direction to move\n      let newDirection = { x: 0, y: 0 };\n      \n      // Prioritize the larger distance\n      if (Math.abs(dx) > Math.abs(dy)) {\n        newDirection.x = dx > 0 ? 1 : -1;\n        newDirection.y = 0;\n      } else {\n        newDirection.x = 0;\n        newDirection.y = dy > 0 ? 1 : -1;\n      }\n      \n      // Occasionally make random moves for more interesting patterns - reduced frequency\n      if (Math.random() < 0.1 * overallEnergy) { // Reduced from 0.2 to 0.1\n        if (Math.random() < 0.5) {\n          newDirection = { x: Math.random() < 0.5 ? -1 : 1, y: 0 };\n        } else {\n          newDirection = { x: 0, y: Math.random() < 0.5 ? -1 : 1 };\n        }\n      }\n      \n      // Don't allow reversing direction\n      if (!(newDirection.x === -snake.direction.x && newDirection.y === -snake.direction.y)) {\n        snake.nextDirection = newDirection;\n        snake.directionChangeQueued = true;\n      }\n    }\n    \n    // Update snake movement counter - sync with music but slower\n    const baseSpeed = 0.5; // Reduced from 0.7 to 0.5\n    const maxSpeedBoost = 0.8; // Reduced from 1.0 to 0.8\n    snake.moveCounter += baseSpeed + (speed * maxSpeedBoost * overallEnergy);\n    \n    // Smooth movement interpolation\n    snake.movementProgress += snake.movementSpeed;\n    \n    // Move snake when counter exceeds threshold\n    if (snake.moveCounter >= snake.moveThreshold) {\n      snake.moveCounter = 0;\n      \n      // Apply queued direction change\n      if (snake.directionChangeQueued) {\n        snake.direction = snake.nextDirection;\n        snake.directionChangeQueued = false;\n      }\n      \n      // Store last move direction\n      snake.lastMoveDirection = { ...snake.direction };\n      \n      // Save previous positions for interpolation\n      snake.segments.forEach(segment => {\n        segment.prevX = segment.x;\n        segment.prevY = segment.y;\n      });\n      \n      // Calculate new head position - smoother, slower movement\n      const head = snake.segments[0];\n      const moveAmount = 0.4 + overallEnergy * 0.4; // Reduced from 0.5 to 0.4\n      \n      const newHead = {\n        x: head.prevX + snake.direction.x * moveAmount,\n        y: head.prevY + snake.direction.y * moveAmount,\n        targetX: head.prevX + snake.direction.x * moveAmount,\n        targetY: head.prevY + snake.direction.y * moveAmount,\n        prevX: head.prevX,\n        prevY: head.prevY,\n        glow: Math.random(),\n        pulseOffset: Math.random() * Math.PI * 2\n      };\n      \n      // Wrap around screen edges with a margin to keep snake visible\n      const margin = 2;\n      if (newHead.x < margin) newHead.x = snake.gridSize - margin;\n      if (newHead.x > snake.gridSize - margin) newHead.x = margin;\n      if (newHead.y < margin) newHead.y = snake.gridSize - margin;\n      if (newHead.y > snake.gridSize - margin) newHead.y = margin;\n      \n      // Update target position to match wrapped position\n      newHead.targetX = newHead.x;\n      newHead.targetY = newHead.y;\n      \n      // Check if snake ate food\n      const distance = Math.sqrt(\n        Math.pow(newHead.x - snake.food.x, 2) + \n        Math.pow(newHead.y - snake.food.y, 2)\n      );\n      const ateFood = distance < 1.5;\n      \n      // Add new head to snake\n      snake.segments.unshift(newHead);\n      \n      // If didn't eat food, remove tail\n      if (!ateFood) {\n        // Only remove tail if we're at or above the current growth target\n        const targetLength = Math.max(\n          snake.initialSize,\n          Math.ceil(snake.initialSize + (snake.maxSegments - snake.initialSize) * (snake.growthProgress / 100))\n        );\n        \n        if (snake.segments.length > targetLength) {\n          snake.segments.pop();\n        }\n      } else {\n        // Generate new food\n        let newFoodX, newFoodY;\n        let validPosition = false;\n        \n        while (!validPosition) {\n          newFoodX = Math.random() * snake.gridSize;\n          newFoodY = Math.random() * snake.gridSize;\n          \n          // Check if position is not too close to snake\n          validPosition = !snake.segments.some(segment => \n            Math.sqrt(Math.pow(segment.x - newFoodX, 2) + Math.pow(segment.y - newFoodY, 2)) < 2\n          );\n        }\n        \n        snake.food = { \n          x: newFoodX, \n          y: newFoodY,\n          energy: 1.0\n        };\n        \n        // Add cosmic energy burst effect\n        snake.glowIntensity = 1.0;\n        snake.tailEffect = 1.0;\n        \n        // Increment food eaten counter\n        snake.foodEaten++;\n        \n        // Increase growth progress - more significant growth\n        snake.growthProgress += 15; // Each food adds 15% toward full growth (was 10%)\n        snake.growthProgress = Math.min(snake.growthProgress, 100); // Cap at 100%\n        \n        // Increase max segments as snake grows\n        if (snake.foodEaten % 2 === 0 && snake.maxSegments < 30) {\n          snake.maxSegments += 5; // Grow by 5 segments every 2 food items (was every 3)\n        }\n      }\n      \n      // Reset movement progress for smooth interpolation\n      snake.movementProgress = 0;\n    }\n    \n    // Update color rotation based on audio energy - slower rotation\n    snake.colorOffset += 0.003 + overallEnergy * 0.02; // Reduced from 0.005 + 0.03\n    if (snake.colorOffset > 1) snake.colorOffset -= 1;\n    \n    // Draw cosmic food\n    const foodPulse = 0.8 + Math.sin(timeRef.current * 2) * 0.2; // Slower pulsing (was 3)\n    const foodSize = snake.cellSize * (1.0 + bassEnergy * 0.5) * foodPulse;\n    const foodX = snake.food.x * snake.cellSize;\n    const foodY = snake.food.y * snake.cellSize;\n    \n    // Food glow effect\n    const foodGlow = ctx.createRadialGradient(foodX, foodY, 0, foodX, foodY, foodSize * 2);\n    const foodHue = (timeRef.current * 20) % 360; // Slower color change (was 30)\n    foodGlow.addColorStop(0, `hsla(${foodHue}, 100%, 70%, 0.8)`);\n    foodGlow.addColorStop(0.5, `hsla(${foodHue}, 100%, 50%, 0.4)`);\n    foodGlow.addColorStop(1, `hsla(${foodHue}, 100%, 40%, 0)`);\n    \n    ctx.fillStyle = foodGlow;\n    ctx.beginPath();\n    ctx.arc(foodX, foodY, foodSize * 2, 0, Math.PI * 2);\n    ctx.fill();\n    \n    // Food core\n    ctx.fillStyle = `hsla(${foodHue}, 100%, 70%, 0.9)`;\n    ctx.beginPath();\n    ctx.arc(foodX, foodY, foodSize / 2, 0, Math.PI * 2);\n    ctx.fill();\n    \n    // Draw targets as subtle cosmic portals - slower animation\n    snake.targets.forEach(target => {\n      if (target.energy > 0.2) {\n        const targetX = target.x * snake.cellSize;\n        const targetY = target.y * snake.cellSize;\n        const targetSize = snake.cellSize * target.energy;\n        \n        // Portal effect with slower pulsing\n        const portalPulse = 0.9 + Math.sin(timeRef.current * 1.5) * 0.1; // Slower pulse\n        const portalGradient = ctx.createRadialGradient(\n          targetX, targetY, 0, \n          targetX, targetY, targetSize * 3 * portalPulse\n        );\n        portalGradient.addColorStop(0, `rgba(100, 100, 255, ${target.energy * 0.1})`);\n        portalGradient.addColorStop(0.5, `rgba(50, 50, 150, ${target.energy * 0.05})`);\n        portalGradient.addColorStop(1, 'rgba(0, 0, 0, 0)');\n        \n        ctx.fillStyle = portalGradient;\n        ctx.beginPath();\n        ctx.arc(targetX, targetY, targetSize * 3 * portalPulse, 0, Math.PI * 2);\n        ctx.fill();\n        \n        // Portal rings with slower rotation\n        ctx.strokeStyle = `rgba(100, 100, 255, ${target.energy * 0.3})`;\n        ctx.lineWidth = 1;\n        \n        // Inner ring\n        ctx.beginPath();\n        ctx.arc(targetX, targetY, targetSize * portalPulse, 0, Math.PI * 2);\n        ctx.stroke();\n        \n        // Outer ring\n        ctx.beginPath();\n        ctx.arc(targetX, targetY, targetSize * 1.5 * portalPulse, 0, Math.PI * 2);\n        ctx.stroke();\n      }\n    });\n    \n    // Draw snake segments with cosmic rainbow effect\n    ctx.globalCompositeOperation = 'lighter'; // Make colors blend additively\n    \n    // Calculate current target size based on growth progress\n    const targetLength = Math.max(\n      snake.initialSize,\n      Math.ceil(snake.initialSize + (snake.maxSegments - snake.initialSize) * (snake.growthProgress / 100))\n    );\n    \n    // Display growth progress for debugging\n    // ctx.fillStyle = 'white';\n    // ctx.font = '12px Arial';\n    // ctx.fillText(`Growth: ${Math.floor(snake.growthProgress)}%, Target: ${targetLength}, Current: ${snake.segments.length}`, 10, 20);\n    \n    snake.segments.forEach((segment, index) => {\n      // Calculate segment progress (0 = head, 1 = tail)\n      const progress = index / Math.max(snake.segments.length, 1);\n      \n      // Calculate hue based on segment index and offset - slower rotation\n      const hue = ((index * 12) + (snake.colorOffset * 360)) % 360; // Reduced from 15 to 12\n      \n      // Interpolate between previous and target positions for smooth movement\n      let interpolatedX, interpolatedY;\n      \n      if (segment.prevX !== undefined && segment.prevY !== undefined) {\n        // Use movement progress for interpolation\n        interpolatedX = segment.prevX + (segment.x - segment.prevX) * Math.min(1, snake.movementProgress);\n        interpolatedY = segment.prevY + (segment.y - segment.prevY) * Math.min(1, snake.movementProgress);\n      } else {\n        // Fallback if no previous position\n        interpolatedX = segment.x;\n        interpolatedY = segment.y;\n      }\n      \n      // Calculate segment size (head is larger, tail is smaller)\n      const segmentFactor = 1 - progress * 0.5; // Less taper for a more uniform serpent\n      \n      // Scale segment size based on growth progress - more dramatic growth\n      const growthScale = 0.6 + (snake.growthProgress / 100) * 0.8; // 0.6 to 1.4 scale as snake grows (was 0.7 to 1.2)\n      let segmentSize = snake.cellSize * segmentFactor * growthScale;\n      \n      // Apply audio reactivity to segment size\n      if (index < snake.segments.length / 3) {\n        // Head section reacts to bass\n        segmentSize *= 1 + bassEnergy * 0.3;\n      } else if (index < snake.segments.length * 2 / 3) {\n        // Middle section reacts to mids\n        segmentSize *= 1 + midEnergy * 0.3;\n      } else {\n        // Tail section reacts to highs\n        segmentSize *= 1 + highEnergy * 0.3;\n      }\n      \n      // Add tail effect - make tail segments pulse with bass\n      if (index > snake.segments.length * 0.7) {\n        const tailProgress = (index - snake.segments.length * 0.7) / (snake.segments.length * 0.3);\n        segmentSize *= 1 + snake.tailEffect * tailProgress * 0.5;\n      }\n      \n      // Draw segment\n      const x = interpolatedX * snake.cellSize;\n      const y = interpolatedY * snake.cellSize;\n      \n      // Segment glow effect - larger for head, smaller for tail\n      const glowSize = segmentSize * (2.0 - progress * 0.5) * snake.glowIntensity;\n      const glow = ctx.createRadialGradient(x, y, 0, x, y, glowSize);\n      \n      // Glow color based on segment\n      const glowOpacity = 0.7 - progress * 0.5; // Head glows more than tail\n      glow.addColorStop(0, `hsla(${hue}, 100%, 70%, ${glowOpacity})`);\n      glow.addColorStop(0.5, `hsla(${hue}, 100%, 50%, ${glowOpacity * 0.5})`);\n      glow.addColorStop(1, `hsla(${hue}, 100%, 30%, 0)`);\n      \n      // Draw segment glow\n      ctx.fillStyle = glow;\n      ctx.beginPath();\n      ctx.arc(x, y, glowSize, 0, Math.PI * 2);\n      ctx.fill();\n      \n      // Draw segment core - slower pulsing\n      const pulseFactor = Math.sin(timeRef.current * 1.5 + segment.pulseOffset) * 10; // Slower pulse (was 2)\n      const segmentColor = `hsl(${hue}, 100%, ${60 + pulseFactor}%)`;\n      ctx.fillStyle = segmentColor;\n      ctx.beginPath();\n      ctx.arc(x, y, segmentSize / 2, 0, Math.PI * 2);\n      ctx.fill();\n      \n      // Add cosmic details to head\n      if (index === 0) {\n        // Draw eyes\n        const eyeSize = segmentSize * 0.2;\n        const eyeOffset = segmentSize * 0.2;\n        \n        // Eye positions based on direction\n        const eyeX1 = x + snake.lastMoveDirection.y * eyeOffset - snake.lastMoveDirection.x * eyeOffset;\n        const eyeY1 = y + snake.lastMoveDirection.x * eyeOffset + snake.lastMoveDirection.y * eyeOffset;\n        const eyeX2 = x + snake.lastMoveDirection.y * eyeOffset + snake.lastMoveDirection.x * eyeOffset;\n        const eyeY2 = y - snake.lastMoveDirection.x * eyeOffset + snake.lastMoveDirection.y * eyeOffset;\n        \n        // Draw cosmic eyes\n        const eyeGlow = ctx.createRadialGradient(eyeX1, eyeY1, 0, eyeX1, eyeY1, eyeSize * 2);\n        eyeGlow.addColorStop(0, 'rgba(255, 255, 255, 0.9)');\n        eyeGlow.addColorStop(0.5, 'rgba(200, 200, 255, 0.5)');\n        eyeGlow.addColorStop(1, 'rgba(100, 100, 255, 0)');\n        \n        ctx.fillStyle = eyeGlow;\n        ctx.beginPath();\n        ctx.arc(eyeX1, eyeY1, eyeSize * 2, 0, Math.PI * 2);\n        ctx.arc(eyeX2, eyeY2, eyeSize * 2, 0, Math.PI * 2);\n        ctx.fill();\n        \n        // Eye cores\n        ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';\n        ctx.beginPath();\n        ctx.arc(eyeX1, eyeY1, eyeSize, 0, Math.PI * 2);\n        ctx.arc(eyeX2, eyeY2, eyeSize, 0, Math.PI * 2);\n        ctx.fill();\n        \n        // Pupils\n        const pupilColor = `hsl(${(hue + 180) % 360}, 100%, 50%)`;\n        ctx.fillStyle = pupilColor;\n        ctx.beginPath();\n        ctx.arc(eyeX1 + snake.lastMoveDirection.x * eyeSize * 0.3, eyeY1 + snake.lastMoveDirection.y * eyeSize * 0.3, eyeSize * 0.5, 0, Math.PI * 2);\n        ctx.arc(eyeX2 + snake.lastMoveDirection.x * eyeSize * 0.3, eyeY2 + snake.lastMoveDirection.y * eyeSize * 0.3, eyeSize * 0.5, 0, Math.PI * 2);\n        ctx.fill();\n      }\n    });\n    \n    // Reset composite operation\n    ctx.globalCompositeOperation = 'source-over';\n    \n    // Add cosmic particle effects - fewer particles, slower movement\n    const particleCount = Math.floor(30 * overallEnergy); // Reduced from 50 to 30\n    for (let i = 0; i < particleCount; i++) {\n      // Particles follow the snake\n      const segmentIndex = Math.floor(Math.random() * snake.segments.length);\n      const segment = snake.segments[segmentIndex];\n      \n      // Smaller particle spread\n      const x = segment.x * snake.cellSize + (Math.random() - 0.5) * snake.cellSize * 3; // Reduced from 4 to 3\n      const y = segment.y * snake.cellSize + (Math.random() - 0.5) * snake.cellSize * 3; // Reduced from 4 to 3\n      const size = Math.random() * 1.5 + 0.5; // Smaller particles\n      \n      // Particle color based on segment\n      const hue = ((segmentIndex * 12) + (snake.colorOffset * 360)) % 360;\n      ctx.fillStyle = `hsla(${hue}, 100%, 70%, ${Math.random() * 0.4})`; // Lower opacity\n      \n      ctx.beginPath();\n      ctx.arc(x, y, size, 0, Math.PI * 2);\n      ctx.fill();\n    }\n  };\n\n  // Expose methods to parent component through ref\n  useImperativeHandle(ref, () => ({\n    getCanvas: () => canvasRef.current,\n    changeResolution,\n    getCurrentResolution: () => resolution\n  }));\n\n  return (\n    <div className=\"visualizer-container\">\n      <div \n        ref={containerRef}\n        className={`visualizer-aspect-container ${RESOLUTIONS[resolution].className}`}\n      >\n        {use3D ? (\n          <ThreeVisualizer \n            audioData={audioData}\n            template={template.replace('3d', '')} // Remove '3d' suffix for the ThreeVisualizer\n            isPlaying={isPlaying}\n            parameters={parameters}\n          />\n        ) : (\n          <canvas ref={canvasRef} className=\"visualizer-canvas\"></canvas>\n        )}\n        <div className=\"visualizer-overlay\"></div>\n        <div className=\"resolution-indicator\">{resolution} ({RESOLUTIONS[resolution].width}×{RESOLUTIONS[resolution].height})</div>\n      </div>\n    </div>\n  );\n});\n\nexport default Visualizer; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}