{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\fkuce\\\\OneDrive\\\\Desktop\\\\Money Projects\\\\Visualizer\\\\frontend\\\\src\\\\components\\\\VideoExporter.js\",\n  _s = $RefreshSig$();\nimport React, { useRef, useState, useEffect } from 'react';\nimport './VideoExporter.css';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst VideoExporter = ({\n  visualizerRef,\n  audioFile,\n  isPlaying\n}) => {\n  _s();\n  const [isExporting, setIsExporting] = useState(false);\n  const [progress, setProgress] = useState(0);\n  const [debug, setDebug] = useState('');\n  const mediaRecorderRef = useRef(null);\n  const chunksRef = useRef([]);\n  const startTimeRef = useRef(null);\n  const audioDurationRef = useRef(null);\n  const progressIntervalRef = useRef(null);\n  const audioElementRef = useRef(null);\n\n  // Get audio duration when audio file changes\n  useEffect(() => {\n    if (audioFile) {\n      // Use the same URL format as in Visualizer component\n      const timestamp = new Date().getTime();\n      const audioUrl = `http://localhost:5001${audioFile.path}?t=${timestamp}`;\n      const audio = new Audio(audioUrl);\n      audio.addEventListener('loadedmetadata', () => {\n        audioDurationRef.current = audio.duration;\n        console.log('Audio duration loaded:', audioDurationRef.current);\n      });\n\n      // Add error handling\n      audio.addEventListener('error', e => {\n        console.error('Error loading audio for duration calculation:', e);\n      });\n    }\n    return () => {\n      if (progressIntervalRef.current) {\n        clearInterval(progressIntervalRef.current);\n      }\n    };\n  }, [audioFile]);\n\n  // Clean up on unmount\n  useEffect(() => {\n    return () => {\n      if (audioElementRef.current) {\n        audioElementRef.current.pause();\n        audioElementRef.current.src = '';\n      }\n      if (mediaRecorderRef.current && mediaRecorderRef.current.state === 'recording') {\n        mediaRecorderRef.current.stop();\n      }\n    };\n  }, []);\n  const exportVideo = async () => {\n    if (!(visualizerRef !== null && visualizerRef !== void 0 && visualizerRef.current) || !audioFile) {\n      alert(\"Please upload an audio file first\");\n      return;\n    }\n    try {\n      setIsExporting(true);\n      setProgress(0);\n      setDebug('Starting export process...');\n      startTimeRef.current = Date.now();\n      chunksRef.current = [];\n\n      // Get the canvas element from the visualizer using the exposed method\n      const canvas = visualizerRef.current.getCanvas();\n      if (!canvas) {\n        throw new Error(\"Canvas element not found\");\n      }\n      setDebug(`Canvas found, dimensions: ${canvas.width}x${canvas.height}`);\n\n      // Force a frame to be drawn on the canvas to ensure it has content\n      const ctx = canvas.getContext('2d');\n      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n      ctx.putImageData(imageData, 0, 0);\n\n      // Create a stream from the canvas - try multiple methods\n      let stream = null;\n\n      // Method 1: Standard captureStream\n      try {\n        stream = canvas.captureStream(30);\n        setDebug('Canvas stream created with standard captureStream');\n      } catch (e) {\n        console.error('Standard captureStream failed:', e);\n        setDebug('Standard captureStream failed, trying alternatives...');\n      }\n\n      // Method 2: Mozilla captureStream\n      if (!stream) {\n        try {\n          stream = canvas.mozCaptureStream && canvas.mozCaptureStream(30);\n          if (stream) {\n            setDebug('Canvas stream created with mozCaptureStream');\n          }\n        } catch (e) {\n          console.error('mozCaptureStream failed:', e);\n          setDebug('mozCaptureStream failed, trying alternatives...');\n        }\n      }\n\n      // Method 3: WebKit captureStream\n      if (!stream) {\n        try {\n          stream = canvas.webkitCaptureStream && canvas.webkitCaptureStream(30);\n          if (stream) {\n            setDebug('Canvas stream created with webkitCaptureStream');\n          }\n        } catch (e) {\n          console.error('webkitCaptureStream failed:', e);\n          setDebug('webkitCaptureStream failed');\n        }\n      }\n      if (!stream) {\n        throw new Error(\"Your browser doesn't support canvas streaming. Try using a different browser like Chrome.\");\n      }\n\n      // Verify we have video tracks\n      const videoTracks = stream.getVideoTracks();\n      if (videoTracks.length === 0) {\n        throw new Error(\"No video tracks found in canvas stream\");\n      }\n      setDebug(`Stream created with ${videoTracks.length} video tracks`);\n\n      // Log video track details\n      videoTracks.forEach((track, index) => {\n        console.log(`Video track ${index}:`, track.label, track.enabled, track.readyState);\n      });\n\n      // Create audio context and connect to stream\n      const audioContext = new (window.AudioContext || window.webkitAudioContext)();\n\n      // Use the same URL format as in Visualizer component\n      const timestamp = new Date().getTime();\n      const audioUrl = `http://localhost:5001${audioFile.path}?t=${timestamp}`;\n      const audioElement = new Audio(audioUrl);\n      audioElementRef.current = audioElement;\n\n      // Add error handling for audio element\n      audioElement.addEventListener('error', e => {\n        console.error('Audio element error:', e);\n        setDebug(`Audio error: ${e.message || 'Unknown error'}`);\n        throw new Error(`Failed to load audio: ${e.message}`);\n      });\n\n      // Wait for audio to be loadable before proceeding\n      await new Promise((resolve, reject) => {\n        audioElement.addEventListener('canplaythrough', () => {\n          setDebug('Audio loaded and ready to play');\n          resolve();\n        }, {\n          once: true\n        });\n        audioElement.addEventListener('error', e => {\n          setDebug(`Audio load error: ${e.message || 'Unknown error'}`);\n          reject(new Error(`Audio load error: ${e.message}`));\n        }, {\n          once: true\n        });\n        audioElement.load();\n      });\n      const audioSource = audioContext.createMediaElementSource(audioElement);\n      const audioDestination = audioContext.createMediaStreamDestination();\n      audioSource.connect(audioDestination);\n      audioSource.connect(audioContext.destination); // Also connect to speakers\n\n      // Verify we have audio tracks\n      const audioTracks = audioDestination.stream.getAudioTracks();\n      if (audioTracks.length === 0) {\n        setDebug('Warning: No audio tracks found in audio stream');\n      } else {\n        setDebug(`Audio stream created with ${audioTracks.length} audio tracks`);\n\n        // Log audio track details\n        audioTracks.forEach((track, index) => {\n          console.log(`Audio track ${index}:`, track.label, track.enabled, track.readyState);\n        });\n      }\n\n      // Combine video and audio streams\n      const combinedStream = new MediaStream([...videoTracks, ...audioTracks]);\n\n      // Check if combined stream has tracks\n      if (combinedStream.getTracks().length === 0) {\n        throw new Error(\"Combined stream has no tracks\");\n      }\n      setDebug(`Combined stream created with ${combinedStream.getTracks().length} total tracks`);\n\n      // Try different MIME types in order of preference\n      const mimeTypes = ['video/webm;codecs=vp9,opus', 'video/webm;codecs=vp8,opus', 'video/webm;codecs=h264,opus', 'video/webm;codecs=vp9', 'video/webm;codecs=vp8', 'video/webm'];\n      let selectedMimeType = '';\n      for (const type of mimeTypes) {\n        if (MediaRecorder.isTypeSupported(type)) {\n          selectedMimeType = type;\n          setDebug(`Using MIME type: ${selectedMimeType}`);\n          break;\n        }\n      }\n      if (!selectedMimeType) {\n        setDebug('Warning: No standard MIME types supported, trying without specifying codec');\n      }\n\n      // Create MediaRecorder with appropriate options\n      const options = selectedMimeType ? {\n        mimeType: selectedMimeType,\n        videoBitsPerSecond: 2500000\n      } : {\n        videoBitsPerSecond: 2500000\n      };\n      try {\n        const mediaRecorder = new MediaRecorder(combinedStream, options);\n        mediaRecorderRef.current = mediaRecorder;\n\n        // Log MediaRecorder details\n        console.log('MediaRecorder created:', mediaRecorder.mimeType, mediaRecorder.state);\n        setDebug(`MediaRecorder created with mime type: ${mediaRecorder.mimeType}`);\n\n        // Log MediaRecorder state changes\n        mediaRecorder.addEventListener('start', () => {\n          console.log('MediaRecorder started');\n          setDebug('Recording started');\n        });\n        mediaRecorder.addEventListener('error', event => {\n          console.error('MediaRecorder error:', event);\n          setDebug(`MediaRecorder error: ${event.error || 'Unknown error'}`);\n        });\n\n        // Handle data available - this is critical\n        mediaRecorder.ondataavailable = event => {\n          console.log('Data available event, size:', event.data.size);\n          if (event.data && event.data.size > 0) {\n            chunksRef.current.push(event.data);\n            setDebug(`Received data chunk: ${(event.data.size / 1024).toFixed(2)} KB, total chunks: ${chunksRef.current.length}`);\n          } else {\n            console.warn('Received empty data chunk');\n            setDebug('Warning: Received empty data chunk');\n          }\n        };\n\n        // Handle recording stop\n        mediaRecorder.onstop = () => {\n          console.log('MediaRecorder stopped, chunks:', chunksRef.current.length);\n          setDebug(`Recording stopped with ${chunksRef.current.length} chunks`);\n          if (chunksRef.current.length === 0) {\n            setDebug('Error: No data chunks were recorded');\n            alert('Error: No video data was captured during recording. This may be due to browser compatibility issues. Try using Chrome or Edge.');\n            setIsExporting(false);\n            return;\n          }\n\n          // Calculate total size of all chunks\n          const totalSize = chunksRef.current.reduce((size, chunk) => size + chunk.size, 0);\n          setDebug(`Total data size: ${(totalSize / 1024).toFixed(2)} KB`);\n          if (totalSize === 0) {\n            setDebug('Error: Recorded data has zero size');\n            alert('Error: The recorded video has no data (0 bytes). Try using a different browser or visualization.');\n            setIsExporting(false);\n            return;\n          }\n\n          // Create blob from chunks\n          const blob = new Blob(chunksRef.current, {\n            type: selectedMimeType || 'video/webm'\n          });\n          console.log('Created blob, size:', blob.size);\n          setDebug(`Created video blob: ${(blob.size / 1024).toFixed(2)} KB`);\n          if (blob.size === 0) {\n            setDebug('Error: Final blob has zero size');\n            alert('Error: The final video file has no data (0 bytes). Try using a different browser.');\n            setIsExporting(false);\n            return;\n          }\n          const url = URL.createObjectURL(blob);\n\n          // Create filename based on audio file name with fallback\n          let fileName = \"visualization.webm\";\n          if (audioFile && audioFile.name) {\n            fileName = audioFile.name.replace(/\\.[^/.]+$/, \"\") + \"_visualization.webm\";\n          } else if (audioFile && audioFile.path) {\n            // Extract filename from path as fallback\n            const pathParts = audioFile.path.split('/');\n            const pathFileName = pathParts[pathParts.length - 1];\n            fileName = pathFileName.replace(/\\.[^/.]+$/, \"\") + \"_visualization.webm\";\n          }\n\n          // Download the file\n          const a = document.createElement('a');\n          a.href = url;\n          a.download = fileName;\n          a.click();\n\n          // Clean up\n          URL.revokeObjectURL(url);\n          setIsExporting(false);\n          setProgress(100);\n          setDebug('Export completed successfully');\n\n          // Clear progress interval\n          if (progressIntervalRef.current) {\n            clearInterval(progressIntervalRef.current);\n            progressIntervalRef.current = null;\n          }\n\n          // Stop and clean up audio element\n          if (audioElementRef.current) {\n            audioElementRef.current.pause();\n            audioElementRef.current.src = '';\n          }\n        };\n\n        // Force data collection more frequently\n        mediaRecorder.start(100); // Capture in 100ms chunks for more frequent data\n        setDebug('MediaRecorder started with 100ms timeslice');\n\n        // Start audio playback\n        try {\n          await audioElement.play();\n          setDebug('Audio playback started');\n        } catch (playError) {\n          console.error('Error playing audio:', playError);\n          setDebug(`Failed to play audio: ${playError.message || 'Unknown error'}`);\n          throw new Error(`Failed to play audio: ${playError.message}`);\n        }\n\n        // Periodically request data to ensure chunks are being collected\n        const dataRequestInterval = setInterval(() => {\n          if (mediaRecorderRef.current && mediaRecorderRef.current.state === 'recording') {\n            mediaRecorderRef.current.requestData();\n          }\n        }, 1000);\n\n        // Update progress based on audio time\n        progressIntervalRef.current = setInterval(() => {\n          if (audioDurationRef.current) {\n            const elapsed = (Date.now() - startTimeRef.current) / 1000;\n            const percentage = Math.min(Math.floor(elapsed / audioDurationRef.current * 100), 99);\n            setProgress(percentage);\n\n            // Log data chunks periodically\n            setDebug(`Progress: ${percentage}%, Chunks: ${chunksRef.current.length}, Duration: ${elapsed.toFixed(1)}s/${audioDurationRef.current.toFixed(1)}s`);\n\n            // If we've been recording for a while but have no chunks, something is wrong\n            if (elapsed > 3 && chunksRef.current.length === 0) {\n              setDebug('Warning: No data chunks received after 3 seconds');\n            }\n          }\n        }, 500);\n\n        // Stop recording when audio ends\n        audioElement.onended = () => {\n          setDebug('Audio playback ended, stopping recording');\n\n          // Clear the data request interval\n          clearInterval(dataRequestInterval);\n          if (mediaRecorderRef.current && mediaRecorderRef.current.state === 'recording') {\n            // Force one last dataavailable event before stopping\n            mediaRecorderRef.current.requestData();\n\n            // Small delay to ensure the last data is captured\n            setTimeout(() => {\n              mediaRecorderRef.current.stop();\n              audioElement.onended = null;\n            }, 500);\n          }\n        };\n      } catch (recorderError) {\n        console.error('Error creating MediaRecorder:', recorderError);\n        setDebug(`Failed to create MediaRecorder: ${recorderError.message}`);\n        throw new Error(`Failed to create MediaRecorder: ${recorderError.message}. Try using a different browser.`);\n      }\n    } catch (error) {\n      console.error(\"Error exporting video:\", error);\n      setDebug(`Export error: ${error.message || 'Unknown error'}`);\n      alert(`Error exporting video: ${error.message}`);\n      setIsExporting(false);\n\n      // Clean up on error\n      if (audioElementRef.current) {\n        audioElementRef.current.pause();\n        audioElementRef.current.src = '';\n      }\n    }\n  };\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"video-exporter\",\n    children: isExporting ? /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"export-progress\",\n      children: [/*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"progress-bar\",\n        children: /*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"progress-fill\",\n          style: {\n            width: `${progress}%`\n          }\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 405,\n          columnNumber: 13\n        }, this)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 404,\n        columnNumber: 11\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"progress-text\",\n        children: [progress, \"% Exporting...\"]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 407,\n        columnNumber: 11\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"debug-info\",\n        children: debug\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 408,\n        columnNumber: 11\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 403,\n      columnNumber: 9\n    }, this) : /*#__PURE__*/_jsxDEV(\"button\", {\n      className: \"export-button\",\n      onClick: exportVideo,\n      disabled: !visualizerRef || !audioFile || isPlaying,\n      children: \"Export Video\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 411,\n      columnNumber: 9\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 401,\n    columnNumber: 5\n  }, this);\n};\n_s(VideoExporter, \"8j3bNp0WxG1WZqhNVGBN6IuWe+g=\");\n_c = VideoExporter;\nexport default VideoExporter;\nvar _c;\n$RefreshReg$(_c, \"VideoExporter\");","map":{"version":3,"names":["React","useRef","useState","useEffect","jsxDEV","_jsxDEV","VideoExporter","visualizerRef","audioFile","isPlaying","_s","isExporting","setIsExporting","progress","setProgress","debug","setDebug","mediaRecorderRef","chunksRef","startTimeRef","audioDurationRef","progressIntervalRef","audioElementRef","timestamp","Date","getTime","audioUrl","path","audio","Audio","addEventListener","current","duration","console","log","e","error","clearInterval","pause","src","state","stop","exportVideo","alert","now","canvas","getCanvas","Error","width","height","ctx","getContext","imageData","getImageData","putImageData","stream","captureStream","mozCaptureStream","webkitCaptureStream","videoTracks","getVideoTracks","length","forEach","track","index","label","enabled","readyState","audioContext","window","AudioContext","webkitAudioContext","audioElement","message","Promise","resolve","reject","once","load","audioSource","createMediaElementSource","audioDestination","createMediaStreamDestination","connect","destination","audioTracks","getAudioTracks","combinedStream","MediaStream","getTracks","mimeTypes","selectedMimeType","type","MediaRecorder","isTypeSupported","options","mimeType","videoBitsPerSecond","mediaRecorder","event","ondataavailable","data","size","push","toFixed","warn","onstop","totalSize","reduce","chunk","blob","Blob","url","URL","createObjectURL","fileName","name","replace","pathParts","split","pathFileName","a","document","createElement","href","download","click","revokeObjectURL","start","play","playError","dataRequestInterval","setInterval","requestData","elapsed","percentage","Math","min","floor","onended","setTimeout","recorderError","className","children","style","_jsxFileName","lineNumber","columnNumber","onClick","disabled","_c","$RefreshReg$"],"sources":["C:/Users/fkuce/OneDrive/Desktop/Money Projects/Visualizer/frontend/src/components/VideoExporter.js"],"sourcesContent":["import React, { useRef, useState, useEffect } from 'react';\nimport './VideoExporter.css';\n\nconst VideoExporter = ({ visualizerRef, audioFile, isPlaying }) => {\n  const [isExporting, setIsExporting] = useState(false);\n  const [progress, setProgress] = useState(0);\n  const [debug, setDebug] = useState('');\n  const mediaRecorderRef = useRef(null);\n  const chunksRef = useRef([]);\n  const startTimeRef = useRef(null);\n  const audioDurationRef = useRef(null);\n  const progressIntervalRef = useRef(null);\n  const audioElementRef = useRef(null);\n\n  // Get audio duration when audio file changes\n  useEffect(() => {\n    if (audioFile) {\n      // Use the same URL format as in Visualizer component\n      const timestamp = new Date().getTime();\n      const audioUrl = `http://localhost:5001${audioFile.path}?t=${timestamp}`;\n      const audio = new Audio(audioUrl);\n      \n      audio.addEventListener('loadedmetadata', () => {\n        audioDurationRef.current = audio.duration;\n        console.log('Audio duration loaded:', audioDurationRef.current);\n      });\n      \n      // Add error handling\n      audio.addEventListener('error', (e) => {\n        console.error('Error loading audio for duration calculation:', e);\n      });\n    }\n    return () => {\n      if (progressIntervalRef.current) {\n        clearInterval(progressIntervalRef.current);\n      }\n    };\n  }, [audioFile]);\n\n  // Clean up on unmount\n  useEffect(() => {\n    return () => {\n      if (audioElementRef.current) {\n        audioElementRef.current.pause();\n        audioElementRef.current.src = '';\n      }\n      if (mediaRecorderRef.current && mediaRecorderRef.current.state === 'recording') {\n        mediaRecorderRef.current.stop();\n      }\n    };\n  }, []);\n\n  const exportVideo = async () => {\n    if (!visualizerRef?.current || !audioFile) {\n      alert(\"Please upload an audio file first\");\n      return;\n    }\n\n    try {\n      setIsExporting(true);\n      setProgress(0);\n      setDebug('Starting export process...');\n      startTimeRef.current = Date.now();\n      chunksRef.current = [];\n\n      // Get the canvas element from the visualizer using the exposed method\n      const canvas = visualizerRef.current.getCanvas();\n      if (!canvas) {\n        throw new Error(\"Canvas element not found\");\n      }\n      setDebug(`Canvas found, dimensions: ${canvas.width}x${canvas.height}`);\n\n      // Force a frame to be drawn on the canvas to ensure it has content\n      const ctx = canvas.getContext('2d');\n      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n      ctx.putImageData(imageData, 0, 0);\n\n      // Create a stream from the canvas - try multiple methods\n      let stream = null;\n      \n      // Method 1: Standard captureStream\n      try {\n        stream = canvas.captureStream(30);\n        setDebug('Canvas stream created with standard captureStream');\n      } catch (e) {\n        console.error('Standard captureStream failed:', e);\n        setDebug('Standard captureStream failed, trying alternatives...');\n      }\n      \n      // Method 2: Mozilla captureStream\n      if (!stream) {\n        try {\n          stream = canvas.mozCaptureStream && canvas.mozCaptureStream(30);\n          if (stream) {\n            setDebug('Canvas stream created with mozCaptureStream');\n          }\n        } catch (e) {\n          console.error('mozCaptureStream failed:', e);\n          setDebug('mozCaptureStream failed, trying alternatives...');\n        }\n      }\n      \n      // Method 3: WebKit captureStream\n      if (!stream) {\n        try {\n          stream = canvas.webkitCaptureStream && canvas.webkitCaptureStream(30);\n          if (stream) {\n            setDebug('Canvas stream created with webkitCaptureStream');\n          }\n        } catch (e) {\n          console.error('webkitCaptureStream failed:', e);\n          setDebug('webkitCaptureStream failed');\n        }\n      }\n\n      if (!stream) {\n        throw new Error(\"Your browser doesn't support canvas streaming. Try using a different browser like Chrome.\");\n      }\n\n      // Verify we have video tracks\n      const videoTracks = stream.getVideoTracks();\n      if (videoTracks.length === 0) {\n        throw new Error(\"No video tracks found in canvas stream\");\n      }\n      setDebug(`Stream created with ${videoTracks.length} video tracks`);\n      \n      // Log video track details\n      videoTracks.forEach((track, index) => {\n        console.log(`Video track ${index}:`, track.label, track.enabled, track.readyState);\n      });\n\n      // Create audio context and connect to stream\n      const audioContext = new (window.AudioContext || window.webkitAudioContext)();\n      \n      // Use the same URL format as in Visualizer component\n      const timestamp = new Date().getTime();\n      const audioUrl = `http://localhost:5001${audioFile.path}?t=${timestamp}`;\n      const audioElement = new Audio(audioUrl);\n      audioElementRef.current = audioElement;\n      \n      // Add error handling for audio element\n      audioElement.addEventListener('error', (e) => {\n        console.error('Audio element error:', e);\n        setDebug(`Audio error: ${e.message || 'Unknown error'}`);\n        throw new Error(`Failed to load audio: ${e.message}`);\n      });\n      \n      // Wait for audio to be loadable before proceeding\n      await new Promise((resolve, reject) => {\n        audioElement.addEventListener('canplaythrough', () => {\n          setDebug('Audio loaded and ready to play');\n          resolve();\n        }, { once: true });\n        audioElement.addEventListener('error', (e) => {\n          setDebug(`Audio load error: ${e.message || 'Unknown error'}`);\n          reject(new Error(`Audio load error: ${e.message}`));\n        }, { once: true });\n        audioElement.load();\n      });\n      \n      const audioSource = audioContext.createMediaElementSource(audioElement);\n      const audioDestination = audioContext.createMediaStreamDestination();\n      audioSource.connect(audioDestination);\n      audioSource.connect(audioContext.destination); // Also connect to speakers\n\n      // Verify we have audio tracks\n      const audioTracks = audioDestination.stream.getAudioTracks();\n      if (audioTracks.length === 0) {\n        setDebug('Warning: No audio tracks found in audio stream');\n      } else {\n        setDebug(`Audio stream created with ${audioTracks.length} audio tracks`);\n        \n        // Log audio track details\n        audioTracks.forEach((track, index) => {\n          console.log(`Audio track ${index}:`, track.label, track.enabled, track.readyState);\n        });\n      }\n\n      // Combine video and audio streams\n      const combinedStream = new MediaStream([\n        ...videoTracks,\n        ...audioTracks\n      ]);\n\n      // Check if combined stream has tracks\n      if (combinedStream.getTracks().length === 0) {\n        throw new Error(\"Combined stream has no tracks\");\n      }\n      setDebug(`Combined stream created with ${combinedStream.getTracks().length} total tracks`);\n\n      // Try different MIME types in order of preference\n      const mimeTypes = [\n        'video/webm;codecs=vp9,opus',\n        'video/webm;codecs=vp8,opus',\n        'video/webm;codecs=h264,opus',\n        'video/webm;codecs=vp9',\n        'video/webm;codecs=vp8',\n        'video/webm'\n      ];\n      \n      let selectedMimeType = '';\n      for (const type of mimeTypes) {\n        if (MediaRecorder.isTypeSupported(type)) {\n          selectedMimeType = type;\n          setDebug(`Using MIME type: ${selectedMimeType}`);\n          break;\n        }\n      }\n      \n      if (!selectedMimeType) {\n        setDebug('Warning: No standard MIME types supported, trying without specifying codec');\n      }\n      \n      // Create MediaRecorder with appropriate options\n      const options = selectedMimeType \n        ? { mimeType: selectedMimeType, videoBitsPerSecond: 2500000 }\n        : { videoBitsPerSecond: 2500000 };\n        \n      try {\n        const mediaRecorder = new MediaRecorder(combinedStream, options);\n        mediaRecorderRef.current = mediaRecorder;\n        \n        // Log MediaRecorder details\n        console.log('MediaRecorder created:', mediaRecorder.mimeType, mediaRecorder.state);\n        setDebug(`MediaRecorder created with mime type: ${mediaRecorder.mimeType}`);\n        \n        // Log MediaRecorder state changes\n        mediaRecorder.addEventListener('start', () => {\n          console.log('MediaRecorder started');\n          setDebug('Recording started');\n        });\n\n        mediaRecorder.addEventListener('error', (event) => {\n          console.error('MediaRecorder error:', event);\n          setDebug(`MediaRecorder error: ${event.error || 'Unknown error'}`);\n        });\n\n        // Handle data available - this is critical\n        mediaRecorder.ondataavailable = (event) => {\n          console.log('Data available event, size:', event.data.size);\n          if (event.data && event.data.size > 0) {\n            chunksRef.current.push(event.data);\n            setDebug(`Received data chunk: ${(event.data.size / 1024).toFixed(2)} KB, total chunks: ${chunksRef.current.length}`);\n          } else {\n            console.warn('Received empty data chunk');\n            setDebug('Warning: Received empty data chunk');\n          }\n        };\n\n        // Handle recording stop\n        mediaRecorder.onstop = () => {\n          console.log('MediaRecorder stopped, chunks:', chunksRef.current.length);\n          setDebug(`Recording stopped with ${chunksRef.current.length} chunks`);\n          \n          if (chunksRef.current.length === 0) {\n            setDebug('Error: No data chunks were recorded');\n            alert('Error: No video data was captured during recording. This may be due to browser compatibility issues. Try using Chrome or Edge.');\n            setIsExporting(false);\n            return;\n          }\n          \n          // Calculate total size of all chunks\n          const totalSize = chunksRef.current.reduce((size, chunk) => size + chunk.size, 0);\n          setDebug(`Total data size: ${(totalSize / 1024).toFixed(2)} KB`);\n          \n          if (totalSize === 0) {\n            setDebug('Error: Recorded data has zero size');\n            alert('Error: The recorded video has no data (0 bytes). Try using a different browser or visualization.');\n            setIsExporting(false);\n            return;\n          }\n\n          // Create blob from chunks\n          const blob = new Blob(chunksRef.current, { type: selectedMimeType || 'video/webm' });\n          console.log('Created blob, size:', blob.size);\n          setDebug(`Created video blob: ${(blob.size / 1024).toFixed(2)} KB`);\n          \n          if (blob.size === 0) {\n            setDebug('Error: Final blob has zero size');\n            alert('Error: The final video file has no data (0 bytes). Try using a different browser.');\n            setIsExporting(false);\n            return;\n          }\n          \n          const url = URL.createObjectURL(blob);\n          \n          // Create filename based on audio file name with fallback\n          let fileName = \"visualization.webm\";\n          if (audioFile && audioFile.name) {\n            fileName = audioFile.name.replace(/\\.[^/.]+$/, \"\") + \"_visualization.webm\";\n          } else if (audioFile && audioFile.path) {\n            // Extract filename from path as fallback\n            const pathParts = audioFile.path.split('/');\n            const pathFileName = pathParts[pathParts.length - 1];\n            fileName = pathFileName.replace(/\\.[^/.]+$/, \"\") + \"_visualization.webm\";\n          }\n          \n          // Download the file\n          const a = document.createElement('a');\n          a.href = url;\n          a.download = fileName;\n          a.click();\n          \n          // Clean up\n          URL.revokeObjectURL(url);\n          setIsExporting(false);\n          setProgress(100);\n          setDebug('Export completed successfully');\n          \n          // Clear progress interval\n          if (progressIntervalRef.current) {\n            clearInterval(progressIntervalRef.current);\n            progressIntervalRef.current = null;\n          }\n          \n          // Stop and clean up audio element\n          if (audioElementRef.current) {\n            audioElementRef.current.pause();\n            audioElementRef.current.src = '';\n          }\n        };\n\n        // Force data collection more frequently\n        mediaRecorder.start(100); // Capture in 100ms chunks for more frequent data\n        setDebug('MediaRecorder started with 100ms timeslice');\n\n        // Start audio playback\n        try {\n          await audioElement.play();\n          setDebug('Audio playback started');\n        } catch (playError) {\n          console.error('Error playing audio:', playError);\n          setDebug(`Failed to play audio: ${playError.message || 'Unknown error'}`);\n          throw new Error(`Failed to play audio: ${playError.message}`);\n        }\n\n        // Periodically request data to ensure chunks are being collected\n        const dataRequestInterval = setInterval(() => {\n          if (mediaRecorderRef.current && mediaRecorderRef.current.state === 'recording') {\n            mediaRecorderRef.current.requestData();\n          }\n        }, 1000);\n\n        // Update progress based on audio time\n        progressIntervalRef.current = setInterval(() => {\n          if (audioDurationRef.current) {\n            const elapsed = (Date.now() - startTimeRef.current) / 1000;\n            const percentage = Math.min(Math.floor((elapsed / audioDurationRef.current) * 100), 99);\n            setProgress(percentage);\n            \n            // Log data chunks periodically\n            setDebug(`Progress: ${percentage}%, Chunks: ${chunksRef.current.length}, Duration: ${elapsed.toFixed(1)}s/${audioDurationRef.current.toFixed(1)}s`);\n            \n            // If we've been recording for a while but have no chunks, something is wrong\n            if (elapsed > 3 && chunksRef.current.length === 0) {\n              setDebug('Warning: No data chunks received after 3 seconds');\n            }\n          }\n        }, 500);\n\n        // Stop recording when audio ends\n        audioElement.onended = () => {\n          setDebug('Audio playback ended, stopping recording');\n          \n          // Clear the data request interval\n          clearInterval(dataRequestInterval);\n          \n          if (mediaRecorderRef.current && mediaRecorderRef.current.state === 'recording') {\n            // Force one last dataavailable event before stopping\n            mediaRecorderRef.current.requestData();\n            \n            // Small delay to ensure the last data is captured\n            setTimeout(() => {\n              mediaRecorderRef.current.stop();\n              audioElement.onended = null;\n            }, 500);\n          }\n        };\n        \n      } catch (recorderError) {\n        console.error('Error creating MediaRecorder:', recorderError);\n        setDebug(`Failed to create MediaRecorder: ${recorderError.message}`);\n        throw new Error(`Failed to create MediaRecorder: ${recorderError.message}. Try using a different browser.`);\n      }\n\n    } catch (error) {\n      console.error(\"Error exporting video:\", error);\n      setDebug(`Export error: ${error.message || 'Unknown error'}`);\n      alert(`Error exporting video: ${error.message}`);\n      setIsExporting(false);\n      \n      // Clean up on error\n      if (audioElementRef.current) {\n        audioElementRef.current.pause();\n        audioElementRef.current.src = '';\n      }\n    }\n  };\n\n  return (\n    <div className=\"video-exporter\">\n      {isExporting ? (\n        <div className=\"export-progress\">\n          <div className=\"progress-bar\">\n            <div className=\"progress-fill\" style={{ width: `${progress}%` }}></div>\n          </div>\n          <div className=\"progress-text\">{progress}% Exporting...</div>\n          <div className=\"debug-info\">{debug}</div>\n        </div>\n      ) : (\n        <button\n          className=\"export-button\"\n          onClick={exportVideo}\n          disabled={!visualizerRef || !audioFile || isPlaying}\n        >\n          Export Video\n        </button>\n      )}\n    </div>\n  );\n};\n\nexport default VideoExporter; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}