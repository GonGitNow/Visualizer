{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\fkuce\\\\OneDrive\\\\Desktop\\\\Money Projects\\\\Visualizer\\\\frontend\\\\src\\\\components\\\\VideoExporter.js\",\n  _s = $RefreshSig$();\nimport React, { useRef, useState, useEffect } from 'react';\nimport './VideoExporter.css';\n\n// This is a more direct approach that will work with the specific structure of this app\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst VideoExporter = ({\n  visualizerRef,\n  audioFile,\n  isPlaying\n}) => {\n  _s();\n  const [isExporting, setIsExporting] = useState(false);\n  const [progress, setProgress] = useState(0);\n  const [debug, setDebug] = useState('');\n  const mediaRecorderRef = useRef(null);\n  const chunksRef = useRef([]);\n  const startTimeRef = useRef(null);\n  const audioDurationRef = useRef(null);\n  const progressIntervalRef = useRef(null);\n  const dataRequestIntervalRef = useRef(null);\n  const audioContextRef = useRef(null);\n  const audioSourceRef = useRef(null);\n  const audioElementRef = useRef(null);\n  const visualizerActivatedRef = useRef(false);\n  const lastActivationTimeRef = useRef(0);\n\n  // High quality settings\n  const HIGH_VIDEO_BITRATE = 8000000; // 8 Mbps for high quality video\n  const HIGH_AUDIO_BITRATE = 320000; // 320 kbps for high quality audio\n  const FRAME_RATE = 60; // 60 fps for smooth animation\n\n  // Minimum time between visualizer activations (in ms)\n  const MIN_ACTIVATION_INTERVAL = 5000; // 5 seconds\n\n  // Clean up on unmount\n  useEffect(() => {\n    return () => {\n      cleanupResources();\n    };\n  }, []);\n\n  // Clean up resources function to centralize cleanup logic\n  const cleanupResources = () => {\n    if (progressIntervalRef.current) {\n      clearInterval(progressIntervalRef.current);\n      progressIntervalRef.current = null;\n    }\n    if (dataRequestIntervalRef.current) {\n      clearInterval(dataRequestIntervalRef.current);\n      dataRequestIntervalRef.current = null;\n    }\n    if (audioSourceRef.current) {\n      try {\n        audioSourceRef.current.disconnect();\n      } catch (e) {\n        console.error('Error disconnecting audio source:', e);\n      }\n      audioSourceRef.current = null;\n    }\n    if (audioElementRef.current) {\n      try {\n        audioElementRef.current.pause();\n        // Remove all event listeners\n        audioElementRef.current.oncanplaythrough = null;\n        audioElementRef.current.onerror = null;\n        audioElementRef.current.onended = null;\n        // Clear source and load to release resources\n        audioElementRef.current.removeAttribute('src');\n        audioElementRef.current.load();\n      } catch (e) {\n        console.error('Error cleaning up audio element:', e);\n      }\n      audioElementRef.current = null;\n    }\n    if (audioContextRef.current && audioContextRef.current.state !== 'closed') {\n      try {\n        audioContextRef.current.close().catch(e => console.error('Error closing audio context:', e));\n      } catch (e) {\n        console.error('Error closing audio context:', e);\n      }\n      audioContextRef.current = null;\n    }\n    if (mediaRecorderRef.current && mediaRecorderRef.current.state === 'recording') {\n      try {\n        mediaRecorderRef.current.stop();\n      } catch (e) {\n        console.error('Error stopping media recorder:', e);\n      }\n      mediaRecorderRef.current = null;\n    }\n\n    // Reset visualizer activation state\n    visualizerActivatedRef.current = false;\n    lastActivationTimeRef.current = 0;\n    chunksRef.current = [];\n  };\n\n  // Validate that the audio file path is valid\n  const validateAudioFile = () => {\n    if (!audioFile) {\n      return false;\n    }\n    if (!audioFile.path) {\n      console.error('Audio file has no path');\n      setDebug('Error: Audio file has no path');\n      return false;\n    }\n    return true;\n  };\n\n  // Function to ensure the visualizer is active and rendering\n  const ensureVisualizerActive = () => {\n    if (!(visualizerRef !== null && visualizerRef !== void 0 && visualizerRef.current)) {\n      console.error('Visualizer reference not available');\n      return false;\n    }\n\n    // Force a render cycle on the canvas to ensure it's active\n    const canvas = visualizerRef.current.getCanvas();\n    if (!canvas) {\n      console.error('Canvas not found in visualizer');\n      return false;\n    }\n    try {\n      // Force a frame to be drawn on the canvas to ensure it has content\n      const ctx = canvas.getContext('2d');\n      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n      ctx.putImageData(imageData, 0, 0);\n      return true;\n    } catch (e) {\n      console.error('Error activating visualizer:', e);\n      return false;\n    }\n  };\n\n  // Get the current canvas resolution\n  const getCanvasResolution = canvas => {\n    if (!canvas) return {\n      width: 0,\n      height: 0\n    };\n\n    // Get the actual canvas dimensions\n    const width = canvas.width;\n    const height = canvas.height;\n\n    // Log the resolution\n    console.log(`Canvas resolution: ${width}x${height}`);\n    setDebug(`Canvas resolution: ${width}x${height}`);\n    return {\n      width,\n      height\n    };\n  };\n\n  // CRITICAL: This function directly manipulates the App's isPlaying state\n  // This is the most direct way to force the visualizer to activate\n  const forceActivateVisualizer = () => {\n    // Check if we've already activated the visualizer recently\n    const now = Date.now();\n    if (visualizerActivatedRef.current && now - lastActivationTimeRef.current < MIN_ACTIVATION_INTERVAL) {\n      // Skip activation if we've already activated recently\n      return false;\n    }\n    try {\n      // Find the App component's setIsPlaying function\n      // We need to look for it in the global scope or window object\n      // This is a hack, but it's the most reliable way to force the visualizer to activate\n\n      // First, try to find any play buttons in the DOM\n      const playButtons = document.querySelectorAll('button');\n      let playButton = null;\n\n      // Look for a button that might be the play button\n      for (const button of playButtons) {\n        if (button.textContent.includes('Play') || button.className.includes('play') || button.title.includes('Play')) {\n          playButton = button;\n          break;\n        }\n      }\n      if (playButton) {\n        // Simulate a click on the play button to activate the visualizer\n        setDebug('Found play button, simulating click to activate visualizer');\n        playButton.click();\n\n        // After a short delay, click it again to pause if we're exporting\n        // This ensures the visualizer is active but we don't have double audio\n        setTimeout(() => {\n          if (isExporting) {\n            playButton.click();\n            setDebug('Paused audio after activating visualizer');\n\n            // Mark the visualizer as activated and update the last activation time\n            visualizerActivatedRef.current = true;\n            lastActivationTimeRef.current = Date.now();\n          }\n        }, 300);\n        return true;\n      }\n\n      // If we couldn't find a play button, try to find the audio element directly\n      const audioElements = document.querySelectorAll('audio');\n      if (audioElements.length > 0) {\n        setDebug('Found audio element, trying to play/pause to activate visualizer');\n\n        // Try to play and then immediately pause the first audio element\n        const audio = audioElements[0];\n        audio.play().then(() => {\n          setTimeout(() => {\n            if (isExporting) {\n              audio.pause();\n              setDebug('Paused audio after activating visualizer');\n\n              // Mark the visualizer as activated and update the last activation time\n              visualizerActivatedRef.current = true;\n              lastActivationTimeRef.current = Date.now();\n            }\n          }, 300);\n        }).catch(e => {\n          console.error('Error playing audio to activate visualizer:', e);\n        });\n        return true;\n      }\n      setDebug('Could not find play button or audio element to activate visualizer');\n      return false;\n    } catch (e) {\n      console.error('Error forcing visualizer activation:', e);\n      setDebug(`Error forcing visualizer activation: ${e.message}`);\n      return false;\n    }\n  };\n  const exportVideo = async () => {\n    if (!(visualizerRef !== null && visualizerRef !== void 0 && visualizerRef.current) || !audioFile) {\n      alert(\"Please upload an audio file first\");\n      return;\n    }\n\n    // Validate audio file\n    if (!validateAudioFile()) {\n      alert(\"Invalid audio file. Please upload a valid audio file.\");\n      return;\n    }\n\n    // Check if already exporting\n    if (isExporting) {\n      console.log('Already exporting, ignoring request');\n      return;\n    }\n    try {\n      // Clean up any existing resources first\n      cleanupResources();\n      setIsExporting(true);\n      setProgress(0);\n      setDebug('Starting export process...');\n      startTimeRef.current = Date.now();\n\n      // Reset visualizer activation state\n      visualizerActivatedRef.current = false;\n      lastActivationTimeRef.current = 0;\n\n      // CRITICAL: Force activate the visualizer first\n      // This is the most important step to ensure the visualizer is active\n      setDebug('Forcing visualizer activation...');\n      forceActivateVisualizer();\n\n      // Short delay to ensure the visualizer has time to activate\n      await new Promise(resolve => setTimeout(resolve, 500));\n\n      // Ensure visualizer is active\n      if (!ensureVisualizerActive()) {\n        throw new Error(\"Could not activate visualizer\");\n      }\n\n      // Get the canvas element from the visualizer using the exposed method\n      const canvas = visualizerRef.current.getCanvas();\n      if (!canvas) {\n        throw new Error(\"Canvas element not found\");\n      }\n\n      // Get and log the canvas resolution\n      const resolution = getCanvasResolution(canvas);\n      setDebug(`Canvas found, dimensions: ${resolution.width}x${resolution.height}`);\n\n      // Ensure the canvas has a reasonable size for high-quality export\n      if (resolution.width < 720 || resolution.height < 720) {\n        setDebug(`Warning: Canvas resolution (${resolution.width}x${resolution.height}) is low. Consider using a higher resolution for better quality.`);\n      }\n\n      // Create a stream from the canvas with high frame rate\n      let stream = null;\n\n      // Method 1: Standard captureStream with high frame rate\n      try {\n        stream = canvas.captureStream(FRAME_RATE);\n        setDebug(`Canvas stream created with ${FRAME_RATE}fps`);\n      } catch (e) {\n        console.error('Standard captureStream failed:', e);\n        setDebug('Standard captureStream failed, trying alternatives...');\n      }\n\n      // Method 2: Mozilla captureStream\n      if (!stream) {\n        try {\n          stream = canvas.mozCaptureStream && canvas.mozCaptureStream(FRAME_RATE);\n          if (stream) {\n            setDebug(`Canvas stream created with mozCaptureStream at ${FRAME_RATE}fps`);\n          }\n        } catch (e) {\n          console.error('mozCaptureStream failed:', e);\n          setDebug('mozCaptureStream failed, trying alternatives...');\n        }\n      }\n\n      // Method 3: WebKit captureStream\n      if (!stream) {\n        try {\n          stream = canvas.webkitCaptureStream && canvas.webkitCaptureStream(FRAME_RATE);\n          if (stream) {\n            setDebug(`Canvas stream created with webkitCaptureStream at ${FRAME_RATE}fps`);\n          }\n        } catch (e) {\n          console.error('webkitCaptureStream failed:', e);\n          setDebug('webkitCaptureStream failed');\n        }\n      }\n      if (!stream) {\n        throw new Error(\"Your browser doesn't support canvas streaming. Try using a different browser like Chrome.\");\n      }\n\n      // Verify we have video tracks\n      const videoTracks = stream.getVideoTracks();\n      if (videoTracks.length === 0) {\n        throw new Error(\"No video tracks found in canvas stream\");\n      }\n      setDebug(`Stream created with ${videoTracks.length} video tracks`);\n\n      // Log video track details and try to set constraints for higher quality\n      videoTracks.forEach((track, index) => {\n        console.log(`Video track ${index}:`, track.label, track.enabled, track.readyState);\n\n        // Try to set constraints for higher quality if supported\n        try {\n          if (track.applyConstraints) {\n            track.applyConstraints({\n              width: {\n                ideal: resolution.width\n              },\n              height: {\n                ideal: resolution.height\n              },\n              frameRate: {\n                ideal: FRAME_RATE\n              }\n            });\n            console.log(`Applied constraints to video track ${index}`);\n          }\n        } catch (e) {\n          console.error('Could not apply constraints to video track:', e);\n        }\n      });\n\n      // Create audio context and connect to stream - use a more reliable approach\n      try {\n        // Create a new audio context with high sample rate\n        const AudioContext = window.AudioContext || window.webkitAudioContext;\n        const audioContext = new AudioContext({\n          sampleRate: 48000\n        });\n        audioContextRef.current = audioContext;\n\n        // Construct the audio URL with proper encoding\n        const timestamp = new Date().getTime();\n        // Ensure the path is properly encoded\n        const encodedPath = encodeURI(audioFile.path);\n        const audioUrl = `http://localhost:5001${encodedPath}?t=${timestamp}`;\n        console.log('Audio URL:', audioUrl);\n        setDebug(`Using audio URL: ${audioUrl}`);\n\n        // Create a new audio element for playback during recording\n        const audioElement = new Audio();\n        audioElement.crossOrigin = \"anonymous\";\n        audioElement.preload = \"auto\";\n        audioElementRef.current = audioElement;\n\n        // Set up error handler before setting source\n        audioElement.onerror = e => {\n          const errorDetail = e.target.error ? `${e.target.error.message || ''} (code: ${e.target.error.code})` : 'Unknown error';\n          console.error('Audio error:', e.target.error);\n          setDebug(`Audio error: ${errorDetail}`);\n          throw new Error(`Audio error: ${errorDetail}`);\n        };\n\n        // Wait for audio to be loaded enough to play\n        setDebug('Loading audio...');\n\n        // Create a promise to handle audio loading\n        const audioLoadPromise = new Promise((resolve, reject) => {\n          // Set up success handler\n          audioElement.oncanplaythrough = () => {\n            console.log('Audio loaded successfully, duration:', audioElement.duration);\n            setDebug('Audio loaded successfully');\n            resolve();\n          };\n\n          // Set up error handler\n          audioElement.onerror = e => {\n            const errorDetail = e.target.error ? `${e.target.error.message || ''} (code: ${e.target.error.code})` : 'Unknown error';\n            console.error('Audio load error:', e.target.error);\n            setDebug(`Audio load error: ${errorDetail}`);\n            reject(new Error(`Audio load error: ${errorDetail}`));\n          };\n\n          // Set a timeout in case the audio never loads\n          const timeoutId = setTimeout(() => {\n            audioElement.oncanplaythrough = null;\n            audioElement.onerror = null;\n            setDebug('Audio load timeout - took too long to load');\n            reject(new Error('Audio load timeout - took too long to load'));\n          }, 10000);\n\n          // Clean up timeout if audio loads or errors\n          const clearTimeoutHandler = () => {\n            clearTimeout(timeoutId);\n          };\n          audioElement.addEventListener('canplaythrough', clearTimeoutHandler, {\n            once: true\n          });\n          audioElement.addEventListener('error', clearTimeoutHandler, {\n            once: true\n          });\n        });\n\n        // Set source AFTER setting up all event handlers\n        audioElement.src = audioUrl;\n\n        // Start loading\n        audioElement.load();\n\n        // Wait for audio to load\n        await audioLoadPromise;\n\n        // Store the duration for progress calculation\n        audioDurationRef.current = audioElement.duration;\n        setDebug(`Audio duration: ${audioDurationRef.current.toFixed(2)} seconds`);\n\n        // Create and connect the audio source\n        const audioSource = audioContext.createMediaElementSource(audioElement);\n        audioSourceRef.current = audioSource;\n\n        // Create a destination with high-quality settings\n        const audioDestination = audioContext.createMediaStreamDestination();\n\n        // Optional: Add audio processing for better quality\n        const gainNode = audioContext.createGain();\n        gainNode.gain.value = 1.0; // Ensure full volume\n\n        // Connect the audio processing chain\n        audioSource.connect(gainNode);\n        gainNode.connect(audioDestination);\n        gainNode.connect(audioContext.destination); // Also connect to speakers\n\n        // Verify we have audio tracks\n        const audioTracks = audioDestination.stream.getAudioTracks();\n        if (audioTracks.length === 0) {\n          setDebug('Warning: No audio tracks found in audio stream');\n        } else {\n          setDebug(`Audio stream created with ${audioTracks.length} audio tracks`);\n\n          // Log audio track details\n          audioTracks.forEach((track, index) => {\n            console.log(`Audio track ${index}:`, track.label, track.enabled, track.readyState);\n          });\n        }\n\n        // Combine video and audio streams\n        const combinedStream = new MediaStream([...videoTracks, ...audioTracks]);\n\n        // Check if combined stream has tracks\n        if (combinedStream.getTracks().length === 0) {\n          throw new Error(\"Combined stream has no tracks\");\n        }\n        setDebug(`Combined stream created with ${combinedStream.getTracks().length} total tracks`);\n\n        // Try different MIME types in order of preference for high quality\n        const mimeTypes = ['video/webm;codecs=vp9,opus',\n        // VP9 is higher quality than VP8\n        'video/webm;codecs=h264,opus',\n        // H.264 is widely supported\n        'video/webm;codecs=vp8,opus',\n        // VP8 fallback\n        'video/webm' // Generic fallback\n        ];\n        let selectedMimeType = '';\n        for (const type of mimeTypes) {\n          if (MediaRecorder.isTypeSupported(type)) {\n            selectedMimeType = type;\n            setDebug(`Using MIME type: ${selectedMimeType}`);\n            break;\n          }\n        }\n        if (!selectedMimeType) {\n          setDebug('Warning: No standard MIME types supported, trying without specifying codec');\n        }\n\n        // Create MediaRecorder with high quality options\n        const options = {\n          mimeType: selectedMimeType || 'video/webm',\n          videoBitsPerSecond: HIGH_VIDEO_BITRATE,\n          audioBitsPerSecond: HIGH_AUDIO_BITRATE\n        };\n        try {\n          const mediaRecorder = new MediaRecorder(combinedStream, options);\n          mediaRecorderRef.current = mediaRecorder;\n\n          // Log MediaRecorder details\n          console.log('MediaRecorder created:', mediaRecorder.mimeType, mediaRecorder.state);\n          setDebug(`MediaRecorder created with mime type: ${mediaRecorder.mimeType}, video bitrate: ${HIGH_VIDEO_BITRATE / 1000000}Mbps`);\n\n          // Log MediaRecorder state changes\n          mediaRecorder.addEventListener('start', () => {\n            console.log('MediaRecorder started');\n            setDebug('Recording started at high quality');\n          });\n          mediaRecorder.addEventListener('error', event => {\n            console.error('MediaRecorder error:', event);\n            setDebug(`MediaRecorder error: ${event.error || 'Unknown error'}`);\n          });\n\n          // Handle data available - this is critical\n          mediaRecorder.ondataavailable = event => {\n            console.log('Data available event, size:', event.data.size);\n            if (event.data && event.data.size > 0) {\n              chunksRef.current.push(event.data);\n              setDebug(`Received data chunk: ${(event.data.size / 1024).toFixed(2)} KB, total chunks: ${chunksRef.current.length}`);\n            } else {\n              console.warn('Received empty data chunk');\n              setDebug('Warning: Received empty data chunk');\n            }\n          };\n\n          // Handle recording stop\n          mediaRecorder.onstop = () => {\n            console.log('MediaRecorder stopped, chunks:', chunksRef.current.length);\n            setDebug(`Recording stopped with ${chunksRef.current.length} chunks`);\n            if (chunksRef.current.length === 0) {\n              setDebug('Error: No data chunks were recorded');\n              alert('Error: No video data was captured during recording. This may be due to browser compatibility issues. Try using Chrome or Edge.');\n              setIsExporting(false);\n              cleanupResources();\n              return;\n            }\n\n            // Calculate total size of all chunks\n            const totalSize = chunksRef.current.reduce((size, chunk) => size + chunk.size, 0);\n            setDebug(`Total data size: ${(totalSize / 1024 / 1024).toFixed(2)} MB`);\n            if (totalSize === 0) {\n              setDebug('Error: Recorded data has zero size');\n              alert('Error: The recorded video has no data (0 bytes). Try using a different browser or visualization.');\n              setIsExporting(false);\n              cleanupResources();\n              return;\n            }\n            try {\n              // Create blob from chunks with high quality settings\n              const blob = new Blob(chunksRef.current, {\n                type: selectedMimeType || 'video/webm'\n              });\n              console.log('Created blob, size:', blob.size);\n              setDebug(`Created video blob: ${(blob.size / 1024 / 1024).toFixed(2)} MB`);\n              if (blob.size === 0) {\n                setDebug('Error: Final blob has zero size');\n                alert('Error: The final video file has no data (0 bytes). Try using a different browser.');\n                setIsExporting(false);\n                cleanupResources();\n                return;\n              }\n              const url = URL.createObjectURL(blob);\n\n              // Create filename based on audio file name with fallback\n              let fileName = \"visualization.webm\";\n              if (audioFile && audioFile.name) {\n                fileName = audioFile.name.replace(/\\.[^/.]+$/, \"\") + \"_visualization.webm\";\n              } else if (audioFile && audioFile.path) {\n                // Extract filename from path as fallback\n                const pathParts = audioFile.path.split('/');\n                const pathFileName = pathParts[pathParts.length - 1];\n                fileName = pathFileName.replace(/\\.[^/.]+$/, \"\") + \"_visualization.webm\";\n              }\n\n              // Download the file\n              const a = document.createElement('a');\n              a.href = url;\n              a.download = fileName;\n              a.click();\n\n              // Clean up\n              URL.revokeObjectURL(url);\n              setIsExporting(false);\n              setProgress(100);\n              setDebug('Export completed successfully');\n\n              // Clean up resources\n              cleanupResources();\n            } catch (blobError) {\n              console.error('Error creating blob:', blobError);\n              setDebug(`Error creating video file: ${blobError.message}`);\n              alert(`Error creating video file: ${blobError.message}`);\n              setIsExporting(false);\n              cleanupResources();\n            }\n          };\n\n          // Use smaller timeslice for higher quality\n          mediaRecorder.start(100); // Capture in 100ms chunks for more frequent data\n          setDebug('MediaRecorder started with 100ms timeslice for high quality');\n\n          // Start audio playback\n          try {\n            // Start audio playback\n            await audioElement.play();\n            setDebug('Audio playback started');\n\n            // Force activate the visualizer again after audio starts, but only if not already activated\n            if (!visualizerActivatedRef.current) {\n              forceActivateVisualizer();\n            }\n\n            // Force a render cycle to ensure the canvas is updating\n            if (canvas) {\n              const ctx = canvas.getContext('2d');\n              ctx.fillStyle = 'rgba(0,0,0,0.01)';\n              ctx.fillRect(0, 0, 1, 1); // Minimal draw to force a render cycle\n            }\n          } catch (playError) {\n            console.error('Error playing audio:', playError);\n            setDebug(`Failed to play audio: ${playError.message || 'Unknown error'}`);\n            throw new Error(`Failed to play audio: ${playError.message}`);\n          }\n\n          // Periodically request data to ensure chunks are being collected\n          dataRequestIntervalRef.current = setInterval(() => {\n            if (mediaRecorderRef.current && mediaRecorderRef.current.state === 'recording') {\n              mediaRecorderRef.current.requestData();\n\n              // Also periodically check if the canvas is still active\n              if (canvas) {\n                try {\n                  const ctx = canvas.getContext('2d');\n                  ctx.fillStyle = 'rgba(0,0,0,0.01)';\n                  ctx.fillRect(0, 0, 1, 1); // Minimal draw to keep the canvas active\n\n                  // Only try to re-activate the visualizer if we haven't received any chunks\n                  // and it's been a while since the last activation\n                  const now = Date.now();\n                  if (chunksRef.current.length === 0 && now - lastActivationTimeRef.current > MIN_ACTIVATION_INTERVAL) {\n                    setDebug('No chunks received, attempting to re-activate visualizer');\n                    forceActivateVisualizer();\n                  }\n                } catch (e) {\n                  console.error('Error keeping canvas active:', e);\n                }\n              }\n            }\n          }, 1000);\n\n          // Update progress based on audio time\n          progressIntervalRef.current = setInterval(() => {\n            if (audioDurationRef.current) {\n              const elapsed = (Date.now() - startTimeRef.current) / 1000;\n              const percentage = Math.min(Math.floor(elapsed / audioDurationRef.current * 100), 99);\n              setProgress(percentage);\n\n              // Log data chunks periodically\n              setDebug(`Progress: ${percentage}%, Chunks: ${chunksRef.current.length}, Duration: ${elapsed.toFixed(1)}s/${audioDurationRef.current.toFixed(1)}s`);\n\n              // If we've been recording for a while but have no chunks, something is wrong\n              if (elapsed > 3 && chunksRef.current.length === 0) {\n                setDebug('Warning: No data chunks received after 3 seconds');\n\n                // Try to force activate the visualizer again as a last resort,\n                // but only if it's been a while since the last activation\n                const now = Date.now();\n                if (now - lastActivationTimeRef.current > MIN_ACTIVATION_INTERVAL) {\n                  forceActivateVisualizer();\n                }\n              }\n            }\n          }, 500);\n\n          // Stop recording when audio ends\n          audioElement.onended = () => {\n            setDebug('Audio playback ended, stopping recording');\n\n            // Clear the data request interval\n            if (dataRequestIntervalRef.current) {\n              clearInterval(dataRequestIntervalRef.current);\n              dataRequestIntervalRef.current = null;\n            }\n            if (mediaRecorderRef.current && mediaRecorderRef.current.state === 'recording') {\n              // Force one last dataavailable event before stopping\n              mediaRecorderRef.current.requestData();\n\n              // Small delay to ensure the last data is captured\n              setTimeout(() => {\n                try {\n                  mediaRecorderRef.current.stop();\n                } catch (stopError) {\n                  console.error('Error stopping MediaRecorder:', stopError);\n                  setDebug(`Error stopping recording: ${stopError.message}`);\n                  setIsExporting(false);\n                  cleanupResources();\n                }\n              }, 500);\n            }\n          };\n        } catch (recorderError) {\n          console.error('Error creating MediaRecorder:', recorderError);\n          setDebug(`Failed to create MediaRecorder: ${recorderError.message}`);\n          throw new Error(`Failed to create MediaRecorder: ${recorderError.message}. Try using a different browser.`);\n        }\n      } catch (audioError) {\n        console.error('Error setting up audio:', audioError);\n        setDebug(`Audio setup error: ${audioError.message}`);\n        throw new Error(`Failed to set up audio: ${audioError.message}`);\n      }\n    } catch (error) {\n      console.error(\"Error exporting video:\", error);\n      setDebug(`Export error: ${error.message || 'Unknown error'}`);\n      alert(`Error exporting video: ${error.message}`);\n      setIsExporting(false);\n      cleanupResources();\n    }\n  };\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"video-exporter\",\n    children: isExporting ? /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"export-progress\",\n      children: [/*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"progress-bar\",\n        children: /*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"progress-fill\",\n          style: {\n            width: `${progress}%`\n          }\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 757,\n          columnNumber: 13\n        }, this)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 756,\n        columnNumber: 11\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"progress-text\",\n        children: [progress, \"% Exporting...\"]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 759,\n        columnNumber: 11\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"debug-info\",\n        children: debug\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 760,\n        columnNumber: 11\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 755,\n      columnNumber: 9\n    }, this) : /*#__PURE__*/_jsxDEV(\"button\", {\n      className: \"export-button\",\n      onClick: exportVideo,\n      disabled: !visualizerRef || !audioFile || isPlaying,\n      children: \"Export Video\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 763,\n      columnNumber: 9\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 753,\n    columnNumber: 5\n  }, this);\n};\n_s(VideoExporter, \"Orfmra39qrJ5axu/ihW0PBHbso0=\");\n_c = VideoExporter;\nexport default VideoExporter;\nvar _c;\n$RefreshReg$(_c, \"VideoExporter\");","map":{"version":3,"names":["React","useRef","useState","useEffect","jsxDEV","_jsxDEV","VideoExporter","visualizerRef","audioFile","isPlaying","_s","isExporting","setIsExporting","progress","setProgress","debug","setDebug","mediaRecorderRef","chunksRef","startTimeRef","audioDurationRef","progressIntervalRef","dataRequestIntervalRef","audioContextRef","audioSourceRef","audioElementRef","visualizerActivatedRef","lastActivationTimeRef","HIGH_VIDEO_BITRATE","HIGH_AUDIO_BITRATE","FRAME_RATE","MIN_ACTIVATION_INTERVAL","cleanupResources","current","clearInterval","disconnect","e","console","error","pause","oncanplaythrough","onerror","onended","removeAttribute","load","state","close","catch","stop","validateAudioFile","path","ensureVisualizerActive","canvas","getCanvas","ctx","getContext","imageData","getImageData","width","height","putImageData","getCanvasResolution","log","forceActivateVisualizer","now","Date","playButtons","document","querySelectorAll","playButton","button","textContent","includes","className","title","click","setTimeout","audioElements","length","audio","play","then","message","exportVideo","alert","Promise","resolve","Error","resolution","stream","captureStream","mozCaptureStream","webkitCaptureStream","videoTracks","getVideoTracks","forEach","track","index","label","enabled","readyState","applyConstraints","ideal","frameRate","AudioContext","window","webkitAudioContext","audioContext","sampleRate","timestamp","getTime","encodedPath","encodeURI","audioUrl","audioElement","Audio","crossOrigin","preload","errorDetail","target","code","audioLoadPromise","reject","duration","timeoutId","clearTimeoutHandler","clearTimeout","addEventListener","once","src","toFixed","audioSource","createMediaElementSource","audioDestination","createMediaStreamDestination","gainNode","createGain","gain","value","connect","destination","audioTracks","getAudioTracks","combinedStream","MediaStream","getTracks","mimeTypes","selectedMimeType","type","MediaRecorder","isTypeSupported","options","mimeType","videoBitsPerSecond","audioBitsPerSecond","mediaRecorder","event","ondataavailable","data","size","push","warn","onstop","totalSize","reduce","chunk","blob","Blob","url","URL","createObjectURL","fileName","name","replace","pathParts","split","pathFileName","a","createElement","href","download","revokeObjectURL","blobError","start","fillStyle","fillRect","playError","setInterval","requestData","elapsed","percentage","Math","min","floor","stopError","recorderError","audioError","children","style","_jsxFileName","lineNumber","columnNumber","onClick","disabled","_c","$RefreshReg$"],"sources":["C:/Users/fkuce/OneDrive/Desktop/Money Projects/Visualizer/frontend/src/components/VideoExporter.js"],"sourcesContent":["import React, { useRef, useState, useEffect } from 'react';\nimport './VideoExporter.css';\n\n// This is a more direct approach that will work with the specific structure of this app\nconst VideoExporter = ({ visualizerRef, audioFile, isPlaying }) => {\n  const [isExporting, setIsExporting] = useState(false);\n  const [progress, setProgress] = useState(0);\n  const [debug, setDebug] = useState('');\n  const mediaRecorderRef = useRef(null);\n  const chunksRef = useRef([]);\n  const startTimeRef = useRef(null);\n  const audioDurationRef = useRef(null);\n  const progressIntervalRef = useRef(null);\n  const dataRequestIntervalRef = useRef(null);\n  const audioContextRef = useRef(null);\n  const audioSourceRef = useRef(null);\n  const audioElementRef = useRef(null);\n  const visualizerActivatedRef = useRef(false);\n  const lastActivationTimeRef = useRef(0);\n  \n  // High quality settings\n  const HIGH_VIDEO_BITRATE = 8000000; // 8 Mbps for high quality video\n  const HIGH_AUDIO_BITRATE = 320000;  // 320 kbps for high quality audio\n  const FRAME_RATE = 60;              // 60 fps for smooth animation\n  \n  // Minimum time between visualizer activations (in ms)\n  const MIN_ACTIVATION_INTERVAL = 5000; // 5 seconds\n\n  // Clean up on unmount\n  useEffect(() => {\n    return () => {\n      cleanupResources();\n    };\n  }, []);\n\n  // Clean up resources function to centralize cleanup logic\n  const cleanupResources = () => {\n    if (progressIntervalRef.current) {\n      clearInterval(progressIntervalRef.current);\n      progressIntervalRef.current = null;\n    }\n    \n    if (dataRequestIntervalRef.current) {\n      clearInterval(dataRequestIntervalRef.current);\n      dataRequestIntervalRef.current = null;\n    }\n    \n    if (audioSourceRef.current) {\n      try {\n        audioSourceRef.current.disconnect();\n      } catch (e) {\n        console.error('Error disconnecting audio source:', e);\n      }\n      audioSourceRef.current = null;\n    }\n    \n    if (audioElementRef.current) {\n      try {\n        audioElementRef.current.pause();\n        // Remove all event listeners\n        audioElementRef.current.oncanplaythrough = null;\n        audioElementRef.current.onerror = null;\n        audioElementRef.current.onended = null;\n        // Clear source and load to release resources\n        audioElementRef.current.removeAttribute('src');\n        audioElementRef.current.load();\n      } catch (e) {\n        console.error('Error cleaning up audio element:', e);\n      }\n      audioElementRef.current = null;\n    }\n    \n    if (audioContextRef.current && audioContextRef.current.state !== 'closed') {\n      try {\n        audioContextRef.current.close().catch(e => console.error('Error closing audio context:', e));\n      } catch (e) {\n        console.error('Error closing audio context:', e);\n      }\n      audioContextRef.current = null;\n    }\n    \n    if (mediaRecorderRef.current && mediaRecorderRef.current.state === 'recording') {\n      try {\n        mediaRecorderRef.current.stop();\n      } catch (e) {\n        console.error('Error stopping media recorder:', e);\n      }\n      mediaRecorderRef.current = null;\n    }\n    \n    // Reset visualizer activation state\n    visualizerActivatedRef.current = false;\n    lastActivationTimeRef.current = 0;\n    \n    chunksRef.current = [];\n  };\n\n  // Validate that the audio file path is valid\n  const validateAudioFile = () => {\n    if (!audioFile) {\n      return false;\n    }\n    \n    if (!audioFile.path) {\n      console.error('Audio file has no path');\n      setDebug('Error: Audio file has no path');\n      return false;\n    }\n    \n    return true;\n  };\n\n  // Function to ensure the visualizer is active and rendering\n  const ensureVisualizerActive = () => {\n    if (!visualizerRef?.current) {\n      console.error('Visualizer reference not available');\n      return false;\n    }\n    \n    // Force a render cycle on the canvas to ensure it's active\n    const canvas = visualizerRef.current.getCanvas();\n    if (!canvas) {\n      console.error('Canvas not found in visualizer');\n      return false;\n    }\n    \n    try {\n      // Force a frame to be drawn on the canvas to ensure it has content\n      const ctx = canvas.getContext('2d');\n      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n      ctx.putImageData(imageData, 0, 0);\n      return true;\n    } catch (e) {\n      console.error('Error activating visualizer:', e);\n      return false;\n    }\n  };\n  \n  // Get the current canvas resolution\n  const getCanvasResolution = (canvas) => {\n    if (!canvas) return { width: 0, height: 0 };\n    \n    // Get the actual canvas dimensions\n    const width = canvas.width;\n    const height = canvas.height;\n    \n    // Log the resolution\n    console.log(`Canvas resolution: ${width}x${height}`);\n    setDebug(`Canvas resolution: ${width}x${height}`);\n    \n    return { width, height };\n  };\n  \n  // CRITICAL: This function directly manipulates the App's isPlaying state\n  // This is the most direct way to force the visualizer to activate\n  const forceActivateVisualizer = () => {\n    // Check if we've already activated the visualizer recently\n    const now = Date.now();\n    if (visualizerActivatedRef.current && \n        (now - lastActivationTimeRef.current) < MIN_ACTIVATION_INTERVAL) {\n      // Skip activation if we've already activated recently\n      return false;\n    }\n    \n    try {\n      // Find the App component's setIsPlaying function\n      // We need to look for it in the global scope or window object\n      // This is a hack, but it's the most reliable way to force the visualizer to activate\n      \n      // First, try to find any play buttons in the DOM\n      const playButtons = document.querySelectorAll('button');\n      let playButton = null;\n      \n      // Look for a button that might be the play button\n      for (const button of playButtons) {\n        if (button.textContent.includes('Play') || \n            button.className.includes('play') || \n            button.title.includes('Play')) {\n          playButton = button;\n          break;\n        }\n      }\n      \n      if (playButton) {\n        // Simulate a click on the play button to activate the visualizer\n        setDebug('Found play button, simulating click to activate visualizer');\n        playButton.click();\n        \n        // After a short delay, click it again to pause if we're exporting\n        // This ensures the visualizer is active but we don't have double audio\n        setTimeout(() => {\n          if (isExporting) {\n            playButton.click();\n            setDebug('Paused audio after activating visualizer');\n            \n            // Mark the visualizer as activated and update the last activation time\n            visualizerActivatedRef.current = true;\n            lastActivationTimeRef.current = Date.now();\n          }\n        }, 300);\n        \n        return true;\n      }\n      \n      // If we couldn't find a play button, try to find the audio element directly\n      const audioElements = document.querySelectorAll('audio');\n      if (audioElements.length > 0) {\n        setDebug('Found audio element, trying to play/pause to activate visualizer');\n        \n        // Try to play and then immediately pause the first audio element\n        const audio = audioElements[0];\n        audio.play().then(() => {\n          setTimeout(() => {\n            if (isExporting) {\n              audio.pause();\n              setDebug('Paused audio after activating visualizer');\n              \n              // Mark the visualizer as activated and update the last activation time\n              visualizerActivatedRef.current = true;\n              lastActivationTimeRef.current = Date.now();\n            }\n          }, 300);\n        }).catch(e => {\n          console.error('Error playing audio to activate visualizer:', e);\n        });\n        \n        return true;\n      }\n      \n      setDebug('Could not find play button or audio element to activate visualizer');\n      return false;\n    } catch (e) {\n      console.error('Error forcing visualizer activation:', e);\n      setDebug(`Error forcing visualizer activation: ${e.message}`);\n      return false;\n    }\n  };\n\n  const exportVideo = async () => {\n    if (!visualizerRef?.current || !audioFile) {\n      alert(\"Please upload an audio file first\");\n      return;\n    }\n    \n    // Validate audio file\n    if (!validateAudioFile()) {\n      alert(\"Invalid audio file. Please upload a valid audio file.\");\n      return;\n    }\n    \n    // Check if already exporting\n    if (isExporting) {\n      console.log('Already exporting, ignoring request');\n      return;\n    }\n\n    try {\n      // Clean up any existing resources first\n      cleanupResources();\n      \n      setIsExporting(true);\n      setProgress(0);\n      setDebug('Starting export process...');\n      startTimeRef.current = Date.now();\n      \n      // Reset visualizer activation state\n      visualizerActivatedRef.current = false;\n      lastActivationTimeRef.current = 0;\n      \n      // CRITICAL: Force activate the visualizer first\n      // This is the most important step to ensure the visualizer is active\n      setDebug('Forcing visualizer activation...');\n      forceActivateVisualizer();\n      \n      // Short delay to ensure the visualizer has time to activate\n      await new Promise(resolve => setTimeout(resolve, 500));\n\n      // Ensure visualizer is active\n      if (!ensureVisualizerActive()) {\n        throw new Error(\"Could not activate visualizer\");\n      }\n      \n      // Get the canvas element from the visualizer using the exposed method\n      const canvas = visualizerRef.current.getCanvas();\n      if (!canvas) {\n        throw new Error(\"Canvas element not found\");\n      }\n      \n      // Get and log the canvas resolution\n      const resolution = getCanvasResolution(canvas);\n      setDebug(`Canvas found, dimensions: ${resolution.width}x${resolution.height}`);\n      \n      // Ensure the canvas has a reasonable size for high-quality export\n      if (resolution.width < 720 || resolution.height < 720) {\n        setDebug(`Warning: Canvas resolution (${resolution.width}x${resolution.height}) is low. Consider using a higher resolution for better quality.`);\n      }\n\n      // Create a stream from the canvas with high frame rate\n      let stream = null;\n      \n      // Method 1: Standard captureStream with high frame rate\n      try {\n        stream = canvas.captureStream(FRAME_RATE);\n        setDebug(`Canvas stream created with ${FRAME_RATE}fps`);\n      } catch (e) {\n        console.error('Standard captureStream failed:', e);\n        setDebug('Standard captureStream failed, trying alternatives...');\n      }\n      \n      // Method 2: Mozilla captureStream\n      if (!stream) {\n        try {\n          stream = canvas.mozCaptureStream && canvas.mozCaptureStream(FRAME_RATE);\n          if (stream) {\n            setDebug(`Canvas stream created with mozCaptureStream at ${FRAME_RATE}fps`);\n          }\n        } catch (e) {\n          console.error('mozCaptureStream failed:', e);\n          setDebug('mozCaptureStream failed, trying alternatives...');\n        }\n      }\n      \n      // Method 3: WebKit captureStream\n      if (!stream) {\n        try {\n          stream = canvas.webkitCaptureStream && canvas.webkitCaptureStream(FRAME_RATE);\n          if (stream) {\n            setDebug(`Canvas stream created with webkitCaptureStream at ${FRAME_RATE}fps`);\n          }\n        } catch (e) {\n          console.error('webkitCaptureStream failed:', e);\n          setDebug('webkitCaptureStream failed');\n        }\n      }\n\n      if (!stream) {\n        throw new Error(\"Your browser doesn't support canvas streaming. Try using a different browser like Chrome.\");\n      }\n\n      // Verify we have video tracks\n      const videoTracks = stream.getVideoTracks();\n      if (videoTracks.length === 0) {\n        throw new Error(\"No video tracks found in canvas stream\");\n      }\n      setDebug(`Stream created with ${videoTracks.length} video tracks`);\n      \n      // Log video track details and try to set constraints for higher quality\n      videoTracks.forEach((track, index) => {\n        console.log(`Video track ${index}:`, track.label, track.enabled, track.readyState);\n        \n        // Try to set constraints for higher quality if supported\n        try {\n          if (track.applyConstraints) {\n            track.applyConstraints({\n              width: { ideal: resolution.width },\n              height: { ideal: resolution.height },\n              frameRate: { ideal: FRAME_RATE }\n            });\n            console.log(`Applied constraints to video track ${index}`);\n          }\n        } catch (e) {\n          console.error('Could not apply constraints to video track:', e);\n        }\n      });\n\n      // Create audio context and connect to stream - use a more reliable approach\n      try {\n        // Create a new audio context with high sample rate\n        const AudioContext = window.AudioContext || window.webkitAudioContext;\n        const audioContext = new AudioContext({ sampleRate: 48000 });\n        audioContextRef.current = audioContext;\n        \n        // Construct the audio URL with proper encoding\n        const timestamp = new Date().getTime();\n        // Ensure the path is properly encoded\n        const encodedPath = encodeURI(audioFile.path);\n        const audioUrl = `http://localhost:5001${encodedPath}?t=${timestamp}`;\n        \n        console.log('Audio URL:', audioUrl);\n        setDebug(`Using audio URL: ${audioUrl}`);\n        \n        // Create a new audio element for playback during recording\n        const audioElement = new Audio();\n        audioElement.crossOrigin = \"anonymous\";\n        audioElement.preload = \"auto\";\n        audioElementRef.current = audioElement;\n        \n        // Set up error handler before setting source\n        audioElement.onerror = (e) => {\n          const errorDetail = e.target.error \n            ? `${e.target.error.message || ''} (code: ${e.target.error.code})` \n            : 'Unknown error';\n          console.error('Audio error:', e.target.error);\n          setDebug(`Audio error: ${errorDetail}`);\n          throw new Error(`Audio error: ${errorDetail}`);\n        };\n        \n        // Wait for audio to be loaded enough to play\n        setDebug('Loading audio...');\n        \n        // Create a promise to handle audio loading\n        const audioLoadPromise = new Promise((resolve, reject) => {\n          // Set up success handler\n          audioElement.oncanplaythrough = () => {\n            console.log('Audio loaded successfully, duration:', audioElement.duration);\n            setDebug('Audio loaded successfully');\n            resolve();\n          };\n          \n          // Set up error handler\n          audioElement.onerror = (e) => {\n            const errorDetail = e.target.error \n              ? `${e.target.error.message || ''} (code: ${e.target.error.code})` \n              : 'Unknown error';\n            console.error('Audio load error:', e.target.error);\n            setDebug(`Audio load error: ${errorDetail}`);\n            reject(new Error(`Audio load error: ${errorDetail}`));\n          };\n          \n          // Set a timeout in case the audio never loads\n          const timeoutId = setTimeout(() => {\n            audioElement.oncanplaythrough = null;\n            audioElement.onerror = null;\n            setDebug('Audio load timeout - took too long to load');\n            reject(new Error('Audio load timeout - took too long to load'));\n          }, 10000);\n          \n          // Clean up timeout if audio loads or errors\n          const clearTimeoutHandler = () => {\n            clearTimeout(timeoutId);\n          };\n          \n          audioElement.addEventListener('canplaythrough', clearTimeoutHandler, { once: true });\n          audioElement.addEventListener('error', clearTimeoutHandler, { once: true });\n        });\n        \n        // Set source AFTER setting up all event handlers\n        audioElement.src = audioUrl;\n        \n        // Start loading\n        audioElement.load();\n        \n        // Wait for audio to load\n        await audioLoadPromise;\n        \n        // Store the duration for progress calculation\n        audioDurationRef.current = audioElement.duration;\n        setDebug(`Audio duration: ${audioDurationRef.current.toFixed(2)} seconds`);\n        \n        // Create and connect the audio source\n        const audioSource = audioContext.createMediaElementSource(audioElement);\n        audioSourceRef.current = audioSource;\n        \n        // Create a destination with high-quality settings\n        const audioDestination = audioContext.createMediaStreamDestination();\n        \n        // Optional: Add audio processing for better quality\n        const gainNode = audioContext.createGain();\n        gainNode.gain.value = 1.0; // Ensure full volume\n        \n        // Connect the audio processing chain\n        audioSource.connect(gainNode);\n        gainNode.connect(audioDestination);\n        gainNode.connect(audioContext.destination); // Also connect to speakers\n\n        // Verify we have audio tracks\n        const audioTracks = audioDestination.stream.getAudioTracks();\n        if (audioTracks.length === 0) {\n          setDebug('Warning: No audio tracks found in audio stream');\n        } else {\n          setDebug(`Audio stream created with ${audioTracks.length} audio tracks`);\n          \n          // Log audio track details\n          audioTracks.forEach((track, index) => {\n            console.log(`Audio track ${index}:`, track.label, track.enabled, track.readyState);\n          });\n        }\n\n        // Combine video and audio streams\n        const combinedStream = new MediaStream([\n          ...videoTracks,\n          ...audioTracks\n        ]);\n\n        // Check if combined stream has tracks\n        if (combinedStream.getTracks().length === 0) {\n          throw new Error(\"Combined stream has no tracks\");\n        }\n        setDebug(`Combined stream created with ${combinedStream.getTracks().length} total tracks`);\n\n        // Try different MIME types in order of preference for high quality\n        const mimeTypes = [\n          'video/webm;codecs=vp9,opus', // VP9 is higher quality than VP8\n          'video/webm;codecs=h264,opus', // H.264 is widely supported\n          'video/webm;codecs=vp8,opus', // VP8 fallback\n          'video/webm' // Generic fallback\n        ];\n        \n        let selectedMimeType = '';\n        for (const type of mimeTypes) {\n          if (MediaRecorder.isTypeSupported(type)) {\n            selectedMimeType = type;\n            setDebug(`Using MIME type: ${selectedMimeType}`);\n            break;\n          }\n        }\n        \n        if (!selectedMimeType) {\n          setDebug('Warning: No standard MIME types supported, trying without specifying codec');\n        }\n        \n        // Create MediaRecorder with high quality options\n        const options = {\n          mimeType: selectedMimeType || 'video/webm',\n          videoBitsPerSecond: HIGH_VIDEO_BITRATE,\n          audioBitsPerSecond: HIGH_AUDIO_BITRATE\n        };\n          \n        try {\n          const mediaRecorder = new MediaRecorder(combinedStream, options);\n          mediaRecorderRef.current = mediaRecorder;\n          \n          // Log MediaRecorder details\n          console.log('MediaRecorder created:', mediaRecorder.mimeType, mediaRecorder.state);\n          setDebug(`MediaRecorder created with mime type: ${mediaRecorder.mimeType}, video bitrate: ${HIGH_VIDEO_BITRATE/1000000}Mbps`);\n          \n          // Log MediaRecorder state changes\n          mediaRecorder.addEventListener('start', () => {\n            console.log('MediaRecorder started');\n            setDebug('Recording started at high quality');\n          });\n\n          mediaRecorder.addEventListener('error', (event) => {\n            console.error('MediaRecorder error:', event);\n            setDebug(`MediaRecorder error: ${event.error || 'Unknown error'}`);\n          });\n\n          // Handle data available - this is critical\n          mediaRecorder.ondataavailable = (event) => {\n            console.log('Data available event, size:', event.data.size);\n            if (event.data && event.data.size > 0) {\n              chunksRef.current.push(event.data);\n              setDebug(`Received data chunk: ${(event.data.size / 1024).toFixed(2)} KB, total chunks: ${chunksRef.current.length}`);\n            } else {\n              console.warn('Received empty data chunk');\n              setDebug('Warning: Received empty data chunk');\n            }\n          };\n\n          // Handle recording stop\n          mediaRecorder.onstop = () => {\n            console.log('MediaRecorder stopped, chunks:', chunksRef.current.length);\n            setDebug(`Recording stopped with ${chunksRef.current.length} chunks`);\n            \n            if (chunksRef.current.length === 0) {\n              setDebug('Error: No data chunks were recorded');\n              alert('Error: No video data was captured during recording. This may be due to browser compatibility issues. Try using Chrome or Edge.');\n              setIsExporting(false);\n              cleanupResources();\n              return;\n            }\n            \n            // Calculate total size of all chunks\n            const totalSize = chunksRef.current.reduce((size, chunk) => size + chunk.size, 0);\n            setDebug(`Total data size: ${(totalSize / 1024 / 1024).toFixed(2)} MB`);\n            \n            if (totalSize === 0) {\n              setDebug('Error: Recorded data has zero size');\n              alert('Error: The recorded video has no data (0 bytes). Try using a different browser or visualization.');\n              setIsExporting(false);\n              cleanupResources();\n              return;\n            }\n\n            try {\n              // Create blob from chunks with high quality settings\n              const blob = new Blob(chunksRef.current, { type: selectedMimeType || 'video/webm' });\n              console.log('Created blob, size:', blob.size);\n              setDebug(`Created video blob: ${(blob.size / 1024 / 1024).toFixed(2)} MB`);\n              \n              if (blob.size === 0) {\n                setDebug('Error: Final blob has zero size');\n                alert('Error: The final video file has no data (0 bytes). Try using a different browser.');\n                setIsExporting(false);\n                cleanupResources();\n                return;\n              }\n              \n              const url = URL.createObjectURL(blob);\n              \n              // Create filename based on audio file name with fallback\n              let fileName = \"visualization.webm\";\n              if (audioFile && audioFile.name) {\n                fileName = audioFile.name.replace(/\\.[^/.]+$/, \"\") + \"_visualization.webm\";\n              } else if (audioFile && audioFile.path) {\n                // Extract filename from path as fallback\n                const pathParts = audioFile.path.split('/');\n                const pathFileName = pathParts[pathParts.length - 1];\n                fileName = pathFileName.replace(/\\.[^/.]+$/, \"\") + \"_visualization.webm\";\n              }\n              \n              // Download the file\n              const a = document.createElement('a');\n              a.href = url;\n              a.download = fileName;\n              a.click();\n              \n              // Clean up\n              URL.revokeObjectURL(url);\n              setIsExporting(false);\n              setProgress(100);\n              setDebug('Export completed successfully');\n              \n              // Clean up resources\n              cleanupResources();\n            } catch (blobError) {\n              console.error('Error creating blob:', blobError);\n              setDebug(`Error creating video file: ${blobError.message}`);\n              alert(`Error creating video file: ${blobError.message}`);\n              setIsExporting(false);\n              cleanupResources();\n            }\n          };\n\n          // Use smaller timeslice for higher quality\n          mediaRecorder.start(100); // Capture in 100ms chunks for more frequent data\n          setDebug('MediaRecorder started with 100ms timeslice for high quality');\n\n          // Start audio playback\n          try {\n            // Start audio playback\n            await audioElement.play();\n            setDebug('Audio playback started');\n            \n            // Force activate the visualizer again after audio starts, but only if not already activated\n            if (!visualizerActivatedRef.current) {\n              forceActivateVisualizer();\n            }\n            \n            // Force a render cycle to ensure the canvas is updating\n            if (canvas) {\n              const ctx = canvas.getContext('2d');\n              ctx.fillStyle = 'rgba(0,0,0,0.01)';\n              ctx.fillRect(0, 0, 1, 1); // Minimal draw to force a render cycle\n            }\n            \n          } catch (playError) {\n            console.error('Error playing audio:', playError);\n            setDebug(`Failed to play audio: ${playError.message || 'Unknown error'}`);\n            throw new Error(`Failed to play audio: ${playError.message}`);\n          }\n\n          // Periodically request data to ensure chunks are being collected\n          dataRequestIntervalRef.current = setInterval(() => {\n            if (mediaRecorderRef.current && mediaRecorderRef.current.state === 'recording') {\n              mediaRecorderRef.current.requestData();\n              \n              // Also periodically check if the canvas is still active\n              if (canvas) {\n                try {\n                  const ctx = canvas.getContext('2d');\n                  ctx.fillStyle = 'rgba(0,0,0,0.01)';\n                  ctx.fillRect(0, 0, 1, 1); // Minimal draw to keep the canvas active\n                  \n                  // Only try to re-activate the visualizer if we haven't received any chunks\n                  // and it's been a while since the last activation\n                  const now = Date.now();\n                  if (chunksRef.current.length === 0 && \n                      (now - lastActivationTimeRef.current) > MIN_ACTIVATION_INTERVAL) {\n                    setDebug('No chunks received, attempting to re-activate visualizer');\n                    forceActivateVisualizer();\n                  }\n                } catch (e) {\n                  console.error('Error keeping canvas active:', e);\n                }\n              }\n            }\n          }, 1000);\n\n          // Update progress based on audio time\n          progressIntervalRef.current = setInterval(() => {\n            if (audioDurationRef.current) {\n              const elapsed = (Date.now() - startTimeRef.current) / 1000;\n              const percentage = Math.min(Math.floor((elapsed / audioDurationRef.current) * 100), 99);\n              setProgress(percentage);\n              \n              // Log data chunks periodically\n              setDebug(`Progress: ${percentage}%, Chunks: ${chunksRef.current.length}, Duration: ${elapsed.toFixed(1)}s/${audioDurationRef.current.toFixed(1)}s`);\n              \n              // If we've been recording for a while but have no chunks, something is wrong\n              if (elapsed > 3 && chunksRef.current.length === 0) {\n                setDebug('Warning: No data chunks received after 3 seconds');\n                \n                // Try to force activate the visualizer again as a last resort,\n                // but only if it's been a while since the last activation\n                const now = Date.now();\n                if ((now - lastActivationTimeRef.current) > MIN_ACTIVATION_INTERVAL) {\n                  forceActivateVisualizer();\n                }\n              }\n            }\n          }, 500);\n\n          // Stop recording when audio ends\n          audioElement.onended = () => {\n            setDebug('Audio playback ended, stopping recording');\n            \n            // Clear the data request interval\n            if (dataRequestIntervalRef.current) {\n              clearInterval(dataRequestIntervalRef.current);\n              dataRequestIntervalRef.current = null;\n            }\n            \n            if (mediaRecorderRef.current && mediaRecorderRef.current.state === 'recording') {\n              // Force one last dataavailable event before stopping\n              mediaRecorderRef.current.requestData();\n              \n              // Small delay to ensure the last data is captured\n              setTimeout(() => {\n                try {\n                  mediaRecorderRef.current.stop();\n                } catch (stopError) {\n                  console.error('Error stopping MediaRecorder:', stopError);\n                  setDebug(`Error stopping recording: ${stopError.message}`);\n                  setIsExporting(false);\n                  cleanupResources();\n                }\n              }, 500);\n            }\n          };\n          \n        } catch (recorderError) {\n          console.error('Error creating MediaRecorder:', recorderError);\n          setDebug(`Failed to create MediaRecorder: ${recorderError.message}`);\n          throw new Error(`Failed to create MediaRecorder: ${recorderError.message}. Try using a different browser.`);\n        }\n      } catch (audioError) {\n        console.error('Error setting up audio:', audioError);\n        setDebug(`Audio setup error: ${audioError.message}`);\n        throw new Error(`Failed to set up audio: ${audioError.message}`);\n      }\n\n    } catch (error) {\n      console.error(\"Error exporting video:\", error);\n      setDebug(`Export error: ${error.message || 'Unknown error'}`);\n      alert(`Error exporting video: ${error.message}`);\n      setIsExporting(false);\n      cleanupResources();\n    }\n  };\n\n  return (\n    <div className=\"video-exporter\">\n      {isExporting ? (\n        <div className=\"export-progress\">\n          <div className=\"progress-bar\">\n            <div className=\"progress-fill\" style={{ width: `${progress}%` }}></div>\n          </div>\n          <div className=\"progress-text\">{progress}% Exporting...</div>\n          <div className=\"debug-info\">{debug}</div>\n        </div>\n      ) : (\n        <button\n          className=\"export-button\"\n          onClick={exportVideo}\n          disabled={!visualizerRef || !audioFile || isPlaying}\n        >\n          Export Video\n        </button>\n      )}\n    </div>\n  );\n};\n\nexport default VideoExporter; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}