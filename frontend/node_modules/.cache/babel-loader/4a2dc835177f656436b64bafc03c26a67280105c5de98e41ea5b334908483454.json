{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\fkuce\\\\OneDrive\\\\Desktop\\\\Money Projects\\\\Visualizer\\\\frontend\\\\src\\\\components\\\\VideoExporter.js\",\n  _s = $RefreshSig$();\nimport React, { useRef, useState, useEffect } from 'react';\nimport './VideoExporter.css';\n\n// Import RESOLUTIONS from Visualizer\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst RESOLUTIONS = {\n  '4K': {\n    width: 3840,\n    height: 2160,\n    className: 'aspect-ratio-4k'\n  },\n  '1080p': {\n    width: 1920,\n    height: 1080,\n    className: 'aspect-ratio-1080p'\n  },\n  '720p': {\n    width: 1280,\n    height: 720,\n    className: 'aspect-ratio-720p'\n  },\n  'Square': {\n    width: 720,\n    height: 720,\n    className: 'aspect-ratio-square'\n  },\n  'Vertical': {\n    width: 1080,\n    height: 1920,\n    className: 'aspect-ratio-vertical'\n  }\n};\nconst VideoExporter = ({\n  visualizerRef,\n  audioFile,\n  isPlaying,\n  audioRef\n}) => {\n  _s();\n  // Add debug logging for audioFile prop\n  useEffect(() => {\n    console.log('VideoExporter: audioFile prop changed:', audioFile);\n  }, [audioFile]);\n  const [isExporting, setIsExporting] = useState(false);\n  const [progress, setProgress] = useState(0);\n  const [error, setError] = useState(null);\n  const mediaRecorderRef = useRef(null);\n  const chunksRef = useRef([]);\n  const startTimeRef = useRef(null);\n  const audioDestinationRef = useRef(null);\n  const streamRef = useRef(null);\n  const exportFileNameRef = useRef(null);\n\n  // Cleanup function to ensure all resources are properly released\n  const cleanup = () => {\n    var _mediaRecorderRef$cur;\n    if (((_mediaRecorderRef$cur = mediaRecorderRef.current) === null || _mediaRecorderRef$cur === void 0 ? void 0 : _mediaRecorderRef$cur.state) === 'recording') {\n      mediaRecorderRef.current.stop();\n      mediaRecorderRef.current = null;\n    }\n    if (streamRef.current) {\n      streamRef.current.getTracks().forEach(track => track.stop());\n      streamRef.current = null;\n    }\n    if (audioDestinationRef.current) {\n      audioDestinationRef.current.disconnect();\n      audioDestinationRef.current = null;\n    }\n    chunksRef.current = [];\n  };\n\n  // Cleanup on unmount\n  useEffect(() => {\n    return cleanup;\n  }, []);\n  const ensureAudioReady = async audioElement => {\n    return new Promise((resolve, reject) => {\n      if (audioElement.readyState >= 2) {\n        console.log('Audio already ready');\n        resolve();\n        return;\n      }\n      const timeout = setTimeout(() => {\n        reject(new Error('Audio loading timeout'));\n      }, 5000); // 5 second timeout\n\n      const loadHandler = () => {\n        console.log('Audio loaded successfully');\n        clearTimeout(timeout);\n        resolve();\n      };\n      const errorHandler = error => {\n        console.error('Audio load error:', error);\n        clearTimeout(timeout);\n        reject(error);\n      };\n      audioElement.addEventListener('canplaythrough', loadHandler, {\n        once: true\n      });\n      audioElement.addEventListener('error', errorHandler, {\n        once: true\n      });\n\n      // Force load if not already loading\n      if (audioElement.readyState === 0) {\n        audioElement.load();\n      }\n    });\n  };\n  const exportVideo = async () => {\n    // Add debug logging at the start of export\n    console.log('Starting export with audioFile:', audioFile);\n    console.log('Visualizer ref:', visualizerRef === null || visualizerRef === void 0 ? void 0 : visualizerRef.current);\n    console.log('Audio ref:', audioRef === null || audioRef === void 0 ? void 0 : audioRef.current);\n\n    // Add more robust checks for audioFile\n    if (!(visualizerRef !== null && visualizerRef !== void 0 && visualizerRef.current)) {\n      setError('Visualizer not initialized');\n      return;\n    }\n    if (!audioFile) {\n      console.error('No audio file provided');\n      setError('Please upload a valid audio file');\n      return;\n    }\n    if (!audioFile.filename) {\n      console.error('Audio file missing filename property:', audioFile);\n      setError('Invalid audio file format');\n      return;\n    }\n    if (isExporting) {\n      setError('Export already in progress');\n      return;\n    }\n    try {\n      cleanup();\n      setIsExporting(true);\n      setProgress(0);\n      setError(null);\n      startTimeRef.current = Date.now();\n\n      // Store the filename at the start with additional safety check\n      const baseFileName = audioFile.filename || 'export';\n      exportFileNameRef.current = baseFileName.replace(/\\.[^/.]+$/, '') + '_visualization.webm';\n\n      // Get the canvas and its current resolution\n      const canvas = visualizerRef.current.getCanvas();\n      if (!canvas) {\n        throw new Error('Canvas not found');\n      }\n\n      // Get the current resolution from the visualizer\n      const resolution = visualizerRef.current.getCurrentResolution();\n      const {\n        width,\n        height\n      } = RESOLUTIONS[resolution];\n\n      // Set canvas to full resolution for export\n      const originalWidth = canvas.width;\n      const originalHeight = canvas.height;\n      canvas.width = width;\n      canvas.height = height;\n\n      // Get audio element from ref\n      const audioElement = audioRef.current;\n      if (!audioElement) {\n        throw new Error('Audio element not found. Please ensure audio is loaded and playing.');\n      }\n\n      // Ensure audio is ready\n      console.log('Audio element found, ensuring it\\'s ready...');\n      await ensureAudioReady(audioElement);\n      console.log('Audio is ready for export');\n\n      // Get the existing audio context and source from the visualizer\n      const audioContext = visualizerRef.current.getAudioContext();\n      const audioSource = visualizerRef.current.getAudioSource();\n      if (!audioContext || !audioSource) {\n        throw new Error('Audio context or source not found in visualizer');\n      }\n\n      // Create a new destination for recording\n      const audioDestination = audioContext.createMediaStreamDestination();\n      audioDestinationRef.current = audioDestination;\n\n      // Connect the existing source to our new destination\n      audioSource.connect(audioDestination);\n\n      // Setup canvas stream\n      const canvasStream = canvas.captureStream(60); // 60 FPS for highest quality\n      streamRef.current = canvasStream;\n\n      // Combine video and audio streams\n      const combinedStream = new MediaStream([...canvasStream.getVideoTracks(), ...audioDestination.stream.getAudioTracks()]);\n\n      // Setup MediaRecorder with highest quality settings\n      const mediaRecorder = new MediaRecorder(combinedStream, {\n        mimeType: 'video/webm;codecs=vp9,opus',\n        videoBitsPerSecond: 8000000,\n        // 8 Mbps\n        audioBitsPerSecond: 320000 // 320 kbps\n      });\n      mediaRecorderRef.current = mediaRecorder;\n\n      // Handle data collection\n      mediaRecorder.ondataavailable = event => {\n        if (event.data && event.data.size > 0) {\n          chunksRef.current.push(event.data);\n        }\n      };\n\n      // Setup recording completion handler\n      mediaRecorder.onstop = () => {\n        if (audioElement) {\n          audioElement.removeEventListener('ended', handleAudioEnd);\n          audioElement.pause();\n          audioElement.currentTime = 0;\n        }\n        const blob = new Blob(chunksRef.current, {\n          type: 'video/webm'\n        });\n        const url = URL.createObjectURL(blob);\n\n        // Use the stored filename\n        const a = document.createElement('a');\n        a.href = url;\n        a.download = exportFileNameRef.current;\n        a.click();\n\n        // Cleanup\n        URL.revokeObjectURL(url);\n        setIsExporting(false);\n        setProgress(100);\n\n        // Restore original canvas size\n        if (canvas) {\n          canvas.width = originalWidth;\n          canvas.height = originalHeight;\n        }\n        cleanup();\n      };\n\n      // Update progress\n      const progressInterval = setInterval(() => {\n        if (audioElement.duration) {\n          const elapsed = (Date.now() - startTimeRef.current) / 1000;\n          const percentage = Math.min(Math.floor(elapsed / audioElement.duration * 100), 100);\n          setProgress(percentage);\n\n          // Stop recording when we reach the end of the audio\n          if (elapsed >= audioElement.duration) {\n            var _mediaRecorderRef$cur2;\n            clearInterval(progressInterval);\n            if (((_mediaRecorderRef$cur2 = mediaRecorderRef.current) === null || _mediaRecorderRef$cur2 === void 0 ? void 0 : _mediaRecorderRef$cur2.state) === 'recording') {\n              mediaRecorderRef.current.stop();\n            }\n          }\n        }\n      }, 100);\n\n      // Handle audio end\n      const handleAudioEnd = () => {\n        var _mediaRecorderRef$cur3;\n        clearInterval(progressInterval);\n        if (((_mediaRecorderRef$cur3 = mediaRecorderRef.current) === null || _mediaRecorderRef$cur3 === void 0 ? void 0 : _mediaRecorderRef$cur3.state) === 'recording') {\n          mediaRecorderRef.current.stop();\n        }\n      };\n\n      // Add event listener for audio end\n      audioElement.addEventListener('ended', handleAudioEnd);\n\n      // Start recording\n      mediaRecorder.start(1000);\n\n      // Start playback\n      audioElement.currentTime = 0;\n      await audioElement.play();\n    } catch (error) {\n      console.error('Export error:', error);\n      setError(error.message);\n      setIsExporting(false);\n      cleanup();\n    }\n  };\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"video-exporter\",\n    children: [isExporting ? /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"export-progress\",\n      children: [/*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"progress-bar\",\n        children: /*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"progress-fill\",\n          style: {\n            width: `${progress}%`\n          }\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 276,\n          columnNumber: 13\n        }, this)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 275,\n        columnNumber: 11\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"progress-text\",\n        children: [progress, \"% Exporting...\"]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 278,\n        columnNumber: 11\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 274,\n      columnNumber: 9\n    }, this) : /*#__PURE__*/_jsxDEV(\"button\", {\n      className: \"export-button\",\n      onClick: exportVideo,\n      disabled: !visualizerRef || !audioFile || isPlaying,\n      title: !audioFile ? 'Please upload an audio file first' : '',\n      children: \"Export Video\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 281,\n      columnNumber: 9\n    }, this), error && /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"error-message\",\n      children: error\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 290,\n      columnNumber: 17\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 272,\n    columnNumber: 5\n  }, this);\n};\n_s(VideoExporter, \"DWoAQVV6VcJ5kUlbvcJrTtEXnTM=\");\n_c = VideoExporter;\nexport default VideoExporter;\nvar _c;\n$RefreshReg$(_c, \"VideoExporter\");","map":{"version":3,"names":["React","useRef","useState","useEffect","jsxDEV","_jsxDEV","RESOLUTIONS","width","height","className","VideoExporter","visualizerRef","audioFile","isPlaying","audioRef","_s","console","log","isExporting","setIsExporting","progress","setProgress","error","setError","mediaRecorderRef","chunksRef","startTimeRef","audioDestinationRef","streamRef","exportFileNameRef","cleanup","_mediaRecorderRef$cur","current","state","stop","getTracks","forEach","track","disconnect","ensureAudioReady","audioElement","Promise","resolve","reject","readyState","timeout","setTimeout","Error","loadHandler","clearTimeout","errorHandler","addEventListener","once","load","exportVideo","filename","Date","now","baseFileName","replace","canvas","getCanvas","resolution","getCurrentResolution","originalWidth","originalHeight","audioContext","getAudioContext","audioSource","getAudioSource","audioDestination","createMediaStreamDestination","connect","canvasStream","captureStream","combinedStream","MediaStream","getVideoTracks","stream","getAudioTracks","mediaRecorder","MediaRecorder","mimeType","videoBitsPerSecond","audioBitsPerSecond","ondataavailable","event","data","size","push","onstop","removeEventListener","handleAudioEnd","pause","currentTime","blob","Blob","type","url","URL","createObjectURL","a","document","createElement","href","download","click","revokeObjectURL","progressInterval","setInterval","duration","elapsed","percentage","Math","min","floor","_mediaRecorderRef$cur2","clearInterval","_mediaRecorderRef$cur3","start","play","message","children","style","fileName","_jsxFileName","lineNumber","columnNumber","onClick","disabled","title","_c","$RefreshReg$"],"sources":["C:/Users/fkuce/OneDrive/Desktop/Money Projects/Visualizer/frontend/src/components/VideoExporter.js"],"sourcesContent":["import React, { useRef, useState, useEffect } from 'react';\r\nimport './VideoExporter.css';\r\n\r\n// Import RESOLUTIONS from Visualizer\r\nconst RESOLUTIONS = {\r\n  '4K': { width: 3840, height: 2160, className: 'aspect-ratio-4k' },\r\n  '1080p': { width: 1920, height: 1080, className: 'aspect-ratio-1080p' },\r\n  '720p': { width: 1280, height: 720, className: 'aspect-ratio-720p' },\r\n  'Square': { width: 720, height: 720, className: 'aspect-ratio-square' },\r\n  'Vertical': { width: 1080, height: 1920, className: 'aspect-ratio-vertical' }\r\n};\r\n\r\nconst VideoExporter = ({ visualizerRef, audioFile, isPlaying, audioRef }) => {\r\n  // Add debug logging for audioFile prop\r\n  useEffect(() => {\r\n    console.log('VideoExporter: audioFile prop changed:', audioFile);\r\n  }, [audioFile]);\r\n\r\n  const [isExporting, setIsExporting] = useState(false);\r\n  const [progress, setProgress] = useState(0);\r\n  const [error, setError] = useState(null);\r\n  \r\n  const mediaRecorderRef = useRef(null);\r\n  const chunksRef = useRef([]);\r\n  const startTimeRef = useRef(null);\r\n  const audioDestinationRef = useRef(null);\r\n  const streamRef = useRef(null);\r\n  const exportFileNameRef = useRef(null);\r\n\r\n  // Cleanup function to ensure all resources are properly released\r\n  const cleanup = () => {\r\n    if (mediaRecorderRef.current?.state === 'recording') {\r\n      mediaRecorderRef.current.stop();\r\n      mediaRecorderRef.current = null;\r\n    }\r\n    \r\n    if (streamRef.current) {\r\n      streamRef.current.getTracks().forEach(track => track.stop());\r\n      streamRef.current = null;\r\n    }\r\n    \r\n    if (audioDestinationRef.current) {\r\n      audioDestinationRef.current.disconnect();\r\n      audioDestinationRef.current = null;\r\n    }\r\n    \r\n    chunksRef.current = [];\r\n  };\r\n\r\n  // Cleanup on unmount\r\n  useEffect(() => {\r\n    return cleanup;\r\n  }, []);\r\n\r\n  const ensureAudioReady = async (audioElement) => {\r\n    return new Promise((resolve, reject) => {\r\n      if (audioElement.readyState >= 2) {\r\n        console.log('Audio already ready');\r\n        resolve();\r\n        return;\r\n      }\r\n\r\n      const timeout = setTimeout(() => {\r\n        reject(new Error('Audio loading timeout'));\r\n      }, 5000); // 5 second timeout\r\n\r\n      const loadHandler = () => {\r\n        console.log('Audio loaded successfully');\r\n        clearTimeout(timeout);\r\n        resolve();\r\n      };\r\n\r\n      const errorHandler = (error) => {\r\n        console.error('Audio load error:', error);\r\n        clearTimeout(timeout);\r\n        reject(error);\r\n      };\r\n\r\n      audioElement.addEventListener('canplaythrough', loadHandler, { once: true });\r\n      audioElement.addEventListener('error', errorHandler, { once: true });\r\n      \r\n      // Force load if not already loading\r\n      if (audioElement.readyState === 0) {\r\n        audioElement.load();\r\n      }\r\n    });\r\n  };\r\n\r\n  const exportVideo = async () => {\r\n    // Add debug logging at the start of export\r\n    console.log('Starting export with audioFile:', audioFile);\r\n    console.log('Visualizer ref:', visualizerRef?.current);\r\n    console.log('Audio ref:', audioRef?.current);\r\n\r\n    // Add more robust checks for audioFile\r\n    if (!visualizerRef?.current) {\r\n      setError('Visualizer not initialized');\r\n      return;\r\n    }\r\n\r\n    if (!audioFile) {\r\n      console.error('No audio file provided');\r\n      setError('Please upload a valid audio file');\r\n      return;\r\n    }\r\n\r\n    if (!audioFile.filename) {\r\n      console.error('Audio file missing filename property:', audioFile);\r\n      setError('Invalid audio file format');\r\n      return;\r\n    }\r\n\r\n    if (isExporting) {\r\n      setError('Export already in progress');\r\n      return;\r\n    }\r\n\r\n    try {\r\n      cleanup();\r\n      setIsExporting(true);\r\n      setProgress(0);\r\n      setError(null);\r\n      startTimeRef.current = Date.now();\r\n\r\n      // Store the filename at the start with additional safety check\r\n      const baseFileName = audioFile.filename || 'export';\r\n      exportFileNameRef.current = baseFileName.replace(/\\.[^/.]+$/, '') + '_visualization.webm';\r\n\r\n      // Get the canvas and its current resolution\r\n      const canvas = visualizerRef.current.getCanvas();\r\n      if (!canvas) {\r\n        throw new Error('Canvas not found');\r\n      }\r\n\r\n      // Get the current resolution from the visualizer\r\n      const resolution = visualizerRef.current.getCurrentResolution();\r\n      const { width, height } = RESOLUTIONS[resolution];\r\n\r\n      // Set canvas to full resolution for export\r\n      const originalWidth = canvas.width;\r\n      const originalHeight = canvas.height;\r\n      canvas.width = width;\r\n      canvas.height = height;\r\n\r\n      // Get audio element from ref\r\n      const audioElement = audioRef.current;\r\n      if (!audioElement) {\r\n        throw new Error('Audio element not found. Please ensure audio is loaded and playing.');\r\n      }\r\n\r\n      // Ensure audio is ready\r\n      console.log('Audio element found, ensuring it\\'s ready...');\r\n      await ensureAudioReady(audioElement);\r\n      console.log('Audio is ready for export');\r\n\r\n      // Get the existing audio context and source from the visualizer\r\n      const audioContext = visualizerRef.current.getAudioContext();\r\n      const audioSource = visualizerRef.current.getAudioSource();\r\n      \r\n      if (!audioContext || !audioSource) {\r\n        throw new Error('Audio context or source not found in visualizer');\r\n      }\r\n\r\n      // Create a new destination for recording\r\n      const audioDestination = audioContext.createMediaStreamDestination();\r\n      audioDestinationRef.current = audioDestination;\r\n\r\n      // Connect the existing source to our new destination\r\n      audioSource.connect(audioDestination);\r\n\r\n      // Setup canvas stream\r\n      const canvasStream = canvas.captureStream(60); // 60 FPS for highest quality\r\n      streamRef.current = canvasStream;\r\n\r\n      // Combine video and audio streams\r\n      const combinedStream = new MediaStream([\r\n        ...canvasStream.getVideoTracks(),\r\n        ...audioDestination.stream.getAudioTracks()\r\n      ]);\r\n\r\n      // Setup MediaRecorder with highest quality settings\r\n      const mediaRecorder = new MediaRecorder(combinedStream, {\r\n        mimeType: 'video/webm;codecs=vp9,opus',\r\n        videoBitsPerSecond: 8000000, // 8 Mbps\r\n        audioBitsPerSecond: 320000    // 320 kbps\r\n      });\r\n\r\n      mediaRecorderRef.current = mediaRecorder;\r\n\r\n      // Handle data collection\r\n      mediaRecorder.ondataavailable = (event) => {\r\n        if (event.data && event.data.size > 0) {\r\n          chunksRef.current.push(event.data);\r\n        }\r\n      };\r\n\r\n      // Setup recording completion handler\r\n      mediaRecorder.onstop = () => {\r\n        if (audioElement) {\r\n          audioElement.removeEventListener('ended', handleAudioEnd);\r\n          audioElement.pause();\r\n          audioElement.currentTime = 0;\r\n        }\r\n\r\n        const blob = new Blob(chunksRef.current, { type: 'video/webm' });\r\n        const url = URL.createObjectURL(blob);\r\n\r\n        // Use the stored filename\r\n        const a = document.createElement('a');\r\n        a.href = url;\r\n        a.download = exportFileNameRef.current;\r\n        a.click();\r\n\r\n        // Cleanup\r\n        URL.revokeObjectURL(url);\r\n        setIsExporting(false);\r\n        setProgress(100);\r\n\r\n        // Restore original canvas size\r\n        if (canvas) {\r\n          canvas.width = originalWidth;\r\n          canvas.height = originalHeight;\r\n        }\r\n\r\n        cleanup();\r\n      };\r\n\r\n      // Update progress\r\n      const progressInterval = setInterval(() => {\r\n        if (audioElement.duration) {\r\n          const elapsed = (Date.now() - startTimeRef.current) / 1000;\r\n          const percentage = Math.min(Math.floor((elapsed / audioElement.duration) * 100), 100);\r\n          setProgress(percentage);\r\n\r\n          // Stop recording when we reach the end of the audio\r\n          if (elapsed >= audioElement.duration) {\r\n            clearInterval(progressInterval);\r\n            if (mediaRecorderRef.current?.state === 'recording') {\r\n              mediaRecorderRef.current.stop();\r\n            }\r\n          }\r\n        }\r\n      }, 100);\r\n\r\n      // Handle audio end\r\n      const handleAudioEnd = () => {\r\n        clearInterval(progressInterval);\r\n        if (mediaRecorderRef.current?.state === 'recording') {\r\n          mediaRecorderRef.current.stop();\r\n        }\r\n      };\r\n\r\n      // Add event listener for audio end\r\n      audioElement.addEventListener('ended', handleAudioEnd);\r\n\r\n      // Start recording\r\n      mediaRecorder.start(1000);\r\n\r\n      // Start playback\r\n      audioElement.currentTime = 0;\r\n      await audioElement.play();\r\n\r\n    } catch (error) {\r\n      console.error('Export error:', error);\r\n      setError(error.message);\r\n      setIsExporting(false);\r\n      cleanup();\r\n    }\r\n  };\r\n\r\n  return (\r\n    <div className=\"video-exporter\">\r\n      {isExporting ? (\r\n        <div className=\"export-progress\">\r\n          <div className=\"progress-bar\">\r\n            <div className=\"progress-fill\" style={{ width: `${progress}%` }}></div>\r\n          </div>\r\n          <div className=\"progress-text\">{progress}% Exporting...</div>\r\n        </div>\r\n      ) : (\r\n        <button\r\n          className=\"export-button\"\r\n          onClick={exportVideo}\r\n          disabled={!visualizerRef || !audioFile || isPlaying}\r\n          title={!audioFile ? 'Please upload an audio file first' : ''}\r\n        >\r\n          Export Video\r\n        </button>\r\n      )}\r\n      {error && <div className=\"error-message\">{error}</div>}\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default VideoExporter; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}