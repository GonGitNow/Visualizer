{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\fkuce\\\\OneDrive\\\\Desktop\\\\Money Projects\\\\Visualizer\\\\frontend\\\\src\\\\components\\\\VideoExporter.js\",\n  _s = $RefreshSig$();\nimport React, { useRef, useState, useEffect } from 'react';\nimport './VideoExporter.css';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst VideoExporter = ({\n  visualizerRef,\n  audioFile,\n  isPlaying\n}) => {\n  _s();\n  const [isExporting, setIsExporting] = useState(false);\n  const [progress, setProgress] = useState(0);\n  const [debug, setDebug] = useState('');\n  const mediaRecorderRef = useRef(null);\n  const chunksRef = useRef([]);\n  const startTimeRef = useRef(null);\n  const audioDurationRef = useRef(null);\n  const progressIntervalRef = useRef(null);\n  const audioElementRef = useRef(null);\n  const audioContextRef = useRef(null);\n\n  // Get audio duration when audio file changes\n  useEffect(() => {\n    if (audioFile) {\n      // Use the same URL format as in Visualizer component\n      const timestamp = new Date().getTime();\n      const audioUrl = `http://localhost:5001${audioFile.path}?t=${timestamp}`;\n      const audio = new Audio(audioUrl);\n      audio.addEventListener('loadedmetadata', () => {\n        audioDurationRef.current = audio.duration;\n        console.log('Audio duration loaded:', audioDurationRef.current);\n      });\n\n      // Add error handling\n      audio.addEventListener('error', e => {\n        console.error('Error loading audio for duration calculation:', e);\n      });\n    }\n    return () => {\n      if (progressIntervalRef.current) {\n        clearInterval(progressIntervalRef.current);\n      }\n    };\n  }, [audioFile]);\n\n  // Clean up on unmount\n  useEffect(() => {\n    return () => {\n      cleanupResources();\n    };\n  }, []);\n\n  // Clean up resources function to centralize cleanup logic\n  const cleanupResources = () => {\n    if (progressIntervalRef.current) {\n      clearInterval(progressIntervalRef.current);\n      progressIntervalRef.current = null;\n    }\n    if (audioElementRef.current) {\n      audioElementRef.current.pause();\n      audioElementRef.current.src = '';\n      audioElementRef.current = null;\n    }\n    if (audioContextRef.current) {\n      audioContextRef.current.close().catch(e => console.error('Error closing audio context:', e));\n      audioContextRef.current = null;\n    }\n    if (mediaRecorderRef.current && mediaRecorderRef.current.state === 'recording') {\n      try {\n        mediaRecorderRef.current.stop();\n      } catch (e) {\n        console.error('Error stopping media recorder:', e);\n      }\n      mediaRecorderRef.current = null;\n    }\n    chunksRef.current = [];\n  };\n  const exportVideo = async () => {\n    if (!(visualizerRef !== null && visualizerRef !== void 0 && visualizerRef.current) || !audioFile) {\n      alert(\"Please upload an audio file first\");\n      return;\n    }\n    try {\n      // Clean up any existing resources first\n      cleanupResources();\n      setIsExporting(true);\n      setProgress(0);\n      setDebug('Starting export process...');\n      startTimeRef.current = Date.now();\n\n      // Get the canvas element from the visualizer using the exposed method\n      const canvas = visualizerRef.current.getCanvas();\n      if (!canvas) {\n        throw new Error(\"Canvas element not found\");\n      }\n      setDebug(`Canvas found, dimensions: ${canvas.width}x${canvas.height}`);\n\n      // Force a frame to be drawn on the canvas to ensure it has content\n      const ctx = canvas.getContext('2d');\n      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n      ctx.putImageData(imageData, 0, 0);\n\n      // Create a stream from the canvas - try multiple methods\n      let stream = null;\n\n      // Method 1: Standard captureStream\n      try {\n        stream = canvas.captureStream(30);\n        setDebug('Canvas stream created with standard captureStream');\n      } catch (e) {\n        console.error('Standard captureStream failed:', e);\n        setDebug('Standard captureStream failed, trying alternatives...');\n      }\n\n      // Method 2: Mozilla captureStream\n      if (!stream) {\n        try {\n          stream = canvas.mozCaptureStream && canvas.mozCaptureStream(30);\n          if (stream) {\n            setDebug('Canvas stream created with mozCaptureStream');\n          }\n        } catch (e) {\n          console.error('mozCaptureStream failed:', e);\n          setDebug('mozCaptureStream failed, trying alternatives...');\n        }\n      }\n\n      // Method 3: WebKit captureStream\n      if (!stream) {\n        try {\n          stream = canvas.webkitCaptureStream && canvas.webkitCaptureStream(30);\n          if (stream) {\n            setDebug('Canvas stream created with webkitCaptureStream');\n          }\n        } catch (e) {\n          console.error('webkitCaptureStream failed:', e);\n          setDebug('webkitCaptureStream failed');\n        }\n      }\n      if (!stream) {\n        throw new Error(\"Your browser doesn't support canvas streaming. Try using a different browser like Chrome.\");\n      }\n\n      // Verify we have video tracks\n      const videoTracks = stream.getVideoTracks();\n      if (videoTracks.length === 0) {\n        throw new Error(\"No video tracks found in canvas stream\");\n      }\n      setDebug(`Stream created with ${videoTracks.length} video tracks`);\n\n      // Log video track details\n      videoTracks.forEach((track, index) => {\n        console.log(`Video track ${index}:`, track.label, track.enabled, track.readyState);\n      });\n\n      // Create audio context and connect to stream - use a more reliable approach\n      try {\n        // Create a new audio context\n        const AudioContext = window.AudioContext || window.webkitAudioContext;\n        const audioContext = new AudioContext();\n        audioContextRef.current = audioContext;\n\n        // Use the same URL format as in Visualizer component\n        const timestamp = new Date().getTime();\n        const audioUrl = `http://localhost:5001${audioFile.path}?t=${timestamp}`;\n\n        // Create a new audio element\n        const audioElement = new Audio();\n        audioElement.crossOrigin = \"anonymous\"; // Important for CORS\n        audioElement.preload = \"auto\";\n        audioElementRef.current = audioElement;\n\n        // Set up error handling before setting the source\n        audioElement.onerror = e => {\n          const errorMessage = e.target.error ? e.target.error.message : 'Unknown error';\n          console.error('Audio element error:', e.target.error);\n          setDebug(`Audio error: ${errorMessage}`);\n          throw new Error(`Failed to load audio: ${errorMessage}`);\n        };\n\n        // Load the audio\n        audioElement.src = audioUrl;\n\n        // Wait for audio to be loadable before proceeding\n        await new Promise((resolve, reject) => {\n          const loadHandler = () => {\n            setDebug('Audio loaded and ready to play');\n            resolve();\n          };\n          const errorHandler = e => {\n            const errorMessage = e.target.error ? e.target.error.message : 'Unknown error';\n            setDebug(`Audio load error: ${errorMessage}`);\n            reject(new Error(`Audio load error: ${errorMessage}`));\n          };\n          audioElement.addEventListener('canplaythrough', loadHandler, {\n            once: true\n          });\n          audioElement.addEventListener('error', errorHandler, {\n            once: true\n          });\n\n          // Set a timeout in case the audio never loads\n          const timeoutId = setTimeout(() => {\n            audioElement.removeEventListener('canplaythrough', loadHandler);\n            audioElement.removeEventListener('error', errorHandler);\n            reject(new Error('Audio load timeout - took too long to load'));\n          }, 10000); // 10 second timeout\n\n          // Clean up timeout if audio loads or errors\n          audioElement.addEventListener('canplaythrough', () => clearTimeout(timeoutId), {\n            once: true\n          });\n          audioElement.addEventListener('error', () => clearTimeout(timeoutId), {\n            once: true\n          });\n          audioElement.load();\n        });\n\n        // Store the duration for progress calculation\n        audioDurationRef.current = audioElement.duration;\n        setDebug(`Audio duration: ${audioDurationRef.current.toFixed(2)} seconds`);\n\n        // Create and connect the audio source\n        const audioSource = audioContext.createMediaElementSource(audioElement);\n        const audioDestination = audioContext.createMediaStreamDestination();\n        audioSource.connect(audioDestination);\n        audioSource.connect(audioContext.destination); // Also connect to speakers\n\n        // Verify we have audio tracks\n        const audioTracks = audioDestination.stream.getAudioTracks();\n        if (audioTracks.length === 0) {\n          setDebug('Warning: No audio tracks found in audio stream');\n        } else {\n          setDebug(`Audio stream created with ${audioTracks.length} audio tracks`);\n\n          // Log audio track details\n          audioTracks.forEach((track, index) => {\n            console.log(`Audio track ${index}:`, track.label, track.enabled, track.readyState);\n          });\n        }\n\n        // Combine video and audio streams\n        const combinedStream = new MediaStream([...videoTracks, ...audioTracks]);\n\n        // Check if combined stream has tracks\n        if (combinedStream.getTracks().length === 0) {\n          throw new Error(\"Combined stream has no tracks\");\n        }\n        setDebug(`Combined stream created with ${combinedStream.getTracks().length} total tracks`);\n\n        // Try different MIME types in order of preference\n        const mimeTypes = ['video/webm;codecs=vp9,opus', 'video/webm;codecs=vp8,opus', 'video/webm;codecs=h264,opus', 'video/webm;codecs=vp9', 'video/webm;codecs=vp8', 'video/webm'];\n        let selectedMimeType = '';\n        for (const type of mimeTypes) {\n          if (MediaRecorder.isTypeSupported(type)) {\n            selectedMimeType = type;\n            setDebug(`Using MIME type: ${selectedMimeType}`);\n            break;\n          }\n        }\n        if (!selectedMimeType) {\n          setDebug('Warning: No standard MIME types supported, trying without specifying codec');\n        }\n\n        // Create MediaRecorder with appropriate options\n        const options = selectedMimeType ? {\n          mimeType: selectedMimeType,\n          videoBitsPerSecond: 2500000\n        } : {\n          videoBitsPerSecond: 2500000\n        };\n        try {\n          const mediaRecorder = new MediaRecorder(combinedStream, options);\n          mediaRecorderRef.current = mediaRecorder;\n\n          // Log MediaRecorder details\n          console.log('MediaRecorder created:', mediaRecorder.mimeType, mediaRecorder.state);\n          setDebug(`MediaRecorder created with mime type: ${mediaRecorder.mimeType}`);\n\n          // Log MediaRecorder state changes\n          mediaRecorder.addEventListener('start', () => {\n            console.log('MediaRecorder started');\n            setDebug('Recording started');\n          });\n          mediaRecorder.addEventListener('error', event => {\n            console.error('MediaRecorder error:', event);\n            setDebug(`MediaRecorder error: ${event.error || 'Unknown error'}`);\n          });\n\n          // Handle data available - this is critical\n          mediaRecorder.ondataavailable = event => {\n            console.log('Data available event, size:', event.data.size);\n            if (event.data && event.data.size > 0) {\n              chunksRef.current.push(event.data);\n              setDebug(`Received data chunk: ${(event.data.size / 1024).toFixed(2)} KB, total chunks: ${chunksRef.current.length}`);\n            } else {\n              console.warn('Received empty data chunk');\n              setDebug('Warning: Received empty data chunk');\n            }\n          };\n\n          // Handle recording stop\n          mediaRecorder.onstop = () => {\n            console.log('MediaRecorder stopped, chunks:', chunksRef.current.length);\n            setDebug(`Recording stopped with ${chunksRef.current.length} chunks`);\n            if (chunksRef.current.length === 0) {\n              setDebug('Error: No data chunks were recorded');\n              alert('Error: No video data was captured during recording. This may be due to browser compatibility issues. Try using Chrome or Edge.');\n              setIsExporting(false);\n              cleanupResources();\n              return;\n            }\n\n            // Calculate total size of all chunks\n            const totalSize = chunksRef.current.reduce((size, chunk) => size + chunk.size, 0);\n            setDebug(`Total data size: ${(totalSize / 1024).toFixed(2)} KB`);\n            if (totalSize === 0) {\n              setDebug('Error: Recorded data has zero size');\n              alert('Error: The recorded video has no data (0 bytes). Try using a different browser or visualization.');\n              setIsExporting(false);\n              cleanupResources();\n              return;\n            }\n            try {\n              // Create blob from chunks\n              const blob = new Blob(chunksRef.current, {\n                type: selectedMimeType || 'video/webm'\n              });\n              console.log('Created blob, size:', blob.size);\n              setDebug(`Created video blob: ${(blob.size / 1024).toFixed(2)} KB`);\n              if (blob.size === 0) {\n                setDebug('Error: Final blob has zero size');\n                alert('Error: The final video file has no data (0 bytes). Try using a different browser.');\n                setIsExporting(false);\n                cleanupResources();\n                return;\n              }\n              const url = URL.createObjectURL(blob);\n\n              // Create filename based on audio file name with fallback\n              let fileName = \"visualization.webm\";\n              if (audioFile && audioFile.name) {\n                fileName = audioFile.name.replace(/\\.[^/.]+$/, \"\") + \"_visualization.webm\";\n              } else if (audioFile && audioFile.path) {\n                // Extract filename from path as fallback\n                const pathParts = audioFile.path.split('/');\n                const pathFileName = pathParts[pathParts.length - 1];\n                fileName = pathFileName.replace(/\\.[^/.]+$/, \"\") + \"_visualization.webm\";\n              }\n\n              // Download the file\n              const a = document.createElement('a');\n              a.href = url;\n              a.download = fileName;\n              a.click();\n\n              // Clean up\n              URL.revokeObjectURL(url);\n              setIsExporting(false);\n              setProgress(100);\n              setDebug('Export completed successfully');\n\n              // Clean up resources\n              cleanupResources();\n            } catch (blobError) {\n              console.error('Error creating blob:', blobError);\n              setDebug(`Error creating video file: ${blobError.message}`);\n              alert(`Error creating video file: ${blobError.message}`);\n              setIsExporting(false);\n              cleanupResources();\n            }\n          };\n\n          // Force data collection more frequently\n          mediaRecorder.start(100); // Capture in 100ms chunks for more frequent data\n          setDebug('MediaRecorder started with 100ms timeslice');\n\n          // Start audio playback\n          try {\n            await audioElement.play();\n            setDebug('Audio playback started');\n          } catch (playError) {\n            console.error('Error playing audio:', playError);\n            setDebug(`Failed to play audio: ${playError.message || 'Unknown error'}`);\n            throw new Error(`Failed to play audio: ${playError.message}`);\n          }\n\n          // Periodically request data to ensure chunks are being collected\n          const dataRequestInterval = setInterval(() => {\n            if (mediaRecorderRef.current && mediaRecorderRef.current.state === 'recording') {\n              mediaRecorderRef.current.requestData();\n            }\n          }, 1000);\n\n          // Update progress based on audio time\n          progressIntervalRef.current = setInterval(() => {\n            if (audioDurationRef.current) {\n              const elapsed = (Date.now() - startTimeRef.current) / 1000;\n              const percentage = Math.min(Math.floor(elapsed / audioDurationRef.current * 100), 99);\n              setProgress(percentage);\n\n              // Log data chunks periodically\n              setDebug(`Progress: ${percentage}%, Chunks: ${chunksRef.current.length}, Duration: ${elapsed.toFixed(1)}s/${audioDurationRef.current.toFixed(1)}s`);\n\n              // If we've been recording for a while but have no chunks, something is wrong\n              if (elapsed > 3 && chunksRef.current.length === 0) {\n                setDebug('Warning: No data chunks received after 3 seconds');\n              }\n            }\n          }, 500);\n\n          // Stop recording when audio ends\n          audioElement.onended = () => {\n            setDebug('Audio playback ended, stopping recording');\n\n            // Clear the data request interval\n            clearInterval(dataRequestInterval);\n            if (mediaRecorderRef.current && mediaRecorderRef.current.state === 'recording') {\n              // Force one last dataavailable event before stopping\n              mediaRecorderRef.current.requestData();\n\n              // Small delay to ensure the last data is captured\n              setTimeout(() => {\n                try {\n                  mediaRecorderRef.current.stop();\n                } catch (stopError) {\n                  console.error('Error stopping MediaRecorder:', stopError);\n                  setDebug(`Error stopping recording: ${stopError.message}`);\n                  setIsExporting(false);\n                  cleanupResources();\n                }\n                audioElement.onended = null;\n              }, 500);\n            }\n          };\n        } catch (recorderError) {\n          console.error('Error creating MediaRecorder:', recorderError);\n          setDebug(`Failed to create MediaRecorder: ${recorderError.message}`);\n          throw new Error(`Failed to create MediaRecorder: ${recorderError.message}. Try using a different browser.`);\n        }\n      } catch (audioError) {\n        console.error('Error setting up audio:', audioError);\n        setDebug(`Audio setup error: ${audioError.message}`);\n        throw new Error(`Failed to set up audio: ${audioError.message}`);\n      }\n    } catch (error) {\n      console.error(\"Error exporting video:\", error);\n      setDebug(`Export error: ${error.message || 'Unknown error'}`);\n      alert(`Error exporting video: ${error.message}`);\n      setIsExporting(false);\n      cleanupResources();\n    }\n  };\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"video-exporter\",\n    children: isExporting ? /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"export-progress\",\n      children: [/*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"progress-bar\",\n        children: /*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"progress-fill\",\n          style: {\n            width: `${progress}%`\n          }\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 475,\n          columnNumber: 13\n        }, this)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 474,\n        columnNumber: 11\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"progress-text\",\n        children: [progress, \"% Exporting...\"]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 477,\n        columnNumber: 11\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"debug-info\",\n        children: debug\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 478,\n        columnNumber: 11\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 473,\n      columnNumber: 9\n    }, this) : /*#__PURE__*/_jsxDEV(\"button\", {\n      className: \"export-button\",\n      onClick: exportVideo,\n      disabled: !visualizerRef || !audioFile || isPlaying,\n      children: \"Export Video\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 481,\n      columnNumber: 9\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 471,\n    columnNumber: 5\n  }, this);\n};\n_s(VideoExporter, \"mfC+2+gm3Yd3Le99RRs/E+xo7/Y=\");\n_c = VideoExporter;\nexport default VideoExporter;\nvar _c;\n$RefreshReg$(_c, \"VideoExporter\");","map":{"version":3,"names":["React","useRef","useState","useEffect","jsxDEV","_jsxDEV","VideoExporter","visualizerRef","audioFile","isPlaying","_s","isExporting","setIsExporting","progress","setProgress","debug","setDebug","mediaRecorderRef","chunksRef","startTimeRef","audioDurationRef","progressIntervalRef","audioElementRef","audioContextRef","timestamp","Date","getTime","audioUrl","path","audio","Audio","addEventListener","current","duration","console","log","e","error","clearInterval","cleanupResources","pause","src","close","catch","state","stop","exportVideo","alert","now","canvas","getCanvas","Error","width","height","ctx","getContext","imageData","getImageData","putImageData","stream","captureStream","mozCaptureStream","webkitCaptureStream","videoTracks","getVideoTracks","length","forEach","track","index","label","enabled","readyState","AudioContext","window","webkitAudioContext","audioContext","audioElement","crossOrigin","preload","onerror","errorMessage","target","message","Promise","resolve","reject","loadHandler","errorHandler","once","timeoutId","setTimeout","removeEventListener","clearTimeout","load","toFixed","audioSource","createMediaElementSource","audioDestination","createMediaStreamDestination","connect","destination","audioTracks","getAudioTracks","combinedStream","MediaStream","getTracks","mimeTypes","selectedMimeType","type","MediaRecorder","isTypeSupported","options","mimeType","videoBitsPerSecond","mediaRecorder","event","ondataavailable","data","size","push","warn","onstop","totalSize","reduce","chunk","blob","Blob","url","URL","createObjectURL","fileName","name","replace","pathParts","split","pathFileName","a","document","createElement","href","download","click","revokeObjectURL","blobError","start","play","playError","dataRequestInterval","setInterval","requestData","elapsed","percentage","Math","min","floor","onended","stopError","recorderError","audioError","className","children","style","_jsxFileName","lineNumber","columnNumber","onClick","disabled","_c","$RefreshReg$"],"sources":["C:/Users/fkuce/OneDrive/Desktop/Money Projects/Visualizer/frontend/src/components/VideoExporter.js"],"sourcesContent":["import React, { useRef, useState, useEffect } from 'react';\nimport './VideoExporter.css';\n\nconst VideoExporter = ({ visualizerRef, audioFile, isPlaying }) => {\n  const [isExporting, setIsExporting] = useState(false);\n  const [progress, setProgress] = useState(0);\n  const [debug, setDebug] = useState('');\n  const mediaRecorderRef = useRef(null);\n  const chunksRef = useRef([]);\n  const startTimeRef = useRef(null);\n  const audioDurationRef = useRef(null);\n  const progressIntervalRef = useRef(null);\n  const audioElementRef = useRef(null);\n  const audioContextRef = useRef(null);\n\n  // Get audio duration when audio file changes\n  useEffect(() => {\n    if (audioFile) {\n      // Use the same URL format as in Visualizer component\n      const timestamp = new Date().getTime();\n      const audioUrl = `http://localhost:5001${audioFile.path}?t=${timestamp}`;\n      const audio = new Audio(audioUrl);\n      \n      audio.addEventListener('loadedmetadata', () => {\n        audioDurationRef.current = audio.duration;\n        console.log('Audio duration loaded:', audioDurationRef.current);\n      });\n      \n      // Add error handling\n      audio.addEventListener('error', (e) => {\n        console.error('Error loading audio for duration calculation:', e);\n      });\n    }\n    return () => {\n      if (progressIntervalRef.current) {\n        clearInterval(progressIntervalRef.current);\n      }\n    };\n  }, [audioFile]);\n\n  // Clean up on unmount\n  useEffect(() => {\n    return () => {\n      cleanupResources();\n    };\n  }, []);\n\n  // Clean up resources function to centralize cleanup logic\n  const cleanupResources = () => {\n    if (progressIntervalRef.current) {\n      clearInterval(progressIntervalRef.current);\n      progressIntervalRef.current = null;\n    }\n    \n    if (audioElementRef.current) {\n      audioElementRef.current.pause();\n      audioElementRef.current.src = '';\n      audioElementRef.current = null;\n    }\n    \n    if (audioContextRef.current) {\n      audioContextRef.current.close().catch(e => console.error('Error closing audio context:', e));\n      audioContextRef.current = null;\n    }\n    \n    if (mediaRecorderRef.current && mediaRecorderRef.current.state === 'recording') {\n      try {\n        mediaRecorderRef.current.stop();\n      } catch (e) {\n        console.error('Error stopping media recorder:', e);\n      }\n      mediaRecorderRef.current = null;\n    }\n    \n    chunksRef.current = [];\n  };\n\n  const exportVideo = async () => {\n    if (!visualizerRef?.current || !audioFile) {\n      alert(\"Please upload an audio file first\");\n      return;\n    }\n\n    try {\n      // Clean up any existing resources first\n      cleanupResources();\n      \n      setIsExporting(true);\n      setProgress(0);\n      setDebug('Starting export process...');\n      startTimeRef.current = Date.now();\n\n      // Get the canvas element from the visualizer using the exposed method\n      const canvas = visualizerRef.current.getCanvas();\n      if (!canvas) {\n        throw new Error(\"Canvas element not found\");\n      }\n      setDebug(`Canvas found, dimensions: ${canvas.width}x${canvas.height}`);\n\n      // Force a frame to be drawn on the canvas to ensure it has content\n      const ctx = canvas.getContext('2d');\n      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n      ctx.putImageData(imageData, 0, 0);\n\n      // Create a stream from the canvas - try multiple methods\n      let stream = null;\n      \n      // Method 1: Standard captureStream\n      try {\n        stream = canvas.captureStream(30);\n        setDebug('Canvas stream created with standard captureStream');\n      } catch (e) {\n        console.error('Standard captureStream failed:', e);\n        setDebug('Standard captureStream failed, trying alternatives...');\n      }\n      \n      // Method 2: Mozilla captureStream\n      if (!stream) {\n        try {\n          stream = canvas.mozCaptureStream && canvas.mozCaptureStream(30);\n          if (stream) {\n            setDebug('Canvas stream created with mozCaptureStream');\n          }\n        } catch (e) {\n          console.error('mozCaptureStream failed:', e);\n          setDebug('mozCaptureStream failed, trying alternatives...');\n        }\n      }\n      \n      // Method 3: WebKit captureStream\n      if (!stream) {\n        try {\n          stream = canvas.webkitCaptureStream && canvas.webkitCaptureStream(30);\n          if (stream) {\n            setDebug('Canvas stream created with webkitCaptureStream');\n          }\n        } catch (e) {\n          console.error('webkitCaptureStream failed:', e);\n          setDebug('webkitCaptureStream failed');\n        }\n      }\n\n      if (!stream) {\n        throw new Error(\"Your browser doesn't support canvas streaming. Try using a different browser like Chrome.\");\n      }\n\n      // Verify we have video tracks\n      const videoTracks = stream.getVideoTracks();\n      if (videoTracks.length === 0) {\n        throw new Error(\"No video tracks found in canvas stream\");\n      }\n      setDebug(`Stream created with ${videoTracks.length} video tracks`);\n      \n      // Log video track details\n      videoTracks.forEach((track, index) => {\n        console.log(`Video track ${index}:`, track.label, track.enabled, track.readyState);\n      });\n\n      // Create audio context and connect to stream - use a more reliable approach\n      try {\n        // Create a new audio context\n        const AudioContext = window.AudioContext || window.webkitAudioContext;\n        const audioContext = new AudioContext();\n        audioContextRef.current = audioContext;\n        \n        // Use the same URL format as in Visualizer component\n        const timestamp = new Date().getTime();\n        const audioUrl = `http://localhost:5001${audioFile.path}?t=${timestamp}`;\n        \n        // Create a new audio element\n        const audioElement = new Audio();\n        audioElement.crossOrigin = \"anonymous\"; // Important for CORS\n        audioElement.preload = \"auto\";\n        audioElementRef.current = audioElement;\n        \n        // Set up error handling before setting the source\n        audioElement.onerror = (e) => {\n          const errorMessage = e.target.error ? e.target.error.message : 'Unknown error';\n          console.error('Audio element error:', e.target.error);\n          setDebug(`Audio error: ${errorMessage}`);\n          throw new Error(`Failed to load audio: ${errorMessage}`);\n        };\n        \n        // Load the audio\n        audioElement.src = audioUrl;\n        \n        // Wait for audio to be loadable before proceeding\n        await new Promise((resolve, reject) => {\n          const loadHandler = () => {\n            setDebug('Audio loaded and ready to play');\n            resolve();\n          };\n          \n          const errorHandler = (e) => {\n            const errorMessage = e.target.error ? e.target.error.message : 'Unknown error';\n            setDebug(`Audio load error: ${errorMessage}`);\n            reject(new Error(`Audio load error: ${errorMessage}`));\n          };\n          \n          audioElement.addEventListener('canplaythrough', loadHandler, { once: true });\n          audioElement.addEventListener('error', errorHandler, { once: true });\n          \n          // Set a timeout in case the audio never loads\n          const timeoutId = setTimeout(() => {\n            audioElement.removeEventListener('canplaythrough', loadHandler);\n            audioElement.removeEventListener('error', errorHandler);\n            reject(new Error('Audio load timeout - took too long to load'));\n          }, 10000); // 10 second timeout\n          \n          // Clean up timeout if audio loads or errors\n          audioElement.addEventListener('canplaythrough', () => clearTimeout(timeoutId), { once: true });\n          audioElement.addEventListener('error', () => clearTimeout(timeoutId), { once: true });\n          \n          audioElement.load();\n        });\n        \n        // Store the duration for progress calculation\n        audioDurationRef.current = audioElement.duration;\n        setDebug(`Audio duration: ${audioDurationRef.current.toFixed(2)} seconds`);\n        \n        // Create and connect the audio source\n        const audioSource = audioContext.createMediaElementSource(audioElement);\n        const audioDestination = audioContext.createMediaStreamDestination();\n        audioSource.connect(audioDestination);\n        audioSource.connect(audioContext.destination); // Also connect to speakers\n\n        // Verify we have audio tracks\n        const audioTracks = audioDestination.stream.getAudioTracks();\n        if (audioTracks.length === 0) {\n          setDebug('Warning: No audio tracks found in audio stream');\n        } else {\n          setDebug(`Audio stream created with ${audioTracks.length} audio tracks`);\n          \n          // Log audio track details\n          audioTracks.forEach((track, index) => {\n            console.log(`Audio track ${index}:`, track.label, track.enabled, track.readyState);\n          });\n        }\n\n        // Combine video and audio streams\n        const combinedStream = new MediaStream([\n          ...videoTracks,\n          ...audioTracks\n        ]);\n\n        // Check if combined stream has tracks\n        if (combinedStream.getTracks().length === 0) {\n          throw new Error(\"Combined stream has no tracks\");\n        }\n        setDebug(`Combined stream created with ${combinedStream.getTracks().length} total tracks`);\n\n        // Try different MIME types in order of preference\n        const mimeTypes = [\n          'video/webm;codecs=vp9,opus',\n          'video/webm;codecs=vp8,opus',\n          'video/webm;codecs=h264,opus',\n          'video/webm;codecs=vp9',\n          'video/webm;codecs=vp8',\n          'video/webm'\n        ];\n        \n        let selectedMimeType = '';\n        for (const type of mimeTypes) {\n          if (MediaRecorder.isTypeSupported(type)) {\n            selectedMimeType = type;\n            setDebug(`Using MIME type: ${selectedMimeType}`);\n            break;\n          }\n        }\n        \n        if (!selectedMimeType) {\n          setDebug('Warning: No standard MIME types supported, trying without specifying codec');\n        }\n        \n        // Create MediaRecorder with appropriate options\n        const options = selectedMimeType \n          ? { mimeType: selectedMimeType, videoBitsPerSecond: 2500000 }\n          : { videoBitsPerSecond: 2500000 };\n          \n        try {\n          const mediaRecorder = new MediaRecorder(combinedStream, options);\n          mediaRecorderRef.current = mediaRecorder;\n          \n          // Log MediaRecorder details\n          console.log('MediaRecorder created:', mediaRecorder.mimeType, mediaRecorder.state);\n          setDebug(`MediaRecorder created with mime type: ${mediaRecorder.mimeType}`);\n          \n          // Log MediaRecorder state changes\n          mediaRecorder.addEventListener('start', () => {\n            console.log('MediaRecorder started');\n            setDebug('Recording started');\n          });\n\n          mediaRecorder.addEventListener('error', (event) => {\n            console.error('MediaRecorder error:', event);\n            setDebug(`MediaRecorder error: ${event.error || 'Unknown error'}`);\n          });\n\n          // Handle data available - this is critical\n          mediaRecorder.ondataavailable = (event) => {\n            console.log('Data available event, size:', event.data.size);\n            if (event.data && event.data.size > 0) {\n              chunksRef.current.push(event.data);\n              setDebug(`Received data chunk: ${(event.data.size / 1024).toFixed(2)} KB, total chunks: ${chunksRef.current.length}`);\n            } else {\n              console.warn('Received empty data chunk');\n              setDebug('Warning: Received empty data chunk');\n            }\n          };\n\n          // Handle recording stop\n          mediaRecorder.onstop = () => {\n            console.log('MediaRecorder stopped, chunks:', chunksRef.current.length);\n            setDebug(`Recording stopped with ${chunksRef.current.length} chunks`);\n            \n            if (chunksRef.current.length === 0) {\n              setDebug('Error: No data chunks were recorded');\n              alert('Error: No video data was captured during recording. This may be due to browser compatibility issues. Try using Chrome or Edge.');\n              setIsExporting(false);\n              cleanupResources();\n              return;\n            }\n            \n            // Calculate total size of all chunks\n            const totalSize = chunksRef.current.reduce((size, chunk) => size + chunk.size, 0);\n            setDebug(`Total data size: ${(totalSize / 1024).toFixed(2)} KB`);\n            \n            if (totalSize === 0) {\n              setDebug('Error: Recorded data has zero size');\n              alert('Error: The recorded video has no data (0 bytes). Try using a different browser or visualization.');\n              setIsExporting(false);\n              cleanupResources();\n              return;\n            }\n\n            try {\n              // Create blob from chunks\n              const blob = new Blob(chunksRef.current, { type: selectedMimeType || 'video/webm' });\n              console.log('Created blob, size:', blob.size);\n              setDebug(`Created video blob: ${(blob.size / 1024).toFixed(2)} KB`);\n              \n              if (blob.size === 0) {\n                setDebug('Error: Final blob has zero size');\n                alert('Error: The final video file has no data (0 bytes). Try using a different browser.');\n                setIsExporting(false);\n                cleanupResources();\n                return;\n              }\n              \n              const url = URL.createObjectURL(blob);\n              \n              // Create filename based on audio file name with fallback\n              let fileName = \"visualization.webm\";\n              if (audioFile && audioFile.name) {\n                fileName = audioFile.name.replace(/\\.[^/.]+$/, \"\") + \"_visualization.webm\";\n              } else if (audioFile && audioFile.path) {\n                // Extract filename from path as fallback\n                const pathParts = audioFile.path.split('/');\n                const pathFileName = pathParts[pathParts.length - 1];\n                fileName = pathFileName.replace(/\\.[^/.]+$/, \"\") + \"_visualization.webm\";\n              }\n              \n              // Download the file\n              const a = document.createElement('a');\n              a.href = url;\n              a.download = fileName;\n              a.click();\n              \n              // Clean up\n              URL.revokeObjectURL(url);\n              setIsExporting(false);\n              setProgress(100);\n              setDebug('Export completed successfully');\n              \n              // Clean up resources\n              cleanupResources();\n            } catch (blobError) {\n              console.error('Error creating blob:', blobError);\n              setDebug(`Error creating video file: ${blobError.message}`);\n              alert(`Error creating video file: ${blobError.message}`);\n              setIsExporting(false);\n              cleanupResources();\n            }\n          };\n\n          // Force data collection more frequently\n          mediaRecorder.start(100); // Capture in 100ms chunks for more frequent data\n          setDebug('MediaRecorder started with 100ms timeslice');\n\n          // Start audio playback\n          try {\n            await audioElement.play();\n            setDebug('Audio playback started');\n          } catch (playError) {\n            console.error('Error playing audio:', playError);\n            setDebug(`Failed to play audio: ${playError.message || 'Unknown error'}`);\n            throw new Error(`Failed to play audio: ${playError.message}`);\n          }\n\n          // Periodically request data to ensure chunks are being collected\n          const dataRequestInterval = setInterval(() => {\n            if (mediaRecorderRef.current && mediaRecorderRef.current.state === 'recording') {\n              mediaRecorderRef.current.requestData();\n            }\n          }, 1000);\n\n          // Update progress based on audio time\n          progressIntervalRef.current = setInterval(() => {\n            if (audioDurationRef.current) {\n              const elapsed = (Date.now() - startTimeRef.current) / 1000;\n              const percentage = Math.min(Math.floor((elapsed / audioDurationRef.current) * 100), 99);\n              setProgress(percentage);\n              \n              // Log data chunks periodically\n              setDebug(`Progress: ${percentage}%, Chunks: ${chunksRef.current.length}, Duration: ${elapsed.toFixed(1)}s/${audioDurationRef.current.toFixed(1)}s`);\n              \n              // If we've been recording for a while but have no chunks, something is wrong\n              if (elapsed > 3 && chunksRef.current.length === 0) {\n                setDebug('Warning: No data chunks received after 3 seconds');\n              }\n            }\n          }, 500);\n\n          // Stop recording when audio ends\n          audioElement.onended = () => {\n            setDebug('Audio playback ended, stopping recording');\n            \n            // Clear the data request interval\n            clearInterval(dataRequestInterval);\n            \n            if (mediaRecorderRef.current && mediaRecorderRef.current.state === 'recording') {\n              // Force one last dataavailable event before stopping\n              mediaRecorderRef.current.requestData();\n              \n              // Small delay to ensure the last data is captured\n              setTimeout(() => {\n                try {\n                  mediaRecorderRef.current.stop();\n                } catch (stopError) {\n                  console.error('Error stopping MediaRecorder:', stopError);\n                  setDebug(`Error stopping recording: ${stopError.message}`);\n                  setIsExporting(false);\n                  cleanupResources();\n                }\n                audioElement.onended = null;\n              }, 500);\n            }\n          };\n          \n        } catch (recorderError) {\n          console.error('Error creating MediaRecorder:', recorderError);\n          setDebug(`Failed to create MediaRecorder: ${recorderError.message}`);\n          throw new Error(`Failed to create MediaRecorder: ${recorderError.message}. Try using a different browser.`);\n        }\n      } catch (audioError) {\n        console.error('Error setting up audio:', audioError);\n        setDebug(`Audio setup error: ${audioError.message}`);\n        throw new Error(`Failed to set up audio: ${audioError.message}`);\n      }\n\n    } catch (error) {\n      console.error(\"Error exporting video:\", error);\n      setDebug(`Export error: ${error.message || 'Unknown error'}`);\n      alert(`Error exporting video: ${error.message}`);\n      setIsExporting(false);\n      cleanupResources();\n    }\n  };\n\n  return (\n    <div className=\"video-exporter\">\n      {isExporting ? (\n        <div className=\"export-progress\">\n          <div className=\"progress-bar\">\n            <div className=\"progress-fill\" style={{ width: `${progress}%` }}></div>\n          </div>\n          <div className=\"progress-text\">{progress}% Exporting...</div>\n          <div className=\"debug-info\">{debug}</div>\n        </div>\n      ) : (\n        <button\n          className=\"export-button\"\n          onClick={exportVideo}\n          disabled={!visualizerRef || !audioFile || isPlaying}\n        >\n          Export Video\n        </button>\n      )}\n    </div>\n  );\n};\n\nexport default VideoExporter; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}