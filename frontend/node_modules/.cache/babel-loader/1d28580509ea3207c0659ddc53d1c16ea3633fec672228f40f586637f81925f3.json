{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\fkuce\\\\OneDrive\\\\Desktop\\\\Money Projects\\\\Visualizer\\\\frontend\\\\src\\\\components\\\\Visualizer.js\",\n  _s = $RefreshSig$();\nimport React, { useEffect, useRef, forwardRef, useState } from 'react';\nimport ThreeVisualizer from './ThreeVisualizer';\nimport './Visualizer.css';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst RESOLUTIONS = {\n  '4K': {\n    width: 3840,\n    height: 2160,\n    className: 'aspect-ratio-4k'\n  },\n  '1080p': {\n    width: 1920,\n    height: 1080,\n    className: 'aspect-ratio-1080p'\n  },\n  '720p': {\n    width: 1280,\n    height: 720,\n    className: 'aspect-ratio-720p'\n  },\n  'Square': {\n    width: 720,\n    height: 720,\n    className: 'aspect-ratio-square'\n  },\n  'Vertical': {\n    width: 1080,\n    height: 1920,\n    className: 'aspect-ratio-vertical'\n  }\n};\nconst Visualizer = /*#__PURE__*/_s(/*#__PURE__*/forwardRef(_c = _s(({\n  audioFile,\n  template,\n  isPlaying,\n  onAudioElementCreated,\n  parameters: initialParameters = {}\n}, ref) => {\n  _s();\n  const canvasRef = useRef(null);\n  const containerRef = useRef(null);\n  const audioContextRef = useRef(null);\n  const analyserRef = useRef(null);\n  const animationFrameRef = useRef(null);\n  const sourceRef = useRef(null);\n  const audioElementRef = useRef(null);\n  const particlesRef = useRef([]);\n  const timeRef = useRef(0); // Add timeRef to track animation time\n  const [resolution, setResolution] = useState('1080p'); // Default to 1080p\n  const [audioData, setAudioData] = useState(null);\n  const [use3D, setUse3D] = useState(false);\n  const [parameters, setParameters] = useState(initialParameters);\n\n  // Check if template is a 3D visualization\n  useEffect(() => {\n    // Define which templates should use 3D rendering\n    const threeDTemplates = ['particles3d', 'waveform3d', 'spiral3d', 'kaleidoscope3d'];\n    setUse3D(threeDTemplates.includes(template));\n  }, [template]);\n\n  // Audio initialization effect\n  useEffect(() => {\n    if (!audioFile) return;\n    let isInitialized = false;\n    const initAudio = async () => {\n      try {\n        // Initialize audio context only on first load or if it doesn't exist\n        if (!audioContextRef.current) {\n          // Create context on user interaction\n          const context = new (window.AudioContext || window.webkitAudioContext)();\n          audioContextRef.current = context;\n\n          // Create analyzer with improved settings for better reactivity\n          const analyser = context.createAnalyser();\n          analyser.fftSize = 2048; // Increased for more detailed frequency data\n          analyser.smoothingTimeConstant = 0.8; // Higher smoothing for more consistent movement\n          analyserRef.current = analyser;\n        }\n\n        // Create and set up audio element\n        const audioElement = new Audio();\n        audioElement.crossOrigin = \"anonymous\";\n        audioElement.preload = \"auto\";\n\n        // Set the audio source\n        const timestamp = new Date().getTime();\n        audioElement.src = `http://localhost:5001${audioFile.path}?t=${timestamp}`;\n\n        // Wait for audio to be loaded enough to play\n        await new Promise((resolve, reject) => {\n          const loadHandler = () => {\n            console.log('Audio loaded, duration:', audioElement.duration);\n            resolve();\n          };\n          const errorHandler = error => {\n            console.error('Audio load error:', error);\n            reject(error);\n          };\n          audioElement.addEventListener('canplaythrough', loadHandler, {\n            once: true\n          });\n          audioElement.addEventListener('error', errorHandler, {\n            once: true\n          });\n          audioElement.load();\n        });\n\n        // Only create new media source if not already connected\n        if (!isInitialized) {\n          // Ensure old source is disconnected\n          if (sourceRef.current) {\n            sourceRef.current.disconnect();\n          }\n\n          // Create and connect new media source\n          const mediaSource = audioContextRef.current.createMediaElementSource(audioElement);\n          sourceRef.current = mediaSource;\n          mediaSource.connect(analyserRef.current);\n          analyserRef.current.connect(audioContextRef.current.destination);\n          isInitialized = true;\n        }\n\n        // Set up event listeners - REMOVE timeupdate listener which causes visualization restarts\n        const onSeeking = () => {\n          console.log('Seeking:', audioElement.currentTime);\n          if (isPlaying) startVisualization();\n        };\n        audioElement.addEventListener('seeking', onSeeking);\n        audioElement.addEventListener('seeked', onSeeking);\n        // Removed timeupdate listener which was causing visualization restarts\n\n        // Store reference and notify parent\n        audioElementRef.current = audioElement;\n        onAudioElementCreated(audioElement);\n\n        // Resume audio context if suspended\n        if (audioContextRef.current.state === 'suspended') {\n          await audioContextRef.current.resume();\n        }\n        return () => {\n          console.log('Cleaning up audio element');\n          audioElement.removeEventListener('seeking', onSeeking);\n          audioElement.removeEventListener('seeked', onSeeking);\n          // Removed timeupdate listener cleanup\n          audioElement.pause();\n          audioElement.src = '';\n          onAudioElementCreated(null);\n        };\n      } catch (error) {\n        console.error('Audio initialization error:', error);\n        alert('Error loading audio. Please try again.');\n      }\n    };\n    initAudio();\n  }, [audioFile]); // Remove isPlaying from dependencies\n\n  // Separate playback control effect\n  useEffect(() => {\n    const audioElement = audioElementRef.current;\n    if (!audioElement) return;\n    const playAudio = async () => {\n      try {\n        var _audioContextRef$curr;\n        // Ensure audio context is running\n        if (((_audioContextRef$curr = audioContextRef.current) === null || _audioContextRef$curr === void 0 ? void 0 : _audioContextRef$curr.state) === 'suspended') {\n          await audioContextRef.current.resume();\n        }\n        console.log('Playing audio...');\n        await audioElement.play();\n        startVisualization();\n      } catch (error) {\n        console.error('Playback error:', error);\n        alert('Error playing audio. Please try again.');\n      }\n    };\n    if (isPlaying) {\n      playAudio();\n    } else {\n      console.log('Pausing audio...');\n      audioElement.pause();\n      cancelAnimationFrame(animationFrameRef.current);\n    }\n  }, [isPlaying]);\n\n  // Add effect to handle template changes\n  useEffect(() => {\n    if (!canvasRef.current) return;\n    const canvas = canvasRef.current;\n    const ctx = canvas.getContext('2d');\n\n    // Clear the entire canvas\n    ctx.fillStyle = 'rgb(0, 0, 0)';\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n    // Restart visualization if playing\n    if (isPlaying) {\n      startVisualization();\n    }\n  }, [template]);\n\n  // Update canvas size based on selected resolution\n  useEffect(() => {\n    if (!canvasRef.current) return;\n    const canvas = canvasRef.current;\n    const {\n      width,\n      height\n    } = RESOLUTIONS[resolution];\n\n    // Set canvas dimensions to match the selected resolution\n    canvas.width = width;\n    canvas.height = height;\n\n    // Clear canvas with new dimensions\n    const ctx = canvas.getContext('2d');\n    ctx.fillStyle = 'rgb(0, 0, 0)';\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n    // Adjust container styles based on aspect ratio\n    if (containerRef.current) {\n      if (resolution === 'Vertical') {\n        containerRef.current.style.width = 'auto';\n        containerRef.current.style.height = '80vh';\n      } else if (resolution === 'Square') {\n        containerRef.current.style.width = '720px';\n        containerRef.current.style.height = '720px';\n        containerRef.current.style.maxWidth = '720px';\n        containerRef.current.style.maxHeight = '720px';\n      } else {\n        containerRef.current.style.width = '100%';\n        containerRef.current.style.height = 'auto';\n        containerRef.current.style.maxWidth = `${width}px`;\n        containerRef.current.style.maxHeight = `${height}px`;\n      }\n    }\n\n    // Restart visualization if playing\n    if (isPlaying) {\n      startVisualization();\n    }\n\n    // Initialize particles for the new canvas size\n    if (template === 'particles') {\n      initParticles(ctx);\n    }\n  }, [resolution, isPlaying, template]);\n\n  // Function to change resolution\n  const changeResolution = newResolution => {\n    if (RESOLUTIONS[newResolution]) {\n      setResolution(newResolution);\n    }\n  };\n\n  // Expose changeResolution to parent via ref\n  React.useImperativeHandle(ref, () => ({\n    changeResolution,\n    getCurrentResolution: () => resolution,\n    updateParameters\n  }));\n  const initParticles = ctx => {\n    // Safety check - ensure context exists\n    if (!ctx || !ctx.canvas) {\n      console.error(\"Canvas context is null in initParticles\");\n      return;\n    }\n    const count = Math.floor((parameters.count || 50) / 50 * 200); // 100-400 particles based on count parameter\n    particlesRef.current = [];\n    for (let i = 0; i < count; i++) {\n      particlesRef.current.push({\n        x: Math.random() * ctx.canvas.width,\n        y: Math.random() * ctx.canvas.height,\n        size: Math.random() * ((parameters.size || 50) / 10) + 1,\n        // 1-6 size based on size parameter\n        vx: (Math.random() - 0.5) * ((parameters.speed || 50) / 25),\n        // Speed based on speed parameter\n        vy: (Math.random() - 0.5) * ((parameters.speed || 50) / 25),\n        hue: Math.random() * 360\n      });\n    }\n  };\n  const updateAndDrawParticles = (ctx, dataArray, bufferLength, cachedParameters) => {\n    // Safety check - ensure canvas reference exists\n    if (!canvasRef.current) {\n      console.error(\"Canvas reference is null in updateAndDrawParticles\");\n      return;\n    }\n\n    // Safety check - ensure particles array exists\n    if (!particlesRef.current || particlesRef.current.length === 0) {\n      console.log(\"Initializing particles in updateAndDrawParticles\");\n      initParticles(ctx);\n\n      // Double-check initialization worked\n      if (!particlesRef.current || particlesRef.current.length === 0) {\n        console.error(\"Failed to initialize particles\");\n        return;\n      }\n    }\n\n    // Apply parameters\n    const color = cachedParameters.color || '#ffffff';\n    const particleCount = Math.floor((cachedParameters.count || 50) / 100 * particlesRef.current.length);\n    const particleSize = (cachedParameters.size || 50) / 10; // Convert to 0-10 scale\n    const speed = (cachedParameters.speed || 50) / 50; // Convert to 0-2 scale\n    const reactivity = (cachedParameters.reactivity || 50) / 50; // Convert to 0-2 scale\n\n    // Clear canvas with fade effect\n    ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';\n    ctx.fillRect(0, 0, canvasRef.current.width, canvasRef.current.height);\n\n    // Update and draw particles\n    for (let i = 0; i < particleCount; i++) {\n      const particle = particlesRef.current[i];\n\n      // Apply audio reactivity\n      const dataIndex = Math.floor(i / particleCount * bufferLength);\n      const audioValue = dataArray[dataIndex] / 255.0 * reactivity;\n\n      // Update position\n      particle.x += particle.vx * speed;\n      particle.y += particle.vy * speed;\n\n      // Bounce off edges\n      if (particle.x < 0 || particle.x > canvasRef.current.width) {\n        particle.vx = -particle.vx;\n      }\n      if (particle.y < 0 || particle.y > canvasRef.current.height) {\n        particle.vy = -particle.vy;\n      }\n\n      // Draw particle\n      const size = particleSize * (1 + audioValue);\n      ctx.beginPath();\n      ctx.arc(particle.x, particle.y, size, 0, Math.PI * 2);\n      ctx.fillStyle = adjustColor(color, audioValue * 50);\n      ctx.fill();\n    }\n  };\n\n  // Helper function to adjust colors\n  const adjustColor = (hexColor, amount) => {\n    // Convert hex to RGB\n    let r = parseInt(hexColor.substring(1, 3), 16);\n    let g = parseInt(hexColor.substring(3, 5), 16);\n    let b = parseInt(hexColor.substring(5, 7), 16);\n\n    // Adjust RGB values\n    r = Math.max(0, Math.min(255, r + amount));\n    g = Math.max(0, Math.min(255, g + amount));\n    b = Math.max(0, Math.min(255, b + amount));\n\n    // Convert back to hex\n    return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;\n  };\n\n  // Start visualization\n  const startVisualization = () => {\n    if (!analyserRef.current) {\n      console.error(\"Analyzer reference is null in startVisualization\");\n      return;\n    }\n    const analyser = analyserRef.current;\n\n    // Create data arrays for audio analysis\n    const bufferLength = analyser.frequencyBinCount;\n    const dataArray = new Uint8Array(bufferLength);\n    const timeArray = new Uint8Array(bufferLength);\n\n    // Get initial data\n    analyser.getByteFrequencyData(dataArray);\n    analyser.getByteTimeDomainData(timeArray);\n\n    // Cancel any existing animation frame\n    if (animationFrameRef.current) {\n      cancelAnimationFrame(animationFrameRef.current);\n    }\n\n    // Reset animation time to ensure consistent animation speed\n    timeRef.current = 0;\n\n    // Track frame timing for consistent animation speed\n    let lastFrameTime = performance.now();\n    const targetFrameRate = 30; // Reduced to 30 FPS for smoother, slower animations\n    const frameInterval = 1000 / targetFrameRate;\n\n    // Handle 3D visualization\n    if (use3D) {\n      // For 3D, we need to continuously update the audio data\n      const update3DAudio = currentTime => {\n        animationFrameRef.current = requestAnimationFrame(update3DAudio);\n\n        // Calculate delta time for smooth animation regardless of frame rate\n        const deltaTime = (currentTime - lastFrameTime) / frameInterval;\n        lastFrameTime = currentTime;\n\n        // Increment time for animations with consistent speed\n        timeRef.current += 0.005 * Math.min(deltaTime, 2);\n\n        // Get frequency and time domain data\n        analyser.getByteFrequencyData(dataArray);\n        analyser.getByteTimeDomainData(timeArray);\n\n        // Update audio data for 3D visualizer with more efficient approach\n        const newDataArray = new Array(bufferLength);\n        const newTimeArray = new Array(bufferLength);\n\n        // Use logarithmic sampling to focus more on lower frequencies\n        for (let i = 0; i < bufferLength; i++) {\n          // Logarithmic mapping to emphasize lower frequencies\n          const logIndex = Math.min(bufferLength - 1, Math.floor(Math.pow(i / bufferLength, 0.5) * bufferLength));\n          newDataArray[i] = dataArray[logIndex];\n          newTimeArray[i] = timeArray[logIndex];\n        }\n        setAudioData({\n          dataArray: newDataArray,\n          timeArray: newTimeArray,\n          bufferLength\n        });\n      };\n      update3DAudio(performance.now());\n      return;\n    }\n\n    // For 2D visualizations, ensure canvas exists\n    if (!canvasRef.current) {\n      console.error(\"Canvas reference is null in startVisualization for 2D visualization\");\n      return;\n    }\n    const canvas = canvasRef.current;\n    const ctx = canvas.getContext('2d', {\n      alpha: false\n    }); // Optimize by disabling alpha\n\n    // Cache parameter values outside the animation loop for better performance\n    let cachedParameters = {\n      ...parameters\n    };\n\n    // Animation function for 2D visualizations\n    const draw = currentTime => {\n      animationFrameRef.current = requestAnimationFrame(draw);\n\n      // Calculate delta time for smooth animation regardless of frame rate\n      const deltaTime = (currentTime - lastFrameTime) / frameInterval;\n      lastFrameTime = currentTime;\n\n      // Increment time for animations with consistent speed\n      timeRef.current += 0.005 * Math.min(deltaTime, 2);\n\n      // Get frequency and time domain data\n      analyser.getByteFrequencyData(dataArray);\n      analyser.getByteTimeDomainData(timeArray);\n\n      // Clear canvas\n      ctx.fillStyle = 'rgb(0, 0, 0)';\n      ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n      // Check if parameters have changed\n      if (JSON.stringify(cachedParameters) !== JSON.stringify(parameters)) {\n        cachedParameters = {\n          ...parameters\n        };\n      }\n\n      // Draw visualization based on template\n      switch (template) {\n        case 'waveform':\n          drawWaveform(ctx, dataArray, bufferLength, cachedParameters);\n          break;\n        case 'bars':\n          drawBars(ctx, dataArray, bufferLength, cachedParameters);\n          break;\n        case 'circles':\n          drawCircles(ctx, dataArray, bufferLength, cachedParameters);\n          break;\n        case 'kaleidoscope':\n          drawKaleidoscope(ctx, dataArray, timeArray, bufferLength, cachedParameters);\n          break;\n        case 'spiral':\n          drawSpiral(ctx, dataArray, timeArray, bufferLength, cachedParameters);\n          break;\n        case 'particles':\n          updateAndDrawParticles(ctx, dataArray, bufferLength, cachedParameters);\n          break;\n        case 'ripple':\n          drawRipples(ctx, dataArray, timeArray, bufferLength, cachedParameters);\n          break;\n        case 'terrain':\n          drawTerrain(ctx, dataArray, timeArray, bufferLength, cachedParameters);\n          break;\n        case 'starburst':\n          drawStarburst(ctx, dataArray, timeArray, bufferLength, cachedParameters);\n          break;\n        case 'fractal':\n          drawFractal(ctx, dataArray, timeArray, bufferLength, cachedParameters);\n          break;\n        case 'liquid':\n          drawLiquid(ctx, dataArray, timeArray, bufferLength, cachedParameters);\n          break;\n        default:\n          drawWaveform(ctx, dataArray, bufferLength, cachedParameters);\n      }\n    };\n    draw(performance.now());\n  };\n  const drawWaveform = (ctx, dataArray, bufferLength, cachedParameters) => {\n    // Safety check - ensure canvas reference exists\n    if (!canvasRef.current) {\n      console.error(\"Canvas reference is null in drawWaveform\");\n      return;\n    }\n\n    // Apply parameters\n    const lineWidth = cachedParameters.lineWidth || 3;\n    const color = cachedParameters.color || '#00aaff';\n    const reactivity = (cachedParameters.reactivity || 50) / 40; // Adjusted for better responsiveness\n    const smoothing = (cachedParameters.smoothing || 50) / 100; // Convert to 0-1 scale\n\n    ctx.lineWidth = lineWidth;\n    ctx.strokeStyle = color;\n    ctx.beginPath();\n    const sliceWidth = canvasRef.current.width * 1.0 / bufferLength;\n    let x = 0;\n\n    // Use fewer points for better performance\n    const step = Math.max(1, Math.floor(bufferLength / 256));\n    for (let i = 0; i < bufferLength; i += step) {\n      const v = dataArray[i] / 128.0 * reactivity;\n      const y = v * canvasRef.current.height / 2;\n      if (i === 0) {\n        ctx.moveTo(x, y);\n      } else {\n        // Apply smoothing if enabled\n        if (smoothing > 0) {\n          const prevX = x - sliceWidth * step;\n          const prevY = dataArray[i - step] / 128.0 * reactivity * canvasRef.current.height / 2;\n          const cpX1 = prevX + sliceWidth * step / 3;\n          const cpX2 = x - sliceWidth * step / 3;\n          const cpY1 = prevY;\n          const cpY2 = y;\n\n          // Use bezier curve for smoothing\n          ctx.bezierCurveTo(cpX1, cpY1, cpX2, cpY2, x, y);\n        } else {\n          ctx.lineTo(x, y);\n        }\n      }\n      x += sliceWidth * step;\n    }\n    ctx.lineTo(canvasRef.current.width, canvasRef.current.height / 2);\n    ctx.stroke();\n  };\n  const drawBars = (ctx, dataArray, bufferLength, cachedParameters) => {\n    // Safety check - ensure canvas reference exists\n    if (!canvasRef.current) {\n      console.error(\"Canvas reference is null in drawBars\");\n      return;\n    }\n\n    // Apply parameters\n    const color = cachedParameters.color || '#ff5500';\n    const barWidth = (cachedParameters.barWidth || 50) / 100; // Convert to 0-1 scale\n    const spacing = (cachedParameters.spacing || 30) / 100; // Convert to 0-1 scale\n    const reactivity = (cachedParameters.reactivity || 50) / 20; // Adjusted for better responsiveness\n\n    const bars = Math.min(bufferLength, 128); // Reduced number of bars for better performance\n    const width = canvasRef.current.width;\n    const height = canvasRef.current.height;\n    const barWidthPx = width / bars * barWidth;\n    const barSpacing = width / bars * spacing;\n    const totalBarWidth = barWidthPx + barSpacing;\n    for (let i = 0; i < bars; i++) {\n      // Use logarithmic mapping to emphasize lower frequencies\n      // Focus more on the lower half of the frequency spectrum\n      const freqRatio = i / bars;\n      const dataIndex = Math.min(bufferLength - 1, Math.floor(Math.pow(freqRatio, 0.8) * (bufferLength / 2)));\n      const barHeight = dataArray[dataIndex] * reactivity;\n      const x = i * totalBarWidth;\n      const y = height - barHeight;\n      ctx.fillStyle = adjustColor(color, i / bars * 30);\n      ctx.fillRect(x, y, barWidthPx, barHeight);\n    }\n  };\n  const drawCircles = (ctx, dataArray, bufferLength, cachedParameters) => {\n    // Safety check - ensure canvas reference exists\n    if (!canvasRef.current) {\n      console.error(\"Canvas reference is null in drawCircles\");\n      return;\n    }\n\n    // Apply parameters\n    const color = cachedParameters.color || '#ff00ff';\n    const baseRadius = (cachedParameters.radius || 50) / 100 * Math.min(canvasRef.current.width, canvasRef.current.height) / 2;\n    const circleCount = Math.max(1, Math.min(20, Math.floor((cachedParameters.count || 50) / 5))); // 1-20 circles\n    const reactivity = (cachedParameters.reactivity || 50) / 40; // Adjusted for better responsiveness\n\n    const centerX = canvasRef.current.width / 2;\n    const centerY = canvasRef.current.height / 2;\n\n    // Draw circles\n    for (let c = 0; c < circleCount; c++) {\n      // Focus on lower frequencies for outer circles, higher frequencies for inner circles\n      const freqRatio = c / circleCount;\n      const freqIndex = Math.floor(Math.pow(freqRatio, 0.7) * (bufferLength / 2));\n      const circleIndex = Math.min(bufferLength - 1, freqIndex);\n      const audioValue = dataArray[circleIndex] / 128.0 * reactivity;\n      const radius = baseRadius * (c + 1) / circleCount * audioValue;\n      ctx.beginPath();\n      ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);\n      ctx.strokeStyle = adjustColor(color, c / circleCount * 50);\n      ctx.stroke();\n    }\n  };\n  const drawKaleidoscope = (ctx, dataArray, timeArray, bufferLength, cachedParameters) => {\n    // Safety check - ensure canvas reference exists\n    if (!canvasRef.current) {\n      console.error(\"Canvas reference is null in drawKaleidoscope\");\n      return;\n    }\n\n    // Apply parameters\n    const color = cachedParameters.color || '#ffaa00';\n    const segments = cachedParameters.segments || 8;\n    const speed = (cachedParameters.speed || 50) / 2000; // Reduced speed for slower rotation\n    const reactivity = (cachedParameters.reactivity || 50) / 40; // Adjusted for better responsiveness\n\n    const centerX = canvasRef.current.width / 2;\n    const centerY = canvasRef.current.height / 2;\n    const radius = Math.min(centerX, centerY) * 0.8;\n\n    // Rotate based on time and speed\n    ctx.translate(centerX, centerY);\n    ctx.rotate(timeRef.current * speed);\n\n    // Draw kaleidoscope segments\n    for (let s = 0; s < segments; s++) {\n      ctx.rotate(Math.PI * 2 / segments);\n      ctx.beginPath();\n      ctx.strokeStyle = adjustColor(color, s * 5);\n\n      // Draw audio-reactive pattern\n      // Use fewer points for better performance\n      const step = Math.max(8, Math.floor(bufferLength / 64));\n      for (let i = 0; i < bufferLength; i += step) {\n        // Focus on lower frequencies which typically contain more rhythm information\n        const dataIndex = Math.min(bufferLength - 1, Math.floor(Math.pow(i / bufferLength, 0.7) * bufferLength));\n        const x = dataArray[dataIndex] / 256.0 * radius * reactivity;\n        const y = timeArray[dataIndex] / 256.0 * radius * reactivity;\n        if (i === 0) {\n          ctx.moveTo(x, y);\n        } else {\n          ctx.lineTo(x, y);\n        }\n      }\n      ctx.stroke();\n    }\n\n    // Reset transformation\n    ctx.setTransform(1, 0, 0, 1, 0, 0);\n  };\n  const drawSpiral = (ctx, dataArray, timeArray, bufferLength, cachedParameters) => {\n    // Safety check - ensure canvas reference exists\n    if (!canvasRef.current) {\n      console.error(\"Canvas reference is null in drawSpiral\");\n      return;\n    }\n\n    // Apply parameters\n    const color = cachedParameters.color || '#00ff99';\n    const arms = cachedParameters.arms || 5;\n    const speed = (cachedParameters.speed || 50) / 2000; // Reduced speed for slower rotation\n    const reactivity = (cachedParameters.reactivity || 50) / 40; // Adjusted for better responsiveness\n\n    const centerX = canvasRef.current.width / 2;\n    const centerY = canvasRef.current.height / 2;\n    const maxRadius = Math.min(centerX, centerY) * 0.9;\n\n    // Rotate based on time and speed\n    ctx.translate(centerX, centerY);\n    ctx.rotate(timeRef.current * speed);\n\n    // Pre-calculate common values\n    const PI2 = Math.PI * 2;\n    const PI6 = Math.PI * 6;\n\n    // Pre-calculate arm colors to avoid recalculating in the loop\n    const armColors = [];\n    for (let a = 0; a < arms; a++) {\n      armColors[a] = adjustColor(color, a * 10);\n    }\n\n    // Draw spiral arms\n    for (let a = 0; a < arms; a++) {\n      const armAngle = a / arms * PI2;\n      ctx.beginPath();\n      ctx.strokeStyle = armColors[a];\n\n      // Use a more efficient approach for drawing the spiral\n      // but maintain the original visual appearance with 100 points\n      const pointsPerArm = 100;\n\n      // Sample audio data less frequently for performance\n      const sampleStep = Math.max(1, Math.floor(bufferLength / 128));\n      for (let i = 0; i < pointsPerArm; i++) {\n        const t = i / pointsPerArm;\n        const angle = armAngle + t * PI6;\n        const radius = t * maxRadius;\n\n        // Apply audio reactivity - use a more efficient data sampling approach\n        // Focus on lower frequencies which typically contain more rhythm information\n        const freqIndex = Math.min(bufferLength - 1, Math.floor(t * bufferLength / 4));\n        const dataIndex = Math.min(bufferLength - 1, freqIndex);\n        const audioValue = dataArray[dataIndex] / 128.0 * reactivity;\n\n        // Pre-calculate trig functions for performance\n        const cosAngle = Math.cos(angle);\n        const sinAngle = Math.sin(angle);\n        const x = cosAngle * radius * audioValue;\n        const y = sinAngle * radius * audioValue;\n        if (i === 0) {\n          ctx.moveTo(x, y);\n        } else {\n          ctx.lineTo(x, y);\n        }\n      }\n      ctx.stroke();\n    }\n\n    // Reset transformation\n    ctx.setTransform(1, 0, 0, 1, 0, 0);\n  };\n\n  // Add a new ripple visualization\n  const drawRipples = (ctx, dataArray, timeArray, bufferLength, cachedParameters) => {\n    // Safety check - ensure canvas reference exists\n    if (!canvasRef.current) {\n      console.error(\"Canvas reference is null in drawRipples\");\n      return;\n    }\n\n    // Apply parameters\n    const color = cachedParameters.color || '#00ffff';\n    const reactivity = (cachedParameters.reactivity || 50) / 40;\n    const speed = (cachedParameters.speed || 50) / 50;\n    const density = (cachedParameters.density || 50) / 50;\n    const width = canvasRef.current.width;\n    const height = canvasRef.current.height;\n    const centerX = width / 2;\n    const centerY = height / 2;\n    const maxRadius = Math.sqrt(width * width + height * height) / 2;\n\n    // Initialize ripples array if it doesn't exist\n    if (!window.ripples) {\n      window.ripples = [];\n    }\n\n    // Detect beats for creating new ripples\n    let bassEnergy = 0;\n    for (let i = 0; i < 8; i++) {\n      bassEnergy += dataArray[i];\n    }\n    bassEnergy = bassEnergy / (8 * 255);\n\n    // Create new ripple on strong beats\n    if (bassEnergy > 0.6 && Math.random() < 0.3 * density) {\n      // Get a frequency band for this ripple's color\n      const freqBand = Math.floor(Math.random() * (bufferLength / 4));\n      const freqIntensity = dataArray[freqBand] / 255;\n\n      // Create a new ripple\n      window.ripples.push({\n        radius: 0,\n        maxRadius: maxRadius * (0.3 + Math.random() * 0.7),\n        lineWidth: 1 + Math.random() * 4,\n        alpha: 0.7 + Math.random() * 0.3,\n        speed: (0.5 + Math.random() * 1.5) * speed,\n        color: adjustColor(color, freqIntensity * 50 - 25)\n      });\n    }\n\n    // Draw and update ripples\n    for (let i = 0; i < window.ripples.length; i++) {\n      const ripple = window.ripples[i];\n\n      // Update radius\n      ripple.radius += ripple.speed;\n\n      // Decrease alpha as the ripple expands\n      ripple.alpha *= 0.98;\n\n      // Draw ripple\n      ctx.beginPath();\n      ctx.arc(centerX, centerY, ripple.radius, 0, Math.PI * 2);\n      ctx.strokeStyle = ripple.color;\n      ctx.globalAlpha = ripple.alpha;\n      ctx.lineWidth = ripple.lineWidth;\n      ctx.stroke();\n      ctx.globalAlpha = 1.0;\n    }\n\n    // Remove ripples that have expanded beyond their max radius or faded out\n    window.ripples = window.ripples.filter(ripple => ripple.radius < ripple.maxRadius && ripple.alpha > 0.01);\n  };\n\n  // Add a new terrain visualization\n  const drawTerrain = (ctx, dataArray, timeArray, bufferLength, cachedParameters) => {\n    // Safety check - ensure canvas reference exists\n    if (!canvasRef.current) {\n      console.error(\"Canvas reference is null in drawTerrain\");\n      return;\n    }\n\n    // Apply parameters\n    const color = cachedParameters.color || '#33cc33';\n    const reactivity = (cachedParameters.reactivity || 50) / 40;\n    const detail = (cachedParameters.detail || 50) / 50;\n    const speed = (cachedParameters.speed || 50) / 100;\n    const width = canvasRef.current.width;\n    const height = canvasRef.current.height;\n\n    // Calculate number of terrain points based on detail parameter\n    const points = Math.max(20, Math.floor(width / (10 / detail)));\n    const pointWidth = width / points;\n\n    // Create terrain heights based on audio data\n    const terrainHeights = [];\n\n    // Sample audio data for terrain heights\n    for (let i = 0; i < points; i++) {\n      // Map point index to frequency data index\n      const dataIndex = Math.floor(i / points * (bufferLength / 2));\n\n      // Get audio value and apply reactivity\n      const audioValue = dataArray[dataIndex] / 255.0 * reactivity;\n\n      // Calculate terrain height\n      const terrainHeight = height * 0.1 + audioValue * height * 0.6;\n      terrainHeights.push(terrainHeight);\n    }\n\n    // Smooth terrain heights\n    const smoothedHeights = [];\n    for (let i = 0; i < points; i++) {\n      let sum = 0;\n      let count = 0;\n\n      // Apply smoothing by averaging neighboring points\n      for (let j = Math.max(0, i - 2); j <= Math.min(points - 1, i + 2); j++) {\n        sum += terrainHeights[j];\n        count++;\n      }\n      smoothedHeights.push(sum / count);\n    }\n\n    // Create a gradient for the terrain\n    const gradient = ctx.createLinearGradient(0, height, 0, height / 2);\n    gradient.addColorStop(0, color);\n    gradient.addColorStop(1, adjustColor(color, 30));\n\n    // Draw terrain\n    ctx.fillStyle = gradient;\n    ctx.beginPath();\n    ctx.moveTo(0, height);\n\n    // Draw terrain path\n    for (let i = 0; i < points; i++) {\n      const x = i * pointWidth;\n      const y = height - smoothedHeights[i];\n      if (i === 0) {\n        ctx.lineTo(x, y);\n      } else {\n        // Use quadratic curves for smoother terrain\n        const prevX = (i - 1) * pointWidth;\n        const prevY = height - smoothedHeights[i - 1];\n        const cpX = (prevX + x) / 2;\n        const cpY = (prevY + y) / 2;\n        ctx.quadraticCurveTo(cpX, cpY, x, y);\n      }\n    }\n\n    // Complete the path\n    ctx.lineTo(width, height);\n    ctx.closePath();\n    ctx.fill();\n\n    // Draw a reflection effect\n    ctx.globalAlpha = 0.3;\n    ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';\n\n    // Draw reflection path (inverted terrain)\n    ctx.beginPath();\n    ctx.moveTo(0, height);\n    for (let i = 0; i < points; i++) {\n      const x = i * pointWidth;\n      const terrainY = height - smoothedHeights[i];\n      const reflectionHeight = smoothedHeights[i] * 0.3; // Smaller reflection\n      const y = height + reflectionHeight;\n      if (i === 0) {\n        ctx.lineTo(x, y);\n      } else {\n        // Use quadratic curves for smoother terrain\n        const prevX = (i - 1) * pointWidth;\n        const prevY = height + smoothedHeights[i - 1] * 0.3;\n        const cpX = (prevX + x) / 2;\n        const cpY = (prevY + y) / 2;\n        ctx.quadraticCurveTo(cpX, cpY, x, y);\n      }\n    }\n\n    // Complete the reflection path\n    ctx.lineTo(width, height);\n    ctx.closePath();\n    ctx.fill();\n\n    // Reset alpha\n    ctx.globalAlpha = 1.0;\n\n    // Draw stars in the sky\n    if (!window.stars) {\n      // Initialize stars\n      window.stars = [];\n      const starCount = 50;\n      for (let i = 0; i < starCount; i++) {\n        window.stars.push({\n          x: Math.random() * width,\n          y: Math.random() * height * 0.5,\n          size: 0.5 + Math.random() * 1.5,\n          brightness: 0.3 + Math.random() * 0.7\n        });\n      }\n    }\n\n    // Draw stars with audio reactivity\n    for (let i = 0; i < window.stars.length; i++) {\n      const star = window.stars[i];\n\n      // Make stars twinkle based on audio\n      const dataIndex = Math.floor(Math.random() * (bufferLength / 4));\n      const twinkle = 0.5 + dataArray[dataIndex] / 255.0 * 0.5;\n      ctx.fillStyle = `rgba(255, 255, 255, ${star.brightness * twinkle})`;\n      ctx.beginPath();\n      ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);\n      ctx.fill();\n    }\n  };\n\n  // Add a new starburst visualization\n  const drawStarburst = (ctx, dataArray, timeArray, bufferLength, cachedParameters) => {\n    // Safety check - ensure canvas reference exists\n    if (!canvasRef.current) {\n      console.error(\"Canvas reference is null in drawStarburst\");\n      return;\n    }\n\n    // Apply parameters\n    const color = cachedParameters.color || '#ff9900';\n    const reactivity = (cachedParameters.reactivity || 50) / 40;\n    const particleCount = (cachedParameters.count || 50) / 50 * 100; // 0-100 particles\n    const particleSize = (cachedParameters.size || 50) / 50 * 5; // 0-5 size\n\n    const width = canvasRef.current.width;\n    const height = canvasRef.current.height;\n    const centerX = width / 2;\n    const centerY = height / 2;\n\n    // Initialize particles array if it doesn't exist\n    if (!window.starburstParticles) {\n      window.starburstParticles = [];\n    }\n\n    // Detect beats for creating new bursts\n    let bassEnergy = 0;\n    for (let i = 0; i < 8; i++) {\n      bassEnergy += dataArray[i];\n    }\n    bassEnergy = bassEnergy / (8 * 255);\n\n    // Create new burst on strong beats\n    if (bassEnergy > 0.6 && (window.lastBurstTime === undefined || timeRef.current - window.lastBurstTime > 0.5)) {\n      window.lastBurstTime = timeRef.current;\n\n      // Create a burst of particles\n      const burstSize = Math.floor(particleCount * (0.5 + bassEnergy * 0.5));\n      const burstColor = adjustColor(color, Math.random() * 40 - 20);\n      for (let i = 0; i < burstSize; i++) {\n        const angle = Math.random() * Math.PI * 2;\n        const speed = (1 + Math.random() * 3) * reactivity;\n        const size = (0.5 + Math.random() * 1.5) * particleSize;\n        const life = 1.0; // Full life\n\n        window.starburstParticles.push({\n          x: centerX,\n          y: centerY,\n          vx: Math.cos(angle) * speed,\n          vy: Math.sin(angle) * speed,\n          size: size,\n          color: burstColor,\n          life: life,\n          decay: 0.01 + Math.random() * 0.02 // Random decay rate\n        });\n      }\n    }\n\n    // Clear canvas with fade effect for trails\n    ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';\n    ctx.fillRect(0, 0, width, height);\n\n    // Update and draw particles\n    for (let i = 0; i < window.starburstParticles.length; i++) {\n      const particle = window.starburstParticles[i];\n\n      // Update position\n      particle.x += particle.vx;\n      particle.y += particle.vy;\n\n      // Apply gravity\n      particle.vy += 0.05;\n\n      // Update life\n      particle.life -= particle.decay;\n\n      // Draw particle\n      if (particle.life > 0) {\n        ctx.globalAlpha = particle.life;\n        ctx.fillStyle = particle.color;\n        ctx.beginPath();\n        ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);\n        ctx.fill();\n      }\n    }\n\n    // Reset alpha\n    ctx.globalAlpha = 1.0;\n\n    // Remove dead particles\n    window.starburstParticles = window.starburstParticles.filter(p => p.life > 0);\n  };\n\n  // Add a new fractal tree visualization\n  const drawFractal = (ctx, dataArray, timeArray, bufferLength, cachedParameters) => {\n    // Safety check - ensure canvas reference exists\n    if (!canvasRef.current) {\n      console.error(\"Canvas reference is null in drawFractal\");\n      return;\n    }\n\n    // Apply parameters\n    const color = cachedParameters.color || '#66ff66';\n    const reactivity = (cachedParameters.reactivity || 50) / 40;\n    const complexity = (cachedParameters.complexity || 50) / 50; // 0-1 complexity\n    const variation = (cachedParameters.variation || 50) / 50; // 0-1 variation\n\n    const width = canvasRef.current.width;\n    const height = canvasRef.current.height;\n\n    // Clear canvas\n    ctx.fillStyle = 'rgb(0, 0, 0)';\n    ctx.fillRect(0, 0, width, height);\n\n    // Calculate audio energy for different frequency bands\n    const lowEnergy = getAverageEnergy(dataArray, 0, 10) * reactivity;\n    const midEnergy = getAverageEnergy(dataArray, 10, 100) * reactivity;\n    const highEnergy = getAverageEnergy(dataArray, 100, 200) * reactivity;\n\n    // Calculate tree parameters based on audio\n    const trunkLength = height * 0.25 * (0.8 + lowEnergy * 0.4);\n    const branchAngle = Math.PI / 6 + midEnergy * Math.PI / 12;\n    const branchRatio = 0.67 + highEnergy * 0.1;\n\n    // Calculate max depth based on complexity\n    const maxDepth = Math.floor(4 + complexity * 4);\n\n    // Draw tree\n    ctx.strokeStyle = color;\n    ctx.lineWidth = 2;\n\n    // Start tree from bottom center\n    const startX = width / 2;\n    const startY = height * 0.9;\n\n    // Draw trunk\n    ctx.beginPath();\n    ctx.moveTo(startX, startY);\n    ctx.lineTo(startX, startY - trunkLength);\n    ctx.stroke();\n\n    // Draw branches recursively\n    drawBranch(ctx, startX, startY - trunkLength, trunkLength, -Math.PI / 2, maxDepth, branchAngle, branchRatio, color, variation, timeRef.current);\n\n    // Helper function to calculate average energy in a frequency range\n    function getAverageEnergy(data, startBin, endBin) {\n      let sum = 0;\n      const binCount = Math.min(endBin - startBin, data.length - startBin);\n      if (binCount <= 0) return 0;\n      for (let i = startBin; i < startBin + binCount; i++) {\n        sum += data[i] / 255.0;\n      }\n      return sum / binCount;\n    }\n\n    // Recursive function to draw branches\n    function drawBranch(ctx, x, y, length, angle, depth, branchAngle, branchRatio, color, variation, time) {\n      if (depth === 0) return;\n\n      // Calculate new branch length\n      const newLength = length * branchRatio;\n\n      // Add some variation based on time\n      const timeVariation = Math.sin(time * 2 + depth) * variation * 0.1;\n\n      // Calculate endpoints for left and right branches\n      const leftAngle = angle - branchAngle + timeVariation;\n      const rightAngle = angle + branchAngle + timeVariation;\n      const leftX = x + Math.cos(leftAngle) * newLength;\n      const leftY = y + Math.sin(leftAngle) * newLength;\n      const rightX = x + Math.cos(rightAngle) * newLength;\n      const rightY = y + Math.sin(rightAngle) * newLength;\n\n      // Adjust color based on depth\n      const branchColor = adjustColor(color, depth * 10);\n      ctx.strokeStyle = branchColor;\n\n      // Adjust line width based on depth\n      ctx.lineWidth = Math.max(1, 3 - depth * 0.5);\n\n      // Draw left branch\n      ctx.beginPath();\n      ctx.moveTo(x, y);\n      ctx.lineTo(leftX, leftY);\n      ctx.stroke();\n\n      // Draw right branch\n      ctx.beginPath();\n      ctx.moveTo(x, y);\n      ctx.lineTo(rightX, rightY);\n      ctx.stroke();\n\n      // Recursively draw sub-branches\n      drawBranch(ctx, leftX, leftY, newLength, leftAngle, depth - 1, branchAngle, branchRatio, color, variation, time);\n      drawBranch(ctx, rightX, rightY, newLength, rightAngle, depth - 1, branchAngle, branchRatio, color, variation, time);\n    }\n  };\n\n  // Add a new liquid wave visualization\n  const drawLiquid = (ctx, dataArray, timeArray, bufferLength, cachedParameters) => {\n    // Safety check - ensure canvas reference exists\n    if (!canvasRef.current) {\n      console.error(\"Canvas reference is null in drawLiquid\");\n      return;\n    }\n\n    // Apply parameters\n    const color = cachedParameters.color || '#0099ff';\n    const reactivity = (cachedParameters.reactivity || 50) / 40;\n    const complexity = (cachedParameters.complexity || 50) / 50; // 0-1 complexity\n    const speed = (cachedParameters.speed || 50) / 50; // 0-1 speed\n\n    const width = canvasRef.current.width;\n    const height = canvasRef.current.height;\n\n    // Initialize wave points if they don't exist\n    if (!window.liquidPoints) {\n      window.liquidPoints = [];\n      const pointCount = Math.floor(20 + complexity * 30); // 20-50 points based on complexity\n\n      for (let i = 0; i < pointCount; i++) {\n        window.liquidPoints.push({\n          x: width * (i / (pointCount - 1)),\n          y: height / 2,\n          vy: 0\n        });\n      }\n    }\n\n    // Ensure we have the right number of points if complexity changes\n    const targetPointCount = Math.floor(20 + complexity * 30);\n    if (window.liquidPoints.length !== targetPointCount) {\n      const newPoints = [];\n      for (let i = 0; i < targetPointCount; i++) {\n        if (i < window.liquidPoints.length) {\n          newPoints.push(window.liquidPoints[i]);\n        } else {\n          newPoints.push({\n            x: width * (i / (targetPointCount - 1)),\n            y: height / 2,\n            vy: 0\n          });\n        }\n      }\n      window.liquidPoints = newPoints;\n    }\n\n    // Clear canvas with gradient background\n    const gradient = ctx.createLinearGradient(0, 0, 0, height);\n    gradient.addColorStop(0, 'rgb(0, 10, 30)');\n    gradient.addColorStop(1, 'rgb(0, 0, 10)');\n    ctx.fillStyle = gradient;\n    ctx.fillRect(0, 0, width, height);\n\n    // Calculate audio energy for different frequency bands\n    const frequencyBands = 8;\n    const energyBands = [];\n    for (let i = 0; i < frequencyBands; i++) {\n      const startBin = Math.floor(i / frequencyBands * (bufferLength / 2));\n      const endBin = Math.floor((i + 1) / frequencyBands * (bufferLength / 2));\n      energyBands.push(getAverageEnergy(dataArray, startBin, endBin) * reactivity);\n    }\n\n    // Update wave points based on audio\n    const pointCount = window.liquidPoints.length;\n    const dampening = 0.95;\n    const tension = 0.025;\n    const timeScale = speed * 0.5;\n\n    // Apply forces to points\n    for (let i = 0; i < pointCount; i++) {\n      const point = window.liquidPoints[i];\n\n      // Determine which frequency band affects this point\n      const bandIndex = Math.floor(i / pointCount * frequencyBands);\n      const energy = energyBands[bandIndex];\n\n      // Apply force based on audio energy\n      point.vy += (Math.random() * 2 - 1) * energy * 2;\n\n      // Apply time-based oscillation\n      const timeOffset = i / pointCount * Math.PI * 2;\n      point.vy += Math.sin(timeRef.current * timeScale + timeOffset) * 0.2;\n\n      // Apply physics\n      point.y += point.vy;\n      point.vy *= dampening;\n\n      // Apply tension to return to center\n      point.vy += (height / 2 - point.y) * tension;\n    }\n\n    // Draw the liquid\n    ctx.fillStyle = color;\n    ctx.beginPath();\n    ctx.moveTo(0, height);\n\n    // Draw first point\n    ctx.lineTo(window.liquidPoints[0].x, window.liquidPoints[0].y);\n\n    // Draw curve through points\n    for (let i = 0; i < pointCount - 1; i++) {\n      const current = window.liquidPoints[i];\n      const next = window.liquidPoints[i + 1];\n\n      // Use quadratic curves for smoother liquid\n      const cpX = (current.x + next.x) / 2;\n      const cpY = (current.y + next.y) / 2;\n      ctx.quadraticCurveTo(current.x, current.y, cpX, cpY);\n    }\n\n    // Draw last point\n    const lastPoint = window.liquidPoints[pointCount - 1];\n    ctx.lineTo(lastPoint.x, lastPoint.y);\n\n    // Complete the path\n    ctx.lineTo(width, height);\n    ctx.closePath();\n    ctx.fill();\n\n    // Add highlights\n    ctx.strokeStyle = adjustColor(color, 30);\n    ctx.lineWidth = 2;\n    ctx.beginPath();\n\n    // Draw curve through points for highlight\n    ctx.moveTo(window.liquidPoints[0].x, window.liquidPoints[0].y);\n    for (let i = 0; i < pointCount - 1; i++) {\n      const current = window.liquidPoints[i];\n      const next = window.liquidPoints[i + 1];\n\n      // Use quadratic curves for smoother liquid\n      const cpX = (current.x + next.x) / 2;\n      const cpY = (current.y + next.y) / 2;\n      ctx.quadraticCurveTo(current.x, current.y, cpX, cpY);\n    }\n\n    // Draw last point for highlight\n    ctx.lineTo(lastPoint.x, lastPoint.y);\n    ctx.stroke();\n\n    // Add bubbles for extra effect\n    if (!window.liquidBubbles) {\n      window.liquidBubbles = [];\n    }\n\n    // Create new bubbles based on audio energy\n    const bassEnergy = energyBands[0];\n    if (Math.random() < bassEnergy * 0.3) {\n      const bubbleX = Math.random() * width;\n      const bubbleSize = 2 + Math.random() * 8;\n      window.liquidBubbles.push({\n        x: bubbleX,\n        y: height,\n        size: bubbleSize,\n        speed: 0.5 + Math.random() * 2,\n        opacity: 0.1 + Math.random() * 0.4\n      });\n    }\n\n    // Update and draw bubbles\n    ctx.fillStyle = adjustColor(color, 50);\n    for (let i = 0; i < window.liquidBubbles.length; i++) {\n      const bubble = window.liquidBubbles[i];\n\n      // Update position\n      bubble.y -= bubble.speed;\n\n      // Draw bubble\n      ctx.globalAlpha = bubble.opacity;\n      ctx.beginPath();\n      ctx.arc(bubble.x, bubble.y, bubble.size, 0, Math.PI * 2);\n      ctx.fill();\n    }\n\n    // Reset alpha\n    ctx.globalAlpha = 1.0;\n\n    // Remove bubbles that have risen to the top\n    window.liquidBubbles = window.liquidBubbles.filter(b => b.y > -b.size);\n\n    // Helper function to calculate average energy in a frequency range\n    function getAverageEnergy(data, startBin, endBin) {\n      let sum = 0;\n      const binCount = Math.min(endBin - startBin, data.length - startBin);\n      if (binCount <= 0) return 0;\n      for (let i = startBin; i < startBin + binCount; i++) {\n        sum += data[i] / 255.0;\n      }\n      return sum / binCount;\n    }\n  };\n\n  // Update parameters when initialParameters change - use a ref to avoid re-renders\n  useEffect(() => {\n    // Only log in development\n    if (process.env.NODE_ENV !== 'production') {\n      console.log(\"Visualizer received updated parameters:\", initialParameters);\n    }\n    if (initialParameters && Object.keys(initialParameters).length > 0) {\n      // Use a simple update without triggering re-renders\n      setParameters(initialParameters);\n    }\n  }, [initialParameters]);\n\n  // Add a function to update parameters\n  const updateParameters = newParameters => {\n    // Only log in development\n    if (process.env.NODE_ENV !== 'production') {\n      console.log(\"Updating visualization parameters:\", newParameters);\n    }\n    setParameters(newParameters);\n  };\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"visualizer-container\",\n    children: /*#__PURE__*/_jsxDEV(\"div\", {\n      ref: containerRef,\n      className: `visualizer-aspect-container ${RESOLUTIONS[resolution].className}`,\n      children: [use3D ? /*#__PURE__*/_jsxDEV(ThreeVisualizer, {\n        audioData: audioData,\n        template: template.replace('3d', '') // Remove '3d' suffix for the ThreeVisualizer\n        ,\n        isPlaying: isPlaying,\n        parameters: parameters\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 1417,\n        columnNumber: 11\n      }, this) : /*#__PURE__*/_jsxDEV(\"canvas\", {\n        ref: canvasRef,\n        className: \"visualizer-canvas\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 1424,\n        columnNumber: 11\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"visualizer-overlay\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 1426,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"resolution-indicator\",\n        children: [resolution, \" (\", RESOLUTIONS[resolution].width, \"\\xD7\", RESOLUTIONS[resolution].height, \")\"]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 1427,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 1412,\n      columnNumber: 7\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 1411,\n    columnNumber: 5\n  }, this);\n}, \"YKAxe3DkZ4mr2sIx+Fv//uNOOD8=\")), \"YKAxe3DkZ4mr2sIx+Fv//uNOOD8=\");\n_c2 = Visualizer;\nexport default Visualizer;\nvar _c, _c2;\n$RefreshReg$(_c, \"Visualizer$forwardRef\");\n$RefreshReg$(_c2, \"Visualizer\");","map":{"version":3,"names":["React","useEffect","useRef","forwardRef","useState","ThreeVisualizer","jsxDEV","_jsxDEV","RESOLUTIONS","width","height","className","Visualizer","_s","_c","audioFile","template","isPlaying","onAudioElementCreated","parameters","initialParameters","ref","canvasRef","containerRef","audioContextRef","analyserRef","animationFrameRef","sourceRef","audioElementRef","particlesRef","timeRef","resolution","setResolution","audioData","setAudioData","use3D","setUse3D","setParameters","threeDTemplates","includes","isInitialized","initAudio","current","context","window","AudioContext","webkitAudioContext","analyser","createAnalyser","fftSize","smoothingTimeConstant","audioElement","Audio","crossOrigin","preload","timestamp","Date","getTime","src","path","Promise","resolve","reject","loadHandler","console","log","duration","errorHandler","error","addEventListener","once","load","disconnect","mediaSource","createMediaElementSource","connect","destination","onSeeking","currentTime","startVisualization","state","resume","removeEventListener","pause","alert","playAudio","_audioContextRef$curr","play","cancelAnimationFrame","canvas","ctx","getContext","fillStyle","fillRect","style","maxWidth","maxHeight","initParticles","changeResolution","newResolution","useImperativeHandle","getCurrentResolution","updateParameters","count","Math","floor","i","push","x","random","y","size","vx","speed","vy","hue","updateAndDrawParticles","dataArray","bufferLength","cachedParameters","length","color","particleCount","particleSize","reactivity","particle","dataIndex","audioValue","beginPath","arc","PI","adjustColor","fill","hexColor","amount","r","parseInt","substring","g","b","max","min","toString","padStart","frequencyBinCount","Uint8Array","timeArray","getByteFrequencyData","getByteTimeDomainData","lastFrameTime","performance","now","targetFrameRate","frameInterval","update3DAudio","requestAnimationFrame","deltaTime","newDataArray","Array","newTimeArray","logIndex","pow","alpha","draw","JSON","stringify","drawWaveform","drawBars","drawCircles","drawKaleidoscope","drawSpiral","drawRipples","drawTerrain","drawStarburst","drawFractal","drawLiquid","lineWidth","smoothing","strokeStyle","sliceWidth","step","v","moveTo","prevX","prevY","cpX1","cpX2","cpY1","cpY2","bezierCurveTo","lineTo","stroke","barWidth","spacing","bars","barWidthPx","barSpacing","totalBarWidth","freqRatio","barHeight","baseRadius","radius","circleCount","centerX","centerY","c","freqIndex","circleIndex","segments","translate","rotate","s","setTransform","arms","maxRadius","PI2","PI6","armColors","a","armAngle","pointsPerArm","sampleStep","t","angle","cosAngle","cos","sinAngle","sin","density","sqrt","ripples","bassEnergy","freqBand","freqIntensity","ripple","globalAlpha","filter","detail","points","pointWidth","terrainHeights","terrainHeight","smoothedHeights","sum","j","gradient","createLinearGradient","addColorStop","cpX","cpY","quadraticCurveTo","closePath","terrainY","reflectionHeight","stars","starCount","brightness","star","twinkle","starburstParticles","lastBurstTime","undefined","burstSize","burstColor","life","decay","p","complexity","variation","lowEnergy","getAverageEnergy","midEnergy","highEnergy","trunkLength","branchAngle","branchRatio","maxDepth","startX","startY","drawBranch","data","startBin","endBin","binCount","depth","time","newLength","timeVariation","leftAngle","rightAngle","leftX","leftY","rightX","rightY","branchColor","liquidPoints","pointCount","targetPointCount","newPoints","frequencyBands","energyBands","dampening","tension","timeScale","point","bandIndex","energy","timeOffset","next","lastPoint","liquidBubbles","bubbleX","bubbleSize","opacity","bubble","process","env","NODE_ENV","Object","keys","newParameters","children","replace","fileName","_jsxFileName","lineNumber","columnNumber","_c2","$RefreshReg$"],"sources":["C:/Users/fkuce/OneDrive/Desktop/Money Projects/Visualizer/frontend/src/components/Visualizer.js"],"sourcesContent":["import React, { useEffect, useRef, forwardRef, useState } from 'react';\nimport ThreeVisualizer from './ThreeVisualizer';\nimport './Visualizer.css';\n\nconst RESOLUTIONS = {\n  '4K': { width: 3840, height: 2160, className: 'aspect-ratio-4k' },\n  '1080p': { width: 1920, height: 1080, className: 'aspect-ratio-1080p' },\n  '720p': { width: 1280, height: 720, className: 'aspect-ratio-720p' },\n  'Square': { width: 720, height: 720, className: 'aspect-ratio-square' },\n  'Vertical': { width: 1080, height: 1920, className: 'aspect-ratio-vertical' }\n};\n\nconst Visualizer = forwardRef(({ audioFile, template, isPlaying, onAudioElementCreated, parameters: initialParameters = {} }, ref) => {\n  const canvasRef = useRef(null);\n  const containerRef = useRef(null);\n  const audioContextRef = useRef(null);\n  const analyserRef = useRef(null);\n  const animationFrameRef = useRef(null);\n  const sourceRef = useRef(null);\n  const audioElementRef = useRef(null);\n  const particlesRef = useRef([]);\n  const timeRef = useRef(0); // Add timeRef to track animation time\n  const [resolution, setResolution] = useState('1080p'); // Default to 1080p\n  const [audioData, setAudioData] = useState(null);\n  const [use3D, setUse3D] = useState(false);\n  const [parameters, setParameters] = useState(initialParameters);\n\n  // Check if template is a 3D visualization\n  useEffect(() => {\n    // Define which templates should use 3D rendering\n    const threeDTemplates = ['particles3d', 'waveform3d', 'spiral3d', 'kaleidoscope3d'];\n    setUse3D(threeDTemplates.includes(template));\n  }, [template]);\n\n  // Audio initialization effect\n  useEffect(() => {\n    if (!audioFile) return;\n\n    let isInitialized = false;\n\n    const initAudio = async () => {\n      try {\n        // Initialize audio context only on first load or if it doesn't exist\n        if (!audioContextRef.current) {\n          // Create context on user interaction\n          const context = new (window.AudioContext || window.webkitAudioContext)();\n          audioContextRef.current = context;\n          \n          // Create analyzer with improved settings for better reactivity\n          const analyser = context.createAnalyser();\n          analyser.fftSize = 2048; // Increased for more detailed frequency data\n          analyser.smoothingTimeConstant = 0.8; // Higher smoothing for more consistent movement\n          analyserRef.current = analyser;\n        }\n\n        // Create and set up audio element\n        const audioElement = new Audio();\n        audioElement.crossOrigin = \"anonymous\";\n        audioElement.preload = \"auto\";\n\n        // Set the audio source\n        const timestamp = new Date().getTime();\n        audioElement.src = `http://localhost:5001${audioFile.path}?t=${timestamp}`;\n\n        // Wait for audio to be loaded enough to play\n        await new Promise((resolve, reject) => {\n          const loadHandler = () => {\n            console.log('Audio loaded, duration:', audioElement.duration);\n            resolve();\n          };\n\n          const errorHandler = (error) => {\n            console.error('Audio load error:', error);\n            reject(error);\n          };\n\n          audioElement.addEventListener('canplaythrough', loadHandler, { once: true });\n          audioElement.addEventListener('error', errorHandler, { once: true });\n          audioElement.load();\n        });\n\n        // Only create new media source if not already connected\n        if (!isInitialized) {\n          // Ensure old source is disconnected\n          if (sourceRef.current) {\n            sourceRef.current.disconnect();\n          }\n\n          // Create and connect new media source\n          const mediaSource = audioContextRef.current.createMediaElementSource(audioElement);\n          sourceRef.current = mediaSource;\n          mediaSource.connect(analyserRef.current);\n          analyserRef.current.connect(audioContextRef.current.destination);\n          isInitialized = true;\n        }\n\n        // Set up event listeners - REMOVE timeupdate listener which causes visualization restarts\n        const onSeeking = () => {\n          console.log('Seeking:', audioElement.currentTime);\n          if (isPlaying) startVisualization();\n        };\n\n        audioElement.addEventListener('seeking', onSeeking);\n        audioElement.addEventListener('seeked', onSeeking);\n        // Removed timeupdate listener which was causing visualization restarts\n\n        // Store reference and notify parent\n        audioElementRef.current = audioElement;\n        onAudioElementCreated(audioElement);\n\n        // Resume audio context if suspended\n        if (audioContextRef.current.state === 'suspended') {\n          await audioContextRef.current.resume();\n        }\n\n        return () => {\n          console.log('Cleaning up audio element');\n          audioElement.removeEventListener('seeking', onSeeking);\n          audioElement.removeEventListener('seeked', onSeeking);\n          // Removed timeupdate listener cleanup\n          audioElement.pause();\n          audioElement.src = '';\n          onAudioElementCreated(null);\n        };\n      } catch (error) {\n        console.error('Audio initialization error:', error);\n        alert('Error loading audio. Please try again.');\n      }\n    };\n\n    initAudio();\n  }, [audioFile]); // Remove isPlaying from dependencies\n\n  // Separate playback control effect\n  useEffect(() => {\n    const audioElement = audioElementRef.current;\n    if (!audioElement) return;\n\n    const playAudio = async () => {\n      try {\n        // Ensure audio context is running\n        if (audioContextRef.current?.state === 'suspended') {\n          await audioContextRef.current.resume();\n        }\n        \n        console.log('Playing audio...');\n        await audioElement.play();\n        startVisualization();\n      } catch (error) {\n        console.error('Playback error:', error);\n        alert('Error playing audio. Please try again.');\n      }\n    };\n\n    if (isPlaying) {\n      playAudio();\n    } else {\n      console.log('Pausing audio...');\n      audioElement.pause();\n      cancelAnimationFrame(animationFrameRef.current);\n    }\n  }, [isPlaying]);\n\n  // Add effect to handle template changes\n  useEffect(() => {\n    if (!canvasRef.current) return;\n    \n    const canvas = canvasRef.current;\n    const ctx = canvas.getContext('2d');\n    \n    // Clear the entire canvas\n    ctx.fillStyle = 'rgb(0, 0, 0)';\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n    // Restart visualization if playing\n    if (isPlaying) {\n      startVisualization();\n    }\n  }, [template]);\n\n  // Update canvas size based on selected resolution\n  useEffect(() => {\n    if (!canvasRef.current) return;\n    \n    const canvas = canvasRef.current;\n    const { width, height } = RESOLUTIONS[resolution];\n    \n    // Set canvas dimensions to match the selected resolution\n    canvas.width = width;\n    canvas.height = height;\n    \n    // Clear canvas with new dimensions\n    const ctx = canvas.getContext('2d');\n    ctx.fillStyle = 'rgb(0, 0, 0)';\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n    \n    // Adjust container styles based on aspect ratio\n    if (containerRef.current) {\n      if (resolution === 'Vertical') {\n        containerRef.current.style.width = 'auto';\n        containerRef.current.style.height = '80vh';\n      } else if (resolution === 'Square') {\n        containerRef.current.style.width = '720px';\n        containerRef.current.style.height = '720px';\n        containerRef.current.style.maxWidth = '720px';\n        containerRef.current.style.maxHeight = '720px';\n      } else {\n        containerRef.current.style.width = '100%';\n        containerRef.current.style.height = 'auto';\n        containerRef.current.style.maxWidth = `${width}px`;\n        containerRef.current.style.maxHeight = `${height}px`;\n      }\n    }\n    \n    // Restart visualization if playing\n    if (isPlaying) {\n      startVisualization();\n    }\n    \n    // Initialize particles for the new canvas size\n    if (template === 'particles') {\n      initParticles(ctx);\n    }\n  }, [resolution, isPlaying, template]);\n\n  // Function to change resolution\n  const changeResolution = (newResolution) => {\n    if (RESOLUTIONS[newResolution]) {\n      setResolution(newResolution);\n    }\n  };\n\n  // Expose changeResolution to parent via ref\n  React.useImperativeHandle(ref, () => ({\n    changeResolution,\n    getCurrentResolution: () => resolution,\n    updateParameters\n  }));\n\n  const initParticles = (ctx) => {\n    // Safety check - ensure context exists\n    if (!ctx || !ctx.canvas) {\n      console.error(\"Canvas context is null in initParticles\");\n      return;\n    }\n    \n    const count = Math.floor(((parameters.count || 50) / 50) * 200); // 100-400 particles based on count parameter\n    particlesRef.current = [];\n    \n    for (let i = 0; i < count; i++) {\n      particlesRef.current.push({\n        x: Math.random() * ctx.canvas.width,\n        y: Math.random() * ctx.canvas.height,\n        size: Math.random() * ((parameters.size || 50) / 10) + 1, // 1-6 size based on size parameter\n        vx: (Math.random() - 0.5) * ((parameters.speed || 50) / 25), // Speed based on speed parameter\n        vy: (Math.random() - 0.5) * ((parameters.speed || 50) / 25),\n        hue: Math.random() * 360\n      });\n    }\n  };\n\n  const updateAndDrawParticles = (ctx, dataArray, bufferLength, cachedParameters) => {\n    // Safety check - ensure canvas reference exists\n    if (!canvasRef.current) {\n      console.error(\"Canvas reference is null in updateAndDrawParticles\");\n      return;\n    }\n    \n    // Safety check - ensure particles array exists\n    if (!particlesRef.current || particlesRef.current.length === 0) {\n      console.log(\"Initializing particles in updateAndDrawParticles\");\n      initParticles(ctx);\n      \n      // Double-check initialization worked\n      if (!particlesRef.current || particlesRef.current.length === 0) {\n        console.error(\"Failed to initialize particles\");\n        return;\n      }\n    }\n    \n    // Apply parameters\n    const color = cachedParameters.color || '#ffffff';\n    const particleCount = Math.floor(((cachedParameters.count || 50) / 100) * particlesRef.current.length);\n    const particleSize = (cachedParameters.size || 50) / 10; // Convert to 0-10 scale\n    const speed = (cachedParameters.speed || 50) / 50; // Convert to 0-2 scale\n    const reactivity = (cachedParameters.reactivity || 50) / 50; // Convert to 0-2 scale\n    \n    // Clear canvas with fade effect\n    ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';\n    ctx.fillRect(0, 0, canvasRef.current.width, canvasRef.current.height);\n    \n    // Update and draw particles\n    for (let i = 0; i < particleCount; i++) {\n      const particle = particlesRef.current[i];\n      \n      // Apply audio reactivity\n      const dataIndex = Math.floor((i / particleCount) * bufferLength);\n      const audioValue = dataArray[dataIndex] / 255.0 * reactivity;\n      \n      // Update position\n      particle.x += particle.vx * speed;\n      particle.y += particle.vy * speed;\n      \n      // Bounce off edges\n      if (particle.x < 0 || particle.x > canvasRef.current.width) {\n        particle.vx = -particle.vx;\n      }\n      \n      if (particle.y < 0 || particle.y > canvasRef.current.height) {\n        particle.vy = -particle.vy;\n      }\n      \n      // Draw particle\n      const size = particleSize * (1 + audioValue);\n      ctx.beginPath();\n      ctx.arc(particle.x, particle.y, size, 0, Math.PI * 2);\n      ctx.fillStyle = adjustColor(color, audioValue * 50);\n      ctx.fill();\n    }\n  };\n\n  // Helper function to adjust colors\n  const adjustColor = (hexColor, amount) => {\n    // Convert hex to RGB\n    let r = parseInt(hexColor.substring(1, 3), 16);\n    let g = parseInt(hexColor.substring(3, 5), 16);\n    let b = parseInt(hexColor.substring(5, 7), 16);\n    \n    // Adjust RGB values\n    r = Math.max(0, Math.min(255, r + amount));\n    g = Math.max(0, Math.min(255, g + amount));\n    b = Math.max(0, Math.min(255, b + amount));\n    \n    // Convert back to hex\n    return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;\n  };\n\n  // Start visualization\n  const startVisualization = () => {\n    if (!analyserRef.current) {\n      console.error(\"Analyzer reference is null in startVisualization\");\n      return;\n    }\n    \n    const analyser = analyserRef.current;\n    \n    // Create data arrays for audio analysis\n    const bufferLength = analyser.frequencyBinCount;\n    const dataArray = new Uint8Array(bufferLength);\n    const timeArray = new Uint8Array(bufferLength);\n    \n    // Get initial data\n    analyser.getByteFrequencyData(dataArray);\n    analyser.getByteTimeDomainData(timeArray);\n    \n    // Cancel any existing animation frame\n    if (animationFrameRef.current) {\n      cancelAnimationFrame(animationFrameRef.current);\n    }\n    \n    // Reset animation time to ensure consistent animation speed\n    timeRef.current = 0;\n    \n    // Track frame timing for consistent animation speed\n    let lastFrameTime = performance.now();\n    const targetFrameRate = 30; // Reduced to 30 FPS for smoother, slower animations\n    const frameInterval = 1000 / targetFrameRate;\n    \n    // Handle 3D visualization\n    if (use3D) {\n      // For 3D, we need to continuously update the audio data\n      const update3DAudio = (currentTime) => {\n        animationFrameRef.current = requestAnimationFrame(update3DAudio);\n        \n        // Calculate delta time for smooth animation regardless of frame rate\n        const deltaTime = (currentTime - lastFrameTime) / frameInterval;\n        lastFrameTime = currentTime;\n        \n        // Increment time for animations with consistent speed\n        timeRef.current += 0.005 * Math.min(deltaTime, 2);\n        \n        // Get frequency and time domain data\n        analyser.getByteFrequencyData(dataArray);\n        analyser.getByteTimeDomainData(timeArray);\n        \n        // Update audio data for 3D visualizer with more efficient approach\n        const newDataArray = new Array(bufferLength);\n        const newTimeArray = new Array(bufferLength);\n        \n        // Use logarithmic sampling to focus more on lower frequencies\n        for (let i = 0; i < bufferLength; i++) {\n          // Logarithmic mapping to emphasize lower frequencies\n          const logIndex = Math.min(bufferLength - 1, Math.floor(Math.pow(i / bufferLength, 0.5) * bufferLength));\n          newDataArray[i] = dataArray[logIndex];\n          newTimeArray[i] = timeArray[logIndex];\n        }\n        \n        setAudioData({ \n          dataArray: newDataArray, \n          timeArray: newTimeArray, \n          bufferLength \n        });\n      };\n      \n      update3DAudio(performance.now());\n      return;\n    }\n    \n    // For 2D visualizations, ensure canvas exists\n    if (!canvasRef.current) {\n      console.error(\"Canvas reference is null in startVisualization for 2D visualization\");\n      return;\n    }\n    \n    const canvas = canvasRef.current;\n    const ctx = canvas.getContext('2d', { alpha: false }); // Optimize by disabling alpha\n    \n    // Cache parameter values outside the animation loop for better performance\n    let cachedParameters = { ...parameters };\n    \n    // Animation function for 2D visualizations\n    const draw = (currentTime) => {\n      animationFrameRef.current = requestAnimationFrame(draw);\n      \n      // Calculate delta time for smooth animation regardless of frame rate\n      const deltaTime = (currentTime - lastFrameTime) / frameInterval;\n      lastFrameTime = currentTime;\n      \n      // Increment time for animations with consistent speed\n      timeRef.current += 0.005 * Math.min(deltaTime, 2);\n      \n      // Get frequency and time domain data\n      analyser.getByteFrequencyData(dataArray);\n      analyser.getByteTimeDomainData(timeArray);\n      \n      // Clear canvas\n      ctx.fillStyle = 'rgb(0, 0, 0)';\n      ctx.fillRect(0, 0, canvas.width, canvas.height);\n      \n      // Check if parameters have changed\n      if (JSON.stringify(cachedParameters) !== JSON.stringify(parameters)) {\n        cachedParameters = { ...parameters };\n      }\n      \n      // Draw visualization based on template\n      switch (template) {\n        case 'waveform':\n          drawWaveform(ctx, dataArray, bufferLength, cachedParameters);\n          break;\n        case 'bars':\n          drawBars(ctx, dataArray, bufferLength, cachedParameters);\n          break;\n        case 'circles':\n          drawCircles(ctx, dataArray, bufferLength, cachedParameters);\n          break;\n        case 'kaleidoscope':\n          drawKaleidoscope(ctx, dataArray, timeArray, bufferLength, cachedParameters);\n          break;\n        case 'spiral':\n          drawSpiral(ctx, dataArray, timeArray, bufferLength, cachedParameters);\n          break;\n        case 'particles':\n          updateAndDrawParticles(ctx, dataArray, bufferLength, cachedParameters);\n          break;\n        case 'ripple':\n          drawRipples(ctx, dataArray, timeArray, bufferLength, cachedParameters);\n          break;\n        case 'terrain':\n          drawTerrain(ctx, dataArray, timeArray, bufferLength, cachedParameters);\n          break;\n        case 'starburst':\n          drawStarburst(ctx, dataArray, timeArray, bufferLength, cachedParameters);\n          break;\n        case 'fractal':\n          drawFractal(ctx, dataArray, timeArray, bufferLength, cachedParameters);\n          break;\n        case 'liquid':\n          drawLiquid(ctx, dataArray, timeArray, bufferLength, cachedParameters);\n          break;\n        default:\n          drawWaveform(ctx, dataArray, bufferLength, cachedParameters);\n      }\n    };\n    \n    draw(performance.now());\n  };\n\n  const drawWaveform = (ctx, dataArray, bufferLength, cachedParameters) => {\n    // Safety check - ensure canvas reference exists\n    if (!canvasRef.current) {\n      console.error(\"Canvas reference is null in drawWaveform\");\n      return;\n    }\n    \n    // Apply parameters\n    const lineWidth = cachedParameters.lineWidth || 3;\n    const color = cachedParameters.color || '#00aaff';\n    const reactivity = (cachedParameters.reactivity || 50) / 40; // Adjusted for better responsiveness\n    const smoothing = (cachedParameters.smoothing || 50) / 100; // Convert to 0-1 scale\n    \n    ctx.lineWidth = lineWidth;\n    ctx.strokeStyle = color;\n    ctx.beginPath();\n    \n    const sliceWidth = (canvasRef.current.width * 1.0) / bufferLength;\n    let x = 0;\n    \n    // Use fewer points for better performance\n    const step = Math.max(1, Math.floor(bufferLength / 256));\n    \n    for (let i = 0; i < bufferLength; i += step) {\n      const v = dataArray[i] / 128.0 * reactivity;\n      const y = v * canvasRef.current.height / 2;\n      \n      if (i === 0) {\n        ctx.moveTo(x, y);\n      } else {\n        // Apply smoothing if enabled\n        if (smoothing > 0) {\n          const prevX = x - sliceWidth * step;\n          const prevY = dataArray[i - step] / 128.0 * reactivity * canvasRef.current.height / 2;\n          const cpX1 = prevX + sliceWidth * step / 3;\n          const cpX2 = x - sliceWidth * step / 3;\n          const cpY1 = prevY;\n          const cpY2 = y;\n          \n          // Use bezier curve for smoothing\n          ctx.bezierCurveTo(cpX1, cpY1, cpX2, cpY2, x, y);\n        } else {\n          ctx.lineTo(x, y);\n        }\n      }\n      \n      x += sliceWidth * step;\n    }\n    \n    ctx.lineTo(canvasRef.current.width, canvasRef.current.height / 2);\n    ctx.stroke();\n  };\n\n  const drawBars = (ctx, dataArray, bufferLength, cachedParameters) => {\n    // Safety check - ensure canvas reference exists\n    if (!canvasRef.current) {\n      console.error(\"Canvas reference is null in drawBars\");\n      return;\n    }\n    \n    // Apply parameters\n    const color = cachedParameters.color || '#ff5500';\n    const barWidth = (cachedParameters.barWidth || 50) / 100; // Convert to 0-1 scale\n    const spacing = (cachedParameters.spacing || 30) / 100; // Convert to 0-1 scale\n    const reactivity = (cachedParameters.reactivity || 50) / 20; // Adjusted for better responsiveness\n    \n    const bars = Math.min(bufferLength, 128); // Reduced number of bars for better performance\n    const width = canvasRef.current.width;\n    const height = canvasRef.current.height;\n    \n    const barWidthPx = (width / bars) * barWidth;\n    const barSpacing = (width / bars) * spacing;\n    const totalBarWidth = barWidthPx + barSpacing;\n    \n    for (let i = 0; i < bars; i++) {\n      // Use logarithmic mapping to emphasize lower frequencies\n      // Focus more on the lower half of the frequency spectrum\n      const freqRatio = i / bars;\n      const dataIndex = Math.min(bufferLength - 1, Math.floor(Math.pow(freqRatio, 0.8) * (bufferLength / 2)));\n      \n      const barHeight = dataArray[dataIndex] * reactivity;\n      \n      const x = i * totalBarWidth;\n      const y = height - barHeight;\n      \n      ctx.fillStyle = adjustColor(color, (i / bars) * 30);\n      ctx.fillRect(x, y, barWidthPx, barHeight);\n    }\n  };\n\n  const drawCircles = (ctx, dataArray, bufferLength, cachedParameters) => {\n    // Safety check - ensure canvas reference exists\n    if (!canvasRef.current) {\n      console.error(\"Canvas reference is null in drawCircles\");\n      return;\n    }\n    \n    // Apply parameters\n    const color = cachedParameters.color || '#ff00ff';\n    const baseRadius = (cachedParameters.radius || 50) / 100 * Math.min(canvasRef.current.width, canvasRef.current.height) / 2;\n    const circleCount = Math.max(1, Math.min(20, Math.floor((cachedParameters.count || 50) / 5))); // 1-20 circles\n    const reactivity = (cachedParameters.reactivity || 50) / 40; // Adjusted for better responsiveness\n    \n    const centerX = canvasRef.current.width / 2;\n    const centerY = canvasRef.current.height / 2;\n    \n    // Draw circles\n    for (let c = 0; c < circleCount; c++) {\n      // Focus on lower frequencies for outer circles, higher frequencies for inner circles\n      const freqRatio = c / circleCount;\n      const freqIndex = Math.floor(Math.pow(freqRatio, 0.7) * (bufferLength / 2));\n      const circleIndex = Math.min(bufferLength - 1, freqIndex);\n      \n      const audioValue = dataArray[circleIndex] / 128.0 * reactivity;\n      \n      const radius = baseRadius * (c + 1) / circleCount * audioValue;\n      \n      ctx.beginPath();\n      ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);\n      ctx.strokeStyle = adjustColor(color, (c / circleCount) * 50);\n      ctx.stroke();\n    }\n  };\n\n  const drawKaleidoscope = (ctx, dataArray, timeArray, bufferLength, cachedParameters) => {\n    // Safety check - ensure canvas reference exists\n    if (!canvasRef.current) {\n      console.error(\"Canvas reference is null in drawKaleidoscope\");\n      return;\n    }\n    \n    // Apply parameters\n    const color = cachedParameters.color || '#ffaa00';\n    const segments = cachedParameters.segments || 8;\n    const speed = (cachedParameters.speed || 50) / 2000; // Reduced speed for slower rotation\n    const reactivity = (cachedParameters.reactivity || 50) / 40; // Adjusted for better responsiveness\n    \n    const centerX = canvasRef.current.width / 2;\n    const centerY = canvasRef.current.height / 2;\n    const radius = Math.min(centerX, centerY) * 0.8;\n    \n    // Rotate based on time and speed\n    ctx.translate(centerX, centerY);\n    ctx.rotate(timeRef.current * speed);\n    \n    // Draw kaleidoscope segments\n    for (let s = 0; s < segments; s++) {\n      ctx.rotate(Math.PI * 2 / segments);\n      \n      ctx.beginPath();\n      ctx.strokeStyle = adjustColor(color, s * 5);\n      \n      // Draw audio-reactive pattern\n      // Use fewer points for better performance\n      const step = Math.max(8, Math.floor(bufferLength / 64));\n      \n      for (let i = 0; i < bufferLength; i += step) {\n        // Focus on lower frequencies which typically contain more rhythm information\n        const dataIndex = Math.min(bufferLength - 1, Math.floor(Math.pow(i / bufferLength, 0.7) * bufferLength));\n        \n        const x = (dataArray[dataIndex] / 256.0) * radius * reactivity;\n        const y = (timeArray[dataIndex] / 256.0) * radius * reactivity;\n        \n        if (i === 0) {\n          ctx.moveTo(x, y);\n        } else {\n          ctx.lineTo(x, y);\n        }\n      }\n      \n      ctx.stroke();\n    }\n    \n    // Reset transformation\n    ctx.setTransform(1, 0, 0, 1, 0, 0);\n  };\n\n  const drawSpiral = (ctx, dataArray, timeArray, bufferLength, cachedParameters) => {\n    // Safety check - ensure canvas reference exists\n    if (!canvasRef.current) {\n      console.error(\"Canvas reference is null in drawSpiral\");\n      return;\n    }\n    \n    // Apply parameters\n    const color = cachedParameters.color || '#00ff99';\n    const arms = cachedParameters.arms || 5;\n    const speed = (cachedParameters.speed || 50) / 2000; // Reduced speed for slower rotation\n    const reactivity = (cachedParameters.reactivity || 50) / 40; // Adjusted for better responsiveness\n    \n    const centerX = canvasRef.current.width / 2;\n    const centerY = canvasRef.current.height / 2;\n    const maxRadius = Math.min(centerX, centerY) * 0.9;\n    \n    // Rotate based on time and speed\n    ctx.translate(centerX, centerY);\n    ctx.rotate(timeRef.current * speed);\n    \n    // Pre-calculate common values\n    const PI2 = Math.PI * 2;\n    const PI6 = Math.PI * 6;\n    \n    // Pre-calculate arm colors to avoid recalculating in the loop\n    const armColors = [];\n    for (let a = 0; a < arms; a++) {\n      armColors[a] = adjustColor(color, a * 10);\n    }\n    \n    // Draw spiral arms\n    for (let a = 0; a < arms; a++) {\n      const armAngle = (a / arms) * PI2;\n      \n      ctx.beginPath();\n      ctx.strokeStyle = armColors[a];\n      \n      // Use a more efficient approach for drawing the spiral\n      // but maintain the original visual appearance with 100 points\n      const pointsPerArm = 100;\n      \n      // Sample audio data less frequently for performance\n      const sampleStep = Math.max(1, Math.floor(bufferLength / 128));\n      \n      for (let i = 0; i < pointsPerArm; i++) {\n        const t = i / pointsPerArm;\n        const angle = armAngle + t * PI6;\n        const radius = t * maxRadius;\n        \n        // Apply audio reactivity - use a more efficient data sampling approach\n        // Focus on lower frequencies which typically contain more rhythm information\n        const freqIndex = Math.min(bufferLength - 1, Math.floor(t * bufferLength / 4));\n        const dataIndex = Math.min(bufferLength - 1, freqIndex);\n        const audioValue = dataArray[dataIndex] / 128.0 * reactivity;\n        \n        // Pre-calculate trig functions for performance\n        const cosAngle = Math.cos(angle);\n        const sinAngle = Math.sin(angle);\n        \n        const x = cosAngle * radius * audioValue;\n        const y = sinAngle * radius * audioValue;\n        \n        if (i === 0) {\n          ctx.moveTo(x, y);\n        } else {\n          ctx.lineTo(x, y);\n        }\n      }\n      \n      ctx.stroke();\n    }\n    \n    // Reset transformation\n    ctx.setTransform(1, 0, 0, 1, 0, 0);\n  };\n\n  // Add a new ripple visualization\n  const drawRipples = (ctx, dataArray, timeArray, bufferLength, cachedParameters) => {\n    // Safety check - ensure canvas reference exists\n    if (!canvasRef.current) {\n      console.error(\"Canvas reference is null in drawRipples\");\n      return;\n    }\n    \n    // Apply parameters\n    const color = cachedParameters.color || '#00ffff';\n    const reactivity = (cachedParameters.reactivity || 50) / 40;\n    const speed = (cachedParameters.speed || 50) / 50;\n    const density = (cachedParameters.density || 50) / 50;\n    \n    const width = canvasRef.current.width;\n    const height = canvasRef.current.height;\n    const centerX = width / 2;\n    const centerY = height / 2;\n    const maxRadius = Math.sqrt(width * width + height * height) / 2;\n    \n    // Initialize ripples array if it doesn't exist\n    if (!window.ripples) {\n      window.ripples = [];\n    }\n    \n    // Detect beats for creating new ripples\n    let bassEnergy = 0;\n    for (let i = 0; i < 8; i++) {\n      bassEnergy += dataArray[i];\n    }\n    bassEnergy = bassEnergy / (8 * 255);\n    \n    // Create new ripple on strong beats\n    if (bassEnergy > 0.6 && Math.random() < 0.3 * density) {\n      // Get a frequency band for this ripple's color\n      const freqBand = Math.floor(Math.random() * (bufferLength / 4));\n      const freqIntensity = dataArray[freqBand] / 255;\n      \n      // Create a new ripple\n      window.ripples.push({\n        radius: 0,\n        maxRadius: maxRadius * (0.3 + Math.random() * 0.7),\n        lineWidth: 1 + Math.random() * 4,\n        alpha: 0.7 + Math.random() * 0.3,\n        speed: (0.5 + Math.random() * 1.5) * speed,\n        color: adjustColor(color, freqIntensity * 50 - 25)\n      });\n    }\n    \n    // Draw and update ripples\n    for (let i = 0; i < window.ripples.length; i++) {\n      const ripple = window.ripples[i];\n      \n      // Update radius\n      ripple.radius += ripple.speed;\n      \n      // Decrease alpha as the ripple expands\n      ripple.alpha *= 0.98;\n      \n      // Draw ripple\n      ctx.beginPath();\n      ctx.arc(centerX, centerY, ripple.radius, 0, Math.PI * 2);\n      ctx.strokeStyle = ripple.color;\n      ctx.globalAlpha = ripple.alpha;\n      ctx.lineWidth = ripple.lineWidth;\n      ctx.stroke();\n      ctx.globalAlpha = 1.0;\n    }\n    \n    // Remove ripples that have expanded beyond their max radius or faded out\n    window.ripples = window.ripples.filter(ripple => \n      ripple.radius < ripple.maxRadius && ripple.alpha > 0.01\n    );\n  };\n\n  // Add a new terrain visualization\n  const drawTerrain = (ctx, dataArray, timeArray, bufferLength, cachedParameters) => {\n    // Safety check - ensure canvas reference exists\n    if (!canvasRef.current) {\n      console.error(\"Canvas reference is null in drawTerrain\");\n      return;\n    }\n    \n    // Apply parameters\n    const color = cachedParameters.color || '#33cc33';\n    const reactivity = (cachedParameters.reactivity || 50) / 40;\n    const detail = (cachedParameters.detail || 50) / 50;\n    const speed = (cachedParameters.speed || 50) / 100;\n    \n    const width = canvasRef.current.width;\n    const height = canvasRef.current.height;\n    \n    // Calculate number of terrain points based on detail parameter\n    const points = Math.max(20, Math.floor(width / (10 / detail)));\n    const pointWidth = width / points;\n    \n    // Create terrain heights based on audio data\n    const terrainHeights = [];\n    \n    // Sample audio data for terrain heights\n    for (let i = 0; i < points; i++) {\n      // Map point index to frequency data index\n      const dataIndex = Math.floor((i / points) * (bufferLength / 2));\n      \n      // Get audio value and apply reactivity\n      const audioValue = dataArray[dataIndex] / 255.0 * reactivity;\n      \n      // Calculate terrain height\n      const terrainHeight = height * 0.1 + audioValue * height * 0.6;\n      terrainHeights.push(terrainHeight);\n    }\n    \n    // Smooth terrain heights\n    const smoothedHeights = [];\n    for (let i = 0; i < points; i++) {\n      let sum = 0;\n      let count = 0;\n      \n      // Apply smoothing by averaging neighboring points\n      for (let j = Math.max(0, i - 2); j <= Math.min(points - 1, i + 2); j++) {\n        sum += terrainHeights[j];\n        count++;\n      }\n      \n      smoothedHeights.push(sum / count);\n    }\n    \n    // Create a gradient for the terrain\n    const gradient = ctx.createLinearGradient(0, height, 0, height / 2);\n    gradient.addColorStop(0, color);\n    gradient.addColorStop(1, adjustColor(color, 30));\n    \n    // Draw terrain\n    ctx.fillStyle = gradient;\n    ctx.beginPath();\n    ctx.moveTo(0, height);\n    \n    // Draw terrain path\n    for (let i = 0; i < points; i++) {\n      const x = i * pointWidth;\n      const y = height - smoothedHeights[i];\n      \n      if (i === 0) {\n        ctx.lineTo(x, y);\n      } else {\n        // Use quadratic curves for smoother terrain\n        const prevX = (i - 1) * pointWidth;\n        const prevY = height - smoothedHeights[i - 1];\n        const cpX = (prevX + x) / 2;\n        const cpY = (prevY + y) / 2;\n        \n        ctx.quadraticCurveTo(cpX, cpY, x, y);\n      }\n    }\n    \n    // Complete the path\n    ctx.lineTo(width, height);\n    ctx.closePath();\n    ctx.fill();\n    \n    // Draw a reflection effect\n    ctx.globalAlpha = 0.3;\n    ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';\n    \n    // Draw reflection path (inverted terrain)\n    ctx.beginPath();\n    ctx.moveTo(0, height);\n    \n    for (let i = 0; i < points; i++) {\n      const x = i * pointWidth;\n      const terrainY = height - smoothedHeights[i];\n      const reflectionHeight = smoothedHeights[i] * 0.3; // Smaller reflection\n      const y = height + reflectionHeight;\n      \n      if (i === 0) {\n        ctx.lineTo(x, y);\n      } else {\n        // Use quadratic curves for smoother terrain\n        const prevX = (i - 1) * pointWidth;\n        const prevY = height + smoothedHeights[i - 1] * 0.3;\n        const cpX = (prevX + x) / 2;\n        const cpY = (prevY + y) / 2;\n        \n        ctx.quadraticCurveTo(cpX, cpY, x, y);\n      }\n    }\n    \n    // Complete the reflection path\n    ctx.lineTo(width, height);\n    ctx.closePath();\n    ctx.fill();\n    \n    // Reset alpha\n    ctx.globalAlpha = 1.0;\n    \n    // Draw stars in the sky\n    if (!window.stars) {\n      // Initialize stars\n      window.stars = [];\n      const starCount = 50;\n      \n      for (let i = 0; i < starCount; i++) {\n        window.stars.push({\n          x: Math.random() * width,\n          y: Math.random() * height * 0.5,\n          size: 0.5 + Math.random() * 1.5,\n          brightness: 0.3 + Math.random() * 0.7\n        });\n      }\n    }\n    \n    // Draw stars with audio reactivity\n    for (let i = 0; i < window.stars.length; i++) {\n      const star = window.stars[i];\n      \n      // Make stars twinkle based on audio\n      const dataIndex = Math.floor(Math.random() * (bufferLength / 4));\n      const twinkle = 0.5 + (dataArray[dataIndex] / 255.0) * 0.5;\n      \n      ctx.fillStyle = `rgba(255, 255, 255, ${star.brightness * twinkle})`;\n      ctx.beginPath();\n      ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);\n      ctx.fill();\n    }\n  };\n\n  // Add a new starburst visualization\n  const drawStarburst = (ctx, dataArray, timeArray, bufferLength, cachedParameters) => {\n    // Safety check - ensure canvas reference exists\n    if (!canvasRef.current) {\n      console.error(\"Canvas reference is null in drawStarburst\");\n      return;\n    }\n    \n    // Apply parameters\n    const color = cachedParameters.color || '#ff9900';\n    const reactivity = (cachedParameters.reactivity || 50) / 40;\n    const particleCount = (cachedParameters.count || 50) / 50 * 100; // 0-100 particles\n    const particleSize = (cachedParameters.size || 50) / 50 * 5; // 0-5 size\n    \n    const width = canvasRef.current.width;\n    const height = canvasRef.current.height;\n    const centerX = width / 2;\n    const centerY = height / 2;\n    \n    // Initialize particles array if it doesn't exist\n    if (!window.starburstParticles) {\n      window.starburstParticles = [];\n    }\n    \n    // Detect beats for creating new bursts\n    let bassEnergy = 0;\n    for (let i = 0; i < 8; i++) {\n      bassEnergy += dataArray[i];\n    }\n    bassEnergy = bassEnergy / (8 * 255);\n    \n    // Create new burst on strong beats\n    if (bassEnergy > 0.6 && (window.lastBurstTime === undefined || timeRef.current - window.lastBurstTime > 0.5)) {\n      window.lastBurstTime = timeRef.current;\n      \n      // Create a burst of particles\n      const burstSize = Math.floor(particleCount * (0.5 + bassEnergy * 0.5));\n      const burstColor = adjustColor(color, (Math.random() * 40) - 20);\n      \n      for (let i = 0; i < burstSize; i++) {\n        const angle = Math.random() * Math.PI * 2;\n        const speed = (1 + Math.random() * 3) * reactivity;\n        const size = (0.5 + Math.random() * 1.5) * particleSize;\n        const life = 1.0; // Full life\n        \n        window.starburstParticles.push({\n          x: centerX,\n          y: centerY,\n          vx: Math.cos(angle) * speed,\n          vy: Math.sin(angle) * speed,\n          size: size,\n          color: burstColor,\n          life: life,\n          decay: 0.01 + Math.random() * 0.02 // Random decay rate\n        });\n      }\n    }\n    \n    // Clear canvas with fade effect for trails\n    ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';\n    ctx.fillRect(0, 0, width, height);\n    \n    // Update and draw particles\n    for (let i = 0; i < window.starburstParticles.length; i++) {\n      const particle = window.starburstParticles[i];\n      \n      // Update position\n      particle.x += particle.vx;\n      particle.y += particle.vy;\n      \n      // Apply gravity\n      particle.vy += 0.05;\n      \n      // Update life\n      particle.life -= particle.decay;\n      \n      // Draw particle\n      if (particle.life > 0) {\n        ctx.globalAlpha = particle.life;\n        ctx.fillStyle = particle.color;\n        ctx.beginPath();\n        ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);\n        ctx.fill();\n      }\n    }\n    \n    // Reset alpha\n    ctx.globalAlpha = 1.0;\n    \n    // Remove dead particles\n    window.starburstParticles = window.starburstParticles.filter(p => p.life > 0);\n  };\n\n  // Add a new fractal tree visualization\n  const drawFractal = (ctx, dataArray, timeArray, bufferLength, cachedParameters) => {\n    // Safety check - ensure canvas reference exists\n    if (!canvasRef.current) {\n      console.error(\"Canvas reference is null in drawFractal\");\n      return;\n    }\n    \n    // Apply parameters\n    const color = cachedParameters.color || '#66ff66';\n    const reactivity = (cachedParameters.reactivity || 50) / 40;\n    const complexity = (cachedParameters.complexity || 50) / 50; // 0-1 complexity\n    const variation = (cachedParameters.variation || 50) / 50; // 0-1 variation\n    \n    const width = canvasRef.current.width;\n    const height = canvasRef.current.height;\n    \n    // Clear canvas\n    ctx.fillStyle = 'rgb(0, 0, 0)';\n    ctx.fillRect(0, 0, width, height);\n    \n    // Calculate audio energy for different frequency bands\n    const lowEnergy = getAverageEnergy(dataArray, 0, 10) * reactivity;\n    const midEnergy = getAverageEnergy(dataArray, 10, 100) * reactivity;\n    const highEnergy = getAverageEnergy(dataArray, 100, 200) * reactivity;\n    \n    // Calculate tree parameters based on audio\n    const trunkLength = height * 0.25 * (0.8 + lowEnergy * 0.4);\n    const branchAngle = Math.PI / 6 + midEnergy * Math.PI / 12;\n    const branchRatio = 0.67 + highEnergy * 0.1;\n    \n    // Calculate max depth based on complexity\n    const maxDepth = Math.floor(4 + complexity * 4);\n    \n    // Draw tree\n    ctx.strokeStyle = color;\n    ctx.lineWidth = 2;\n    \n    // Start tree from bottom center\n    const startX = width / 2;\n    const startY = height * 0.9;\n    \n    // Draw trunk\n    ctx.beginPath();\n    ctx.moveTo(startX, startY);\n    ctx.lineTo(startX, startY - trunkLength);\n    ctx.stroke();\n    \n    // Draw branches recursively\n    drawBranch(\n      ctx, \n      startX, \n      startY - trunkLength, \n      trunkLength, \n      -Math.PI / 2, \n      maxDepth, \n      branchAngle, \n      branchRatio, \n      color,\n      variation,\n      timeRef.current\n    );\n    \n    // Helper function to calculate average energy in a frequency range\n    function getAverageEnergy(data, startBin, endBin) {\n      let sum = 0;\n      const binCount = Math.min(endBin - startBin, data.length - startBin);\n      \n      if (binCount <= 0) return 0;\n      \n      for (let i = startBin; i < startBin + binCount; i++) {\n        sum += data[i] / 255.0;\n      }\n      \n      return sum / binCount;\n    }\n    \n    // Recursive function to draw branches\n    function drawBranch(ctx, x, y, length, angle, depth, branchAngle, branchRatio, color, variation, time) {\n      if (depth === 0) return;\n      \n      // Calculate new branch length\n      const newLength = length * branchRatio;\n      \n      // Add some variation based on time\n      const timeVariation = Math.sin(time * 2 + depth) * variation * 0.1;\n      \n      // Calculate endpoints for left and right branches\n      const leftAngle = angle - branchAngle + timeVariation;\n      const rightAngle = angle + branchAngle + timeVariation;\n      \n      const leftX = x + Math.cos(leftAngle) * newLength;\n      const leftY = y + Math.sin(leftAngle) * newLength;\n      \n      const rightX = x + Math.cos(rightAngle) * newLength;\n      const rightY = y + Math.sin(rightAngle) * newLength;\n      \n      // Adjust color based on depth\n      const branchColor = adjustColor(color, depth * 10);\n      ctx.strokeStyle = branchColor;\n      \n      // Adjust line width based on depth\n      ctx.lineWidth = Math.max(1, 3 - depth * 0.5);\n      \n      // Draw left branch\n      ctx.beginPath();\n      ctx.moveTo(x, y);\n      ctx.lineTo(leftX, leftY);\n      ctx.stroke();\n      \n      // Draw right branch\n      ctx.beginPath();\n      ctx.moveTo(x, y);\n      ctx.lineTo(rightX, rightY);\n      ctx.stroke();\n      \n      // Recursively draw sub-branches\n      drawBranch(ctx, leftX, leftY, newLength, leftAngle, depth - 1, branchAngle, branchRatio, color, variation, time);\n      drawBranch(ctx, rightX, rightY, newLength, rightAngle, depth - 1, branchAngle, branchRatio, color, variation, time);\n    }\n  };\n\n  // Add a new liquid wave visualization\n  const drawLiquid = (ctx, dataArray, timeArray, bufferLength, cachedParameters) => {\n    // Safety check - ensure canvas reference exists\n    if (!canvasRef.current) {\n      console.error(\"Canvas reference is null in drawLiquid\");\n      return;\n    }\n    \n    // Apply parameters\n    const color = cachedParameters.color || '#0099ff';\n    const reactivity = (cachedParameters.reactivity || 50) / 40;\n    const complexity = (cachedParameters.complexity || 50) / 50; // 0-1 complexity\n    const speed = (cachedParameters.speed || 50) / 50; // 0-1 speed\n    \n    const width = canvasRef.current.width;\n    const height = canvasRef.current.height;\n    \n    // Initialize wave points if they don't exist\n    if (!window.liquidPoints) {\n      window.liquidPoints = [];\n      const pointCount = Math.floor(20 + complexity * 30); // 20-50 points based on complexity\n      \n      for (let i = 0; i < pointCount; i++) {\n        window.liquidPoints.push({\n          x: width * (i / (pointCount - 1)),\n          y: height / 2,\n          vy: 0\n        });\n      }\n    }\n    \n    // Ensure we have the right number of points if complexity changes\n    const targetPointCount = Math.floor(20 + complexity * 30);\n    if (window.liquidPoints.length !== targetPointCount) {\n      const newPoints = [];\n      for (let i = 0; i < targetPointCount; i++) {\n        if (i < window.liquidPoints.length) {\n          newPoints.push(window.liquidPoints[i]);\n        } else {\n          newPoints.push({\n            x: width * (i / (targetPointCount - 1)),\n            y: height / 2,\n            vy: 0\n          });\n        }\n      }\n      window.liquidPoints = newPoints;\n    }\n    \n    // Clear canvas with gradient background\n    const gradient = ctx.createLinearGradient(0, 0, 0, height);\n    gradient.addColorStop(0, 'rgb(0, 10, 30)');\n    gradient.addColorStop(1, 'rgb(0, 0, 10)');\n    ctx.fillStyle = gradient;\n    ctx.fillRect(0, 0, width, height);\n    \n    // Calculate audio energy for different frequency bands\n    const frequencyBands = 8;\n    const energyBands = [];\n    \n    for (let i = 0; i < frequencyBands; i++) {\n      const startBin = Math.floor((i / frequencyBands) * (bufferLength / 2));\n      const endBin = Math.floor(((i + 1) / frequencyBands) * (bufferLength / 2));\n      energyBands.push(getAverageEnergy(dataArray, startBin, endBin) * reactivity);\n    }\n    \n    // Update wave points based on audio\n    const pointCount = window.liquidPoints.length;\n    const dampening = 0.95;\n    const tension = 0.025;\n    const timeScale = speed * 0.5;\n    \n    // Apply forces to points\n    for (let i = 0; i < pointCount; i++) {\n      const point = window.liquidPoints[i];\n      \n      // Determine which frequency band affects this point\n      const bandIndex = Math.floor((i / pointCount) * frequencyBands);\n      const energy = energyBands[bandIndex];\n      \n      // Apply force based on audio energy\n      point.vy += (Math.random() * 2 - 1) * energy * 2;\n      \n      // Apply time-based oscillation\n      const timeOffset = (i / pointCount) * Math.PI * 2;\n      point.vy += Math.sin(timeRef.current * timeScale + timeOffset) * 0.2;\n      \n      // Apply physics\n      point.y += point.vy;\n      point.vy *= dampening;\n      \n      // Apply tension to return to center\n      point.vy += (height / 2 - point.y) * tension;\n    }\n    \n    // Draw the liquid\n    ctx.fillStyle = color;\n    ctx.beginPath();\n    ctx.moveTo(0, height);\n    \n    // Draw first point\n    ctx.lineTo(window.liquidPoints[0].x, window.liquidPoints[0].y);\n    \n    // Draw curve through points\n    for (let i = 0; i < pointCount - 1; i++) {\n      const current = window.liquidPoints[i];\n      const next = window.liquidPoints[i + 1];\n      \n      // Use quadratic curves for smoother liquid\n      const cpX = (current.x + next.x) / 2;\n      const cpY = (current.y + next.y) / 2;\n      \n      ctx.quadraticCurveTo(current.x, current.y, cpX, cpY);\n    }\n    \n    // Draw last point\n    const lastPoint = window.liquidPoints[pointCount - 1];\n    ctx.lineTo(lastPoint.x, lastPoint.y);\n    \n    // Complete the path\n    ctx.lineTo(width, height);\n    ctx.closePath();\n    ctx.fill();\n    \n    // Add highlights\n    ctx.strokeStyle = adjustColor(color, 30);\n    ctx.lineWidth = 2;\n    ctx.beginPath();\n    \n    // Draw curve through points for highlight\n    ctx.moveTo(window.liquidPoints[0].x, window.liquidPoints[0].y);\n    \n    for (let i = 0; i < pointCount - 1; i++) {\n      const current = window.liquidPoints[i];\n      const next = window.liquidPoints[i + 1];\n      \n      // Use quadratic curves for smoother liquid\n      const cpX = (current.x + next.x) / 2;\n      const cpY = (current.y + next.y) / 2;\n      \n      ctx.quadraticCurveTo(current.x, current.y, cpX, cpY);\n    }\n    \n    // Draw last point for highlight\n    ctx.lineTo(lastPoint.x, lastPoint.y);\n    ctx.stroke();\n    \n    // Add bubbles for extra effect\n    if (!window.liquidBubbles) {\n      window.liquidBubbles = [];\n    }\n    \n    // Create new bubbles based on audio energy\n    const bassEnergy = energyBands[0];\n    if (Math.random() < bassEnergy * 0.3) {\n      const bubbleX = Math.random() * width;\n      const bubbleSize = 2 + Math.random() * 8;\n      \n      window.liquidBubbles.push({\n        x: bubbleX,\n        y: height,\n        size: bubbleSize,\n        speed: 0.5 + Math.random() * 2,\n        opacity: 0.1 + Math.random() * 0.4\n      });\n    }\n    \n    // Update and draw bubbles\n    ctx.fillStyle = adjustColor(color, 50);\n    \n    for (let i = 0; i < window.liquidBubbles.length; i++) {\n      const bubble = window.liquidBubbles[i];\n      \n      // Update position\n      bubble.y -= bubble.speed;\n      \n      // Draw bubble\n      ctx.globalAlpha = bubble.opacity;\n      ctx.beginPath();\n      ctx.arc(bubble.x, bubble.y, bubble.size, 0, Math.PI * 2);\n      ctx.fill();\n    }\n    \n    // Reset alpha\n    ctx.globalAlpha = 1.0;\n    \n    // Remove bubbles that have risen to the top\n    window.liquidBubbles = window.liquidBubbles.filter(b => b.y > -b.size);\n    \n    // Helper function to calculate average energy in a frequency range\n    function getAverageEnergy(data, startBin, endBin) {\n      let sum = 0;\n      const binCount = Math.min(endBin - startBin, data.length - startBin);\n      \n      if (binCount <= 0) return 0;\n      \n      for (let i = startBin; i < startBin + binCount; i++) {\n        sum += data[i] / 255.0;\n      }\n      \n      return sum / binCount;\n    }\n  };\n\n  // Update parameters when initialParameters change - use a ref to avoid re-renders\n  useEffect(() => {\n    // Only log in development\n    if (process.env.NODE_ENV !== 'production') {\n      console.log(\"Visualizer received updated parameters:\", initialParameters);\n    }\n    \n    if (initialParameters && Object.keys(initialParameters).length > 0) {\n      // Use a simple update without triggering re-renders\n      setParameters(initialParameters);\n    }\n  }, [initialParameters]);\n\n  // Add a function to update parameters\n  const updateParameters = (newParameters) => {\n    // Only log in development\n    if (process.env.NODE_ENV !== 'production') {\n      console.log(\"Updating visualization parameters:\", newParameters);\n    }\n    \n    setParameters(newParameters);\n  };\n\n  return (\n    <div className=\"visualizer-container\">\n      <div \n        ref={containerRef}\n        className={`visualizer-aspect-container ${RESOLUTIONS[resolution].className}`}\n      >\n        {use3D ? (\n          <ThreeVisualizer \n            audioData={audioData}\n            template={template.replace('3d', '')} // Remove '3d' suffix for the ThreeVisualizer\n            isPlaying={isPlaying}\n            parameters={parameters}\n          />\n        ) : (\n          <canvas ref={canvasRef} className=\"visualizer-canvas\"></canvas>\n        )}\n        <div className=\"visualizer-overlay\"></div>\n        <div className=\"resolution-indicator\">{resolution} ({RESOLUTIONS[resolution].width}{RESOLUTIONS[resolution].height})</div>\n      </div>\n    </div>\n  );\n});\n\nexport default Visualizer; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}